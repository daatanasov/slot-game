{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"convertToList.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/convertToList.ts"],"sourcesContent":["export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n"],"names":[],"mappings":";;;;AAAO,MAAM,aAAgB,GAAA,CACzB,KACA,EAAA,SAAA,EACA,iBAAiB,KAErB,KAAA;IACI,IAAI,CAAC,KAAA,CAAM,OAAQ,CAAA,KAAK,CACxB,EAAA;QACI,KAAA,GAAQ;YAAC,KAAU;SAAA,CAAA;IAAA,CACvB;IAEA,IAAI,CAAC,SACL,EAAA;QACW,OAAA,KAAA,CAAA;IAAA,CACX;IAEQ,OAAA,KAAA,CAAyB,GAAI,CAAA,CAAC,IACtC,KAAA;QACQ,IAAA,OAAO,IAAS,KAAA,QAAA,IAAY,cAChC,EAAA;YACI,OAAO,UAAU,IAAc,CAAA,CAAA;QAAA,CACnC;QAEO,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;AACL","ignoreList":[0]}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"file":"Cache.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/cache/Cache.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"],"names":["key"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"file":"createStringVariations.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/createStringVariations.ts"],"sourcesContent":["function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,QAAS,CAAA,IAAA,EAAc,GAAiB,EAAA,KAAA,EAAe,MAAA,EAAkB,IAClF,EAAA;IACU,MAAA,EAAA,GAAK,GAAA,CAAI,KAAK,CAAA,CAAA;IAEpB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,EAAA,CAAG,MAAA,EAAQ,CAC/B,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,EAAA,CAAG,CAAC,CAAA,CAAA;QAEd,IAAA,KAAA,GAAQ,GAAI,CAAA,MAAA,GAAS,CACzB,EAAA;YACa,QAAA,CAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAO,KAAK,CAAA,EAAG,KAAK,CAAA,EAAG,GAAK,EAAA,KAAA,GAAQ,CAAG,EAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;QAAA,CAG7E,MAAA;YACI,IAAA,CAAK,IAAA,CAAK,IAAK,CAAA,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA,EAAG,KAAK,CAAC,CAAA,CAAA;QAAA,CAChD;IAAA,CACJ;AACJ,CAAA;AASO,SAAS,uBAAuB,MACvC,EAAA;IACI,MAAM,KAAQ,GAAA,YAAA,CAAA;IAER,MAAA,MAAA,GAAS,MAAO,CAAA,KAAA,CAAM,KAAK,CAAA,CAAA;IAEjC,MAAM,OAAiB,EAAC,CAAA;IAExB,IAAI,MACJ,EAAA;QACI,MAAM,MAAkB,EAAC,CAAA;QAElB,MAAA,CAAA,OAAA,CAAQ,CAAC,IAChB,KAAA;YAEU,MAAA,KAAA,GAAQ,KAAK,SAAU,CAAA,CAAA,EAAG,KAAK,MAAS,GAAA,CAAC,CAAE,CAAA,KAAA,CAAM,GAAG,CAAA,CAAA;YAE1D,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA,CAAA;QAAA,CACjB,CAAA,CAAA;QAED,QAAA,CAAS,MAAQ,EAAA,GAAA,EAAK,CAAG,EAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;IAAA,CAGzC,MAAA;QACI,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA,CAAA;IAAA,CACpB;IAEO,OAAA,IAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"file":"isSingleItem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/isSingleItem.ts"],"sourcesContent":["/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n"],"names":[],"mappings":";;;;AAIO,MAAM,eAAe,CAAC,IAAA,GAA4B,CAAC,KAAA,CAAM,OAAA,CAAQ,IAAI","ignoreList":[0]}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"file":"Resolver.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/resolver/Resolver.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n"],"names":["src"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 722, "column": 0}, "map": {"version":3,"file":"LoaderParser.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts"],"sourcesContent":["import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/** A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n"],"names":["LoaderParserPriority"],"mappings":";;;;AAUY,IAAA,oBAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,qBAAL,KAAA;IAGHA,qBAAAA,CAAAA,qBAAAA,CAAA,MAAA,GAAM,CAAN,CAAA,GAAA,KAAA,CAAA;IAEAA,qBAAAA,CAAAA,qBAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IAEAA,qBAAAA,CAAAA,qBAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,qBAAAA,CAAAA;AAAA,CAAA,EAAA,oBAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 740, "column": 0}, "map": {"version":3,"file":"copySearchParams.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/copySearchParams.ts"],"sourcesContent":["/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n"],"names":[],"mappings":";;;;AAMa,MAAA,gBAAA,GAAmB,CAAC,SAAA,EAAmB,SACpD,KAAA;IACI,MAAM,YAAe,GAAA,SAAA,CAAU,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA;IAE3C,IAAI,YACJ,EAAA;QACI,SAAA,IAAa,CAAA,CAAA,EAAI,YAAY,CAAA,CAAA,CAAA;IAAA,CACjC;IAEO,OAAA,SAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"file":"Loader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/Loader.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n\n                    warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser should have a name`);\n                    // #endif\n                }\n                else if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n"],"names":["parser"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 919, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"file":"BackgroundLoader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/BackgroundLoader.ts"],"sourcesContent":["import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof assets\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,gBACb,CAAA;IAAA;;;GAAA,GAqBI,WAAA,CAAY,MAAgB,EAAA,OAAA,GAAU,KACtC,CAAA;QACI,IAAA,CAAK,OAAU,GAAA,MAAA,CAAA;QACf,IAAA,CAAK,UAAA,GAAa,EAAC,CAAA;QACnB,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;QAClB,IAAA,CAAK,cAAiB,GAAA,CAAA,CAAA;QACtB,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;IAAA,CACnB;IAAA;;;GAAA,GAMO,IAAI,SACX,EAAA;QACc,SAAA,CAAA,OAAA,CAAQ,CAAC,CACnB,KAAA;YACS,IAAA,CAAA,UAAA,CAAW,IAAA,CAAK,CAAC,CAAA,CAAA;QAAA,CACzB,CAAA,CAAA;QAED,IAAI,IAAA,CAAK,OACT,EAAA;YAEY,OAAA,CAAA,GAAA,CAAI,6BAA+B,EAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAAA,CAC9D;QAEA,IAAI,IAAK,CAAA,SAAA,IAAa,CAAC,IAAA,CAAK,UAC5B,EAAA;YACI,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;IAAA;;;;GAAA,GAOA,MAAc,KACd,GAAA;QACI,IAAI,IAAK,CAAA,UAAA,CAAW,MAAU,IAAA,IAAA,CAAK,SACnC,EAAA;YACI,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;YAElB,MAAM,SAAS,EAAC,CAAA;YAEhB,MAAM,eAAe,IAAK,CAAA,GAAA,CAAI,IAAA,CAAK,UAAW,CAAA,MAAA,EAAQ,IAAA,CAAK,cAAc,CAAA,CAAA;YAEzE,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,EAAc,CAClC,EAAA,CAAA;gBACI,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,UAAW,CAAA,GAAA,EAAK,CAAA,CAAA;YAAA,CACrC;YAEM,MAAA,IAAA,CAAK,OAAQ,CAAA,IAAA,CAAK,MAAM,CAAA,CAAA;YAE9B,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;YAElB,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;IAAA;;;GAAA,GAMA,IAAI,MACJ,GAAA;QACI,OAAO,IAAK,CAAA,SAAA,CAAA;IAAA,CAChB;IAEA,IAAI,OAAO,KACX,EAAA;QACI,IAAI,IAAA,CAAK,SAAc,KAAA,KAAA,EAAO,OAAA;QAE9B,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;QAEb,IAAA,KAAA,IAAS,CAAC,IAAA,CAAK,UACnB,EAAA;YACI,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"file":"cacheTextureArray.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @memberof assets\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,iBAA4C,GAAA;IACrD,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,WAAA;QACpB,IAAM,EAAA,mBAAA;IAAA,CACV;IAEA,IAAM,EAAA,CAAC,KAAiB,GAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAK,IAAA,KAAA,CAAM,KAAM,CAAA,CAAC,CAAM,GAAA,CAAA,yMAAa,UAAO,CAAA;IAEvF,kBAAA,EAAoB,CAAC,IAAA,EAAgB,KACrC,KAAA;QACI,MAAM,MAA+B,CAAA,CAAC,CAAA;QAEjC,IAAA,CAAA,OAAA,CAAQ,CAAC,GACd,KAAA;YACU,KAAA,CAAA,OAAA,CAAQ,CAAC,IAAA,EAAe,CAC9B,KAAA;gBACI,GAAA,CAAI,MAAA,CAAO,CAAM,KAAA,CAAA,GAAI,EAAK,GAAA,CAAA,GAAI,CAAA,CAAE,CAAI,GAAA,IAAA,CAAA;YAAA,CACvC,CAAA,CAAA;QAAA,CACJ,CAAA,CAAA;QAEM,OAAA,GAAA,CAAA;IAAA,CACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"file":"detectDefaults.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @memberof assets\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;AAIA,MAAM,YAAe,GAAA;IAAC,KAAO;IAAA,KAAA;IAAO,MAAM;CAAA,CAAA;AAMnC,MAAM,cAAiB,GAAA;IAC1B,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA,CAAA;IAAA,CACd;IACA,IAAM,EAAA,IAAwB,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA;IAClD,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG,OAAA,EAAS;eAAG,YAAY;SAAA;IACpD,MAAA,EAAQ,OAAO,OAAA,GAAY,OAAQ,CAAA,MAAA,CAAO,CAAC,CAAA,GAAM,CAAC,YAAA,CAAa,QAAS,CAAA,CAAC,CAAC,CAAA;AAC9E","ignoreList":[0]}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1056, "column": 0}, "map": {"version":3,"file":"testImageFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts"],"sourcesContent":["export async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (_e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"],"names":[],"mappings":";;;;AAAA,eAAsB,gBAAgB,SACtC,EAAA;IAII,IAAI,WAAW,UACf,EAAA;QACW,OAAA,IAAI,OAAiB,CAAA,CAAC,OAC7B,KAAA;YACU,MAAA,KAAA,GAAQ,IAAI,KAAM,EAAA,CAAA;YAExB,KAAA,CAAM,MAAA,GAAS,MACf;gBACI,OAAA,CAAQ,IAAI,CAAA,CAAA;YAAA,CAChB,CAAA;YACA,KAAA,CAAM,OAAA,GAAU,MAChB;gBACI,OAAA,CAAQ,KAAK,CAAA,CAAA;YAAA,CACjB,CAAA;YACA,KAAA,CAAM,GAAM,GAAA,SAAA,CAAA;QAAA,CACf,CAAA,CAAA;IAAA,CACL;IAEI,IAAA,mBAAA,IAAuB,UAAc,IAAA,OAAA,IAAW,UACpD,EAAA;QAEI,IAAA;YACI,MAAM,OAAO,MAAO,CAAA,MAAM,KAAM,CAAA,SAAS,CAAA,EAAG,IAAK,EAAA,CAAA;YAEjD,MAAM,kBAAkB,IAAI,CAAA,CAAA;QAAA,EAAA,OAEzB,EACP,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAEO,OAAA,KAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 1086, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"file":"detectAvif.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @memberof assets\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,UAAoC,GAAA;IAC7C,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,MAAM,UAA8B,6MAAA,EAAA,mCAAA;QAEhC,ybAAA;IAEJ,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE","ignoreList":[0]}},
    {"offset": {"line": 1115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1121, "column": 0}, "map": {"version":3,"file":"detectWebp.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @memberof assets\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,UAAa,GAAA;IACtB,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,MAAM,UAA8B,6MAAA,EAChC,6EAAA;IAEJ,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE","ignoreList":[0]}},
    {"offset": {"line": 1143, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1149, "column": 0}, "map": {"version":3,"file":"testVideoFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts"],"sourcesContent":["const inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,QAAW,GAAA,mBAAA,IAAuB,UACjC,IAAA,UAAA,YAAuB,UAAmB,CAAA,iBAAA,CAAA;AAE1C,SAAS,gBAAgB,QAChC,EAAA;IACI,IAAI,QACJ,EAAA;QACW,OAAA,KAAA,CAAA;IAAA,CACX;IAEM,MAAA,KAAA,GAAQ,QAAS,CAAA,aAAA,CAAc,OAAO,CAAA,CAAA;IAErC,OAAA,KAAA,CAAM,WAAY,CAAA,QAAQ,CAAM,KAAA,EAAA,CAAA;AAC3C","ignoreList":[0]}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1169, "column": 0}, "map": {"version":3,"file":"detectMp4.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @memberof assets\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,SAAY,GAAA;IACrB,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,UAA8B,6MAAA,EAAgB,WAAW,CAAA;IAC/D,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG,OAAA;YAAS;YAAO,KAAK;SAAA;IACjD,MAAA,EAAQ,OAAO,OAAA,GAAY,OAAQ,CAAA,MAAA,CAAO,CAAC,CAAM,GAAA,CAAA,KAAM,KAAS,IAAA,CAAA,KAAM,KAAK,CAAA;AAC/E","ignoreList":[0]}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"file":"detectOgv.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @memberof assets\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,SAAY,GAAA;IACrB,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,UAA8B,6MAAA,EAAgB,WAAW,CAAA;IAC/D,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,KAAK;SAAA;IAC1C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,KAAK,CAAA;AAChE","ignoreList":[0]}},
    {"offset": {"line": 1220, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"file":"detectWebm.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @memberof assets\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,UAAa,GAAA;IACtB,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,UAA8B,6MAAA,EAAgB,YAAY,CAAA;IAChE,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE","ignoreList":[0]}},
    {"offset": {"line": 1248, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1254, "column": 0}, "map": {"version":3,"file":"checkDataUrl.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/checkDataUrl.ts"],"sourcesContent":["export function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,YAAA,CAAa,GAAA,EAAa,KAC1C,EAAA;IACQ,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CACvB,EAAA;QACI,KAAA,MAAW,QAAQ,KACnB,CAAA;YACI,IAAI,GAAI,CAAA,UAAA,CAAW,CAAQ,KAAA,EAAA,IAAI,CAAE,CAAA,CAAA,EAAU,OAAA,IAAA,CAAA;QAAA,CAC/C;QAEO,OAAA,KAAA,CAAA;IAAA,CACX;IAEA,OAAO,GAAI,CAAA,UAAA,CAAW,CAAQ,KAAA,EAAA,KAAK,CAAE,CAAA,CAAA,CAAA;AACzC","ignoreList":[0]}},
    {"offset": {"line": 1269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1275, "column": 0}, "map": {"version":3,"file":"checkExtension.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/utils/checkExtension.ts"],"sourcesContent":["import { path } from '../../utils/path';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n"],"names":[],"mappings":";;;;;;AAEgB,SAAA,cAAA,CAAe,GAAA,EAAa,SAC5C,EAAA;IACI,MAAM,OAAU,GAAA,GAAA,CAAI,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA;IAChC,MAAM,GAAM,uJAAA,OAAA,CAAK,OAAQ,CAAA,OAAO,EAAE,WAAY,EAAA,CAAA;IAE1C,IAAA,KAAA,CAAM,OAAQ,CAAA,SAAS,CAC3B,EAAA;QACW,OAAA,SAAA,CAAU,QAAA,CAAS,GAAG,CAAA,CAAA;IAAA,CACjC;IAEA,OAAO,GAAQ,KAAA,SAAA,CAAA;AACnB","ignoreList":[0]}},
    {"offset": {"line": 1291, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1297, "column": 0}, "map": {"version":3,"file":"loadJson.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadJson',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAQA,MAAM,kBAAqB,GAAA,OAAA,CAAA;AAC3B,MAAM,aAAgB,GAAA,kBAAA,CAAA;AAMf,MAAM,QAAW,GAAA;IACpB,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,UAAA;QACpB,4LAAU,uBAAqB,CAAA,GAAA;IAAA,CACnC;IAEA,IAAM,EAAA,UAAA;IAEN,MAAK,GACL,EAAA;QACI,iLAAO,eAAA,EAAa,GAAK,EAAA,aAAa,CAAK,gLAAA,iBAAA,EAAe,KAAK,kBAAkB,CAAA,CAAA;IAAA,CACrF;IAEA,MAAM,MAAQ,GACd,EAAA;QACI,MAAM,WAAW,mKAAM,aAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;QAE3C,MAAA,IAAA,GAAO,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;QAE1B,OAAA,IAAA,CAAA;IAAA,CACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1336, "column": 0}, "map": {"version":3,"file":"loadTxt.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @memberof assets\n */\nexport const loadTxt = {\n\n    name: 'loadTxt',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAQA,MAAM,iBAAoB,GAAA,MAAA,CAAA;AAC1B,MAAM,YAAe,GAAA,YAAA,CAAA;AAMd,MAAM,OAAU,GAAA;IAEnB,IAAM,EAAA,SAAA;IAEN,SAAW,EAAA;QACP,MAAM,+KAAc,CAAA,UAAA;QACpB,4LAAU,uBAAqB,CAAA,GAAA;QAC/B,IAAM,EAAA,SAAA;IAAA,CACV;IAEA,MAAK,GACL,EAAA;QACI,QAAO,wLAAA,EAAa,GAAK,EAAA,YAAY,CAAK,gLAAA,iBAAA,EAAe,KAAK,iBAAiB,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,MAAK,GACX,EAAA;QACI,MAAM,WAAW,mKAAM,aAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;QAE3C,MAAA,GAAA,GAAM,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;QAEzB,OAAA,GAAA,CAAA;IAAA,CACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1370, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1376, "column": 0}, "map": {"version":3,"file":"loadWebFont.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Data for loading a font\n * @memberof assets\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @memberof assets\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @memberof assets\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadWebFont',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            Cache.set(`${name}-and-url`, {\n                url,\n                fontFaces,\n            });\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) =>\n            {\n                Cache.remove(t.family);\n                DOMAdapter.get().getFontFaceSet().delete(t);\n            });\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"file":"createTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts"],"sourcesContent":["import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAcgB,SAAA,aAAA,CAAc,MAAuB,EAAA,MAAA,EAAgB,GACrE,EAAA;IACI,MAAA,CAAO,KAAQ,GAAA,GAAA,CAAA;IACf,MAAA,CAAO,aAAgB,GAAA,GAAA,CAAA;IAEjB,MAAA,OAAA,GAAU,iMAAI,UAAQ,CAAA;QACxB,MAAA;QACA,KAAO,EAAA,GAAA;IAAA,CACV,CAAA,CAAA;IAED,MAAM,SAAS,MACf;QACW,OAAA,MAAA,CAAO,YAAA,CAAa,GAAG,CAAA,CAAA;QAE1B,mKAAA,QAAA,CAAM,GAAI,CAAA,GAAG,CACjB,EAAA;2KACI,QAAA,CAAM,MAAA,CAAO,GAAG,CAAA,CAAA;QAAA,CACpB;IAAA,CACJ,CAAA;IAGQ,OAAA,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,MAC/B;QACQ,IAAA,MAAA,CAAO,YAAa,CAAA,GAAG,CAC3B,EAAA;+KAEI,OAAA,EAAK,4IAC0D,CAAA,CAAA;YAGxD,MAAA,EAAA,CAAA;QAAA,CACX;IAAA,CACH,CAAA,CAAA;IAEO,OAAA,CAAA,IAAA,CAAK,WAAW,MACxB;QACQ,IAAA,CAAC,OAAO,SACZ,EAAA;+KAEI,OAAA,EAAK,gIACsD,CAAA,CAAA;YAGpD,MAAA,EAAA,CAAA;QAAA,CACX;IAAA,CACH,CAAA,CAAA;IAEM,OAAA,OAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 1541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1547, "column": 0}, "map": {"version":3,"file":"loadSVG.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the [loadSVG]{@link assets.loadSVG} plugin.\n * @see assets.loadSVG\n * @memberof assets\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    name: 'loadSVG',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: HTMLImageElement['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const blobUrl = URL.createObjectURL(blob);\n\n    const image = new Image();\n\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    URL.revokeObjectURL(blobUrl);\n\n    // convert to canvas...\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1630, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1636, "column": 0}, "map": {"version":3,"file":"WorkerManager.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts"],"sourcesContent":["import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    private readonly _workerPool: Worker[];\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n"],"names":["CheckImageBitmapWorker","LoadImageBitmapWorker"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"file":"loadTextures.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link assets.loadTextures} plugin.\n * @see assets.loadTextures\n * @memberof assets\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link assets.LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof assets\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1841, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1847, "column": 0}, "map": {"version":3,"file":"loadVideoTextures.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @memberof assets\n */\nexport function crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @memberof assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Asset.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @memberof assets\n */\nexport const loadVideoTextures = {\n\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<VideoSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: VideoSourceOptions = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, VideoSourceOptions>;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1985, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1991, "column": 0}, "map": {"version":3,"file":"resolveTextureUrl.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @memberof assets\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n"],"names":[],"mappings":";;;;;;;;;;AAUO,MAAM,iBAAoB,GAAA;IAC7B,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,aAAA;QACpB,IAAM,EAAA,gBAAA;IAAA,CACV;IACA,oMAAM,eAAa,CAAA,IAAA;IACnB,KAAA,EAAO,CAAC,KACH,GAAA,CAAA;YACG,UAAA,EAAY,gLAAW,WAAS,CAAA,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,EAAA,CAAI,CAAC,CAAA,IAAK,GAAG,CAAA;YACrE,MAAQ,EAAA,KAAA,CAAM,KAAM,CAAA,GAAG,EAAE,GAAI,EAAA;YAC7B,GAAK,EAAA,KAAA;QAAA,CACT,CAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2021, "column": 0}, "map": {"version":3,"file":"resolveJsonUrl.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @memberof assets\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n"],"names":[],"mappings":";;;;;;;;;;AAWO,MAAM,cAAiB,GAAA;IAC1B,SAAW,EAAA;QACP,qKAAM,gBAAc,CAAA,aAAA;QACpB,QAAU,EAAA,CAAA,CAAA;QACV,IAAM,EAAA,aAAA;IAAA,CACV;IACA,IAAA,EAAM,CAAC,KAAA,wKACH,WAAS,CAAA,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,IAAK,KAAM,CAAA,QAAA,CAAS,OAAO,CAAA;IAChE,gMAAO,oBAAkB,CAAA,KAAA;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"file":"Assets.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/assets/Assets.ts"],"sourcesContent":["/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback for when progress on asset loading is made.\n * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n * of the assets loaded.\n * @memberof assets\n * @callback ProgressCallback\n * @param {number} progress - The percentage (0.0 - 1.0) of the assets loaded.\n * @returns {void}\n * @example\n * (progress) => console.log(progress * 100 + '%')\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for the Assets Class.\n * @memberof assets\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is preferred) or a single resolutions  */\n        resolution?: number | number[];\n        /**\n         * the formats you prefer, by default this will be:\n         * ['avif', 'webp', 'png', 'jpg', 'jpeg', 'webm', 'mp4', 'm4v', 'ogv']\n         */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * If true, don't attempt to detect whether browser has preferred formats available.\n     * May result in increased performance as it skips detection step.\n     */\n    skipDetections?: boolean;\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @namespace assets\n *\n * Use the singleton class [Assets]{@link assets.Assets} to easily load and manage all your assets.\n *\n * ```typescript\n * import { Assets, Texture } from 'pixi.js';\n *\n * const bunnyTexture = await Assets.load<Texture>('bunny.png');\n * const sprite = new Sprite(bunnyTexture);\n * ```\n *\n * Check out the sections below for more information on how to deal with assets.\n *\n * <details id=\"assets-loading\">\n *\n * <summary>Asset Loading</summary>\n *\n * Do not be afraid to load things multiple times - under the hood, it will **NEVER** load anything more than once.\n *\n * *For example:*\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box Pixi supports the following files:\n * - Textures (**_avif_**, **_webp_**, **_png_**, **_jpg_**, **_gif_**, **_svg_**) via {@link assets.loadTextures}, {@link assets.loadSvg}\n * - Video Textures (**_mp4_**, **_m4v_**, **_webm_**, **_ogg_**, **_ogv_**, **_h264_**, **_avi_**, **_mov_**) via {@link assets.loadVideoTextures}\n * - Sprite sheets (**_json_**) via {@link assets.spritesheetAsset}\n * - Bitmap fonts (**_xml_**, **_fnt_**, **_txt_**) via {@link assets.loadBitmapFont}\n * - Web fonts (**_ttf_**, **_woff_**, **_woff2_**) via {@link assets.loadWebFont}\n * - JSON files (**_json_**) via {@link assets.loadJson}\n * - Text Files (**_txt_**) via {@link assets.loadTxt}\n * <br/>\n * More types can be added fairly easily by creating additional {@link assets.LoaderParser LoaderParsers}.\n * </details>\n *\n * <details id=\"textures\">\n *\n * <summary>Textures</summary>\n *\n * - Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via `Texture.from()` (see {@link core.from|Texture.from})\n * and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist\n * (for example you prefer 2x resolutions images but only 1x is available for that texture,\n * the Assets manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name: `my-spritesheet{resolution}.{imageFormat}.json`\n * <br><br>For example:\n *   - `my-spritesheet@2x.webp.json`* // 2x resolution, WebP sprite sheet*\n *   - `my-spritesheet@0.5x.png.json`* // 0.5x resolution, png sprite sheet*\n * - This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n * </details>\n *\n * <details id=\"fonts\">\n *\n * <summary>Fonts</summary>\n *\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * </details>\n *\n * <details id=\"background-loading\">\n *\n * <summary>Background Loading</summary>\n *\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n * </details>\n *\n * <details id=\"manifests-and-bundles\">\n *\n * <summary>Manifest and Bundles</summary>\n *\n * - {@link assets.AssetsManifest Manifest} is a descriptor that contains a list of all assets and their properties.\n * - {@link assets.AssetsBundle Bundles} are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     alias: 'background',\n *                     src: 'sunset.png',\n *                 },\n *                 {\n *                     alias: 'bar',\n *                     src: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     alias: 'character',\n *                     src: 'robot.png',\n *                 },\n *                 {\n *                     alias: 'enemy',\n *                     src: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Assets.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * </details>\n */\n\n/**\n * The global Assets class, it's a singleton so you don't need to instantiate it.\n *\n * **The `Assets` class has four main responsibilities:**\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n *\n * **It also has a few advanced features:**\n * 1. Allows developers to provide a {@link assets.Manifest} upfront of all assets and help manage\n * them via {@link assets.AssetsBundles Bundles}.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n * @memberof assets\n * @class Assets\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /** The loader, loads stuff! */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {assets.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Assets manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny.{png,webp}',\n     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n     *\n     * Assets.add({\n     *     alias: 'bunnyBooBoo',\n     *     src: [\n     *         'bunny.png',\n     *         'bunny.webp',\n     *    ],\n     * });\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param assets - the unresolved assets to add to the resolver\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Assets.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your initial load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n"],"names":["resolveResult"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}