module.exports = {

"[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "ExtensionType": (()=>ExtensionType),
    "extensions": (()=>extensions),
    "normalizeExtensionPriority": (()=>normalizeExtensionPriority)
});
"use strict";
var ExtensionType = /* @__PURE__ */ ((ExtensionType2)=>{
    ExtensionType2["Application"] = "application";
    ExtensionType2["WebGLPipes"] = "webgl-pipes";
    ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
    ExtensionType2["WebGLSystem"] = "webgl-system";
    ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
    ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
    ExtensionType2["WebGPUSystem"] = "webgpu-system";
    ExtensionType2["CanvasSystem"] = "canvas-system";
    ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
    ExtensionType2["CanvasPipes"] = "canvas-pipes";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    ExtensionType2["MaskEffect"] = "mask-effect";
    ExtensionType2["BlendMode"] = "blend-mode";
    ExtensionType2["TextureSource"] = "texture-source";
    ExtensionType2["Environment"] = "environment";
    ExtensionType2["ShapeBuilder"] = "shape-builder";
    ExtensionType2["Batcher"] = "batcher";
    return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext)=>{
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? {
            type: ext.extension
        } : ext.extension;
        ext = {
            ...metadata,
            ref: ext
        };
    }
    if (typeof ext === "object") {
        ext = {
            ...ext
        };
    } else {
        throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
        ext.type = [
            ext.type
        ];
    }
    return ext;
};
const normalizeExtensionPriority = (ext, defaultPriority)=>normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
    /** @ignore */ _addHandlers: {},
    /** @ignore */ _removeHandlers: {},
    /** @ignore */ _queue: {},
    /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {extensions} For chaining.
   */ remove (...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext)=>{
            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));
        });
        return this;
    },
    /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {extensions} For chaining.
   */ add (...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext)=>{
            ext.type.forEach((type)=>{
                const handlers = this._addHandlers;
                const queue = this._queue;
                if (!handlers[type]) {
                    queue[type] = queue[type] || [];
                    queue[type]?.push(ext);
                } else {
                    handlers[type]?.(ext);
                }
            });
        });
        return this;
    },
    /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns {extensions} For chaining.
   */ handle (type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
            queue[type]?.forEach((ext)=>onAdd(ext));
            delete queue[type];
        }
        return this;
    },
    /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {extensions} For chaining.
   */ handleByMap (type, map) {
        return this.handle(type, (extension)=>{
            if (extension.name) {
                map[extension.name] = extension.ref;
            }
        }, (extension)=>{
            if (extension.name) {
                delete map[extension.name];
            }
        });
    },
    /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns {extensions} For chaining.
   */ handleByNamedList (type, map, defaultPriority = -1) {
        return this.handle(type, (extension)=>{
            const index = map.findIndex((item)=>item.name === extension.name);
            if (index >= 0) return;
            map.push({
                name: extension.name,
                value: extension.ref
            });
            map.sort((a, b)=>normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
        }, (extension)=>{
            const index = map.findIndex((item)=>item.name === extension.name);
            if (index !== -1) {
                map.splice(index, 1);
            }
        });
    },
    /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {extensions} For chaining.
   */ handleByList (type, list, defaultPriority = -1) {
        return this.handle(type, (extension)=>{
            if (list.includes(extension.ref)) {
                return;
            }
            list.push(extension.ref);
            list.sort((a, b)=>normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
        }, (extension)=>{
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
                list.splice(index, 1);
            }
        });
    }
};
;
 //# sourceMappingURL=Extensions.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/browser/isMobile.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "isMobile": (()=>isMobile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ismobilejs/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ismobilejs/esm/isMobile.js [app-ssr] (ecmascript)");
;
"use strict";
const isMobileCall = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].default ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
const isMobile = isMobileCall(globalThis.navigator);
;
 //# sourceMappingURL=isMobile.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/data/removeItems.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "removeItems": (()=>removeItems)
});
"use strict";
function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i;
    if (startIdx >= length || removeCount === 0) {
        return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for(i = startIdx; i < len; ++i){
        arr[i] = arr[i + removeCount];
    }
    arr.length = len;
}
;
 //# sourceMappingURL=removeItems.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "resetUids": (()=>resetUids),
    "uid": (()=>uid)
});
"use strict";
const uidCache = {
    default: -1
};
function uid(name = "default") {
    if (uidCache[name] === void 0) {
        uidCache[name] = -1;
    }
    return ++uidCache[name];
}
function resetUids() {
    for(const key in uidCache){
        delete uidCache[key];
    }
}
;
 //# sourceMappingURL=uid.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "deprecation": (()=>deprecation),
    "v8_0_0": (()=>v8_0_0),
    "v8_3_4": (()=>v8_3_4)
});
"use strict";
const warnings = {};
const v8_0_0 = "8.0.0";
const v8_3_4 = "8.3.4";
function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
        return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (console.groupCollapsed) {
            console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
            console.warn(stack);
            console.groupEnd();
        } else {
            console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
            console.warn(stack);
        }
    }
    warnings[message] = true;
}
;
 //# sourceMappingURL=deprecation.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/pool/Pool.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Pool": (()=>Pool)
});
"use strict";
class Pool {
    /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */ constructor(ClassType, initialSize){
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
            this.prepopulate(initialSize);
        }
    }
    /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */ prepopulate(total) {
        for(let i = 0; i < total; i++){
            this._pool[this._index++] = new this._classType();
        }
        this._count += total;
    }
    /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */ get(data) {
        let item;
        if (this._index > 0) {
            item = this._pool[--this._index];
        } else {
            item = new this._classType();
        }
        item.init?.(data);
        return item;
    }
    /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */ return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
    }
    /**
   * Gets the number of items in the pool.
   * @readonly
   * @member {number}
   */ get totalSize() {
        return this._count;
    }
    /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   * @member {number}
   */ get totalFree() {
        return this._index;
    }
    /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   * @member {number}
   */ get totalUsed() {
        return this._count - this._index;
    }
    /** clears the pool - mainly used for debugging! */ clear() {
        this._pool.length = 0;
        this._index = 0;
    }
}
;
 //# sourceMappingURL=Pool.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "BigPool": (()=>BigPool),
    "PoolGroupClass": (()=>PoolGroupClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$Pool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/pool/Pool.mjs [app-ssr] (ecmascript)");
;
"use strict";
class PoolGroupClass {
    constructor(){
        /**
     * A map to store the pools by their class type.
     * @private
     */ this._poolsByClass = /* @__PURE__ */ new Map();
    }
    /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */ prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
    }
    /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */ get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
    }
    /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */ return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
    }
    /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */ getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$Pool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Pool"](ClassType));
        }
        return this._poolsByClass.get(ClassType);
    }
    /** gets the usage stats of each pool in the system */ stats() {
        const stats = {};
        this._poolsByClass.forEach((pool)=>{
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
                free: pool.totalFree,
                used: pool.totalUsed,
                size: pool.totalSize
            };
        });
        return stats;
    }
}
const BigPool = new PoolGroupClass();
;
 //# sourceMappingURL=PoolGroup.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/misc/NOOP.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "NOOP": (()=>NOOP)
});
"use strict";
const NOOP = ()=>{};
;
 //# sourceMappingURL=NOOP.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "warn": (()=>warn)
});
"use strict";
let warnCount = 0;
const maxWarnings = 500;
function warn(...args) {
    if (warnCount === maxWarnings) return;
    warnCount++;
    if (warnCount === maxWarnings) {
        console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
        console.warn("PixiJS Warning: ", ...args);
    }
}
;
 //# sourceMappingURL=warn.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/path.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "path": (()=>path)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
;
"use strict";
function assertPath(path2) {
    if (typeof path2 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
}
function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
}
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for(let i = 0; i <= path2.length; ++i){
        if (i < path2.length) {
            code = path2.charCodeAt(i);
        } else if (code === 47) {
            break;
        } else {
            code = 47;
        }
        if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) {
                        res += "/..";
                    } else {
                        res = "..";
                    }
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) {
                    res += `/${path2.slice(lastSlash + 1, i)}`;
                } else {
                    res = path2.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
const path = {
    /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */ toPosix (path2) {
        return replaceAll(path2, "\\", "/");
    },
    /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */ isUrl (path2) {
        return /^https?:/.test(this.toPosix(path2));
    },
    /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */ isDataUrl (path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */ isBlobUrl (path2) {
        return path2.startsWith("blob:");
    },
    /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */ hasProtocol (path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
    },
    /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */ getProtocol (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
            return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
            return matchProtocol[0];
        }
        return "";
    },
    /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */ toAbsolute (url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
    },
    /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */ normalize (path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return `/${path2}`;
        return protocol + path2;
    },
    /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */ isAbsolute (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2)) return true;
        return path2.startsWith("/");
    },
    /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */ join (...segments) {
        if (segments.length === 0) {
            return ".";
        }
        let joined;
        for(let i = 0; i < segments.length; ++i){
            const arg = segments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === void 0) joined = arg;
                else {
                    const prevArg = segments[i - 1] ?? "";
                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                        joined += `/../${arg}`;
                    } else {
                        joined += `/${arg}`;
                    }
                }
            }
        }
        if (joined === void 0) {
            return ".";
        }
        return this.normalize(joined);
    },
    /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */ dirname (path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for(let i = path2.length - 1; i >= 1; --i){
            code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else {
                matchedSlash = false;
            }
        }
        if (end === -1) return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1) return "//";
        return proto + path2.slice(0, end);
    },
    /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */ rootname (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/")) root = "/";
        else {
            root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
                root = path2.slice(0, index);
            } else root = path2;
            if (!root.endsWith("/")) root += "/";
        }
        return root;
    },
    /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */ basename (path2, ext) {
        assertPath(path2);
        if (ext) assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2) return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for(i = path2.length - 1; i >= 0; --i){
                const code = path2.charCodeAt(i);
                if (code === 47) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        } else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path2.length;
            return path2.slice(start, end);
        }
        for(i = path2.length - 1; i >= 0; --i){
            if (path2.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    },
    /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */ extname (path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for(let i = path2.length - 1; i >= 0; --i){
            const code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
        }
        return path2.slice(startDot, end);
    },
    /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */ parse (path2) {
        assertPath(path2);
        const ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path2.length === 0) return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
        } else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path2.length - 1;
        let preDotState = 0;
        for(; i >= start; --i){
            code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
                else ret.base = ret.name = path2.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path2.slice(1, startDot);
                ret.base = path2.slice(1, end);
            } else {
                ret.name = path2.slice(startPart, startDot);
                ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return ret;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
        ".html"
    ]
};
;
 //# sourceMappingURL=path.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "updateQuadBounds": (()=>updateQuadBounds)
});
"use strict";
function updateQuadBounds(bounds, anchor, texture, padding) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
        const sourceWidth = trim.width;
        const sourceHeight = trim.height;
        bounds.minX = trim.x - anchor._x * width - padding;
        bounds.maxX = bounds.minX + sourceWidth;
        bounds.minY = trim.y - anchor._y * height - padding;
        bounds.maxY = bounds.minY + sourceHeight;
    } else {
        bounds.minX = -anchor._x * width - padding;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height - padding;
        bounds.maxY = bounds.minY + height;
    }
    return;
}
;
 //# sourceMappingURL=updateQuadBounds.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "detectVideoAlphaMode": (()=>detectVideoAlphaMode)
});
"use strict";
let promise;
async function detectVideoAlphaMode() {
    promise ?? (promise = (async ()=>{
        const canvas = document.createElement("canvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
            return "premultiply-alpha-on-upload";
        }
        const video = await new Promise((resolve)=>{
            const video2 = document.createElement("video");
            video2.onloadeddata = ()=>resolve(video2);
            video2.onerror = ()=>resolve(null);
            video2.autoplay = false;
            video2.crossOrigin = "anonymous";
            video2.preload = "auto";
            video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
            video2.load();
        });
        if (!video) {
            return "premultiply-alpha-on-upload";
        }
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        const pixel = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
        gl.getExtension("WEBGL_lose_context")?.loseContext();
        return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
}
;
 //# sourceMappingURL=detectVideoAlphaMode.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "ViewableBuffer": (()=>ViewableBuffer)
});
"use strict";
class ViewableBuffer {
    constructor(sizeOrBuffer){
        if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
            this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
    }
    /** View on the raw binary data as a `Int8Array`. */ get int8View() {
        if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
    }
    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {
        if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
    }
    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {
        if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
    }
    /** View on the raw binary data as a `Int32Array`. */ get int32View() {
        if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
    }
    /** View on the raw binary data as a `Float64Array`. */ get float64View() {
        if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
    }
    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {
        if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
    }
    /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */ view(type) {
        return this[`${type}View`];
    }
    /** Destroys all buffer references. Do not use after calling this. */ destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
    }
    /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */ static sizeOf(type) {
        switch(type){
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${type} isn't a valid view type`);
        }
    }
}
;
 //# sourceMappingURL=ViewableBuffer.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "getCanvasBoundingBox": (()=>getCanvasBoundingBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
"use strict";
function checkRow(data, width, y) {
    for(let x = 0, index = 4 * y * width; x < width; ++x, index += 4){
        if (data[index + 3] !== 0) return false;
    }
    return true;
}
function checkColumn(data, width, x, top, bottom) {
    const stride = 4 * width;
    for(let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride){
        if (data[index + 3] !== 0) return false;
    }
    return true;
}
function getCanvasBoundingBox(canvas, resolution = 1) {
    const { width, height } = canvas;
    const context = canvas.getContext("2d", {
        willReadFrequently: true
    });
    if (context === null) {
        throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while(top < height && checkRow(data, width, top))++top;
    if (top === height) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"].EMPTY;
    while(checkRow(data, width, bottom))--bottom;
    while(checkColumn(data, width, left, top, bottom))++left;
    while(checkColumn(data, width, right, top, bottom))--right;
    ++right;
    ++bottom;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
}
;
 //# sourceMappingURL=getCanvasBoundingBox.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/utils/browser/isSafari.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "isSafari": (()=>isSafari)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
;
"use strict";
function isSafari() {
    const { userAgent } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
}
;
 //# sourceMappingURL=isSafari.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Point": (()=>Point)
});
"use strict";
class Point {
    /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */ constructor(x = 0, y = 0){
        /** Position of the point on the x axis */ this.x = 0;
        /** Position of the point on the y axis */ this.y = 0;
        this.x = x;
        this.y = y;
    }
    /**
   * Creates a clone of this point
   * @returns A clone of this point
   */ clone() {
        return new Point(this.x, this.y);
    }
    /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */ copyFrom(p) {
        this.set(p.x, p.y);
        return this;
    }
    /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */ copyTo(p) {
        p.set(this.x, this.y);
        return p;
    }
    /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */ equals(p) {
        return p.x === this.x && p.y === this.y;
    }
    /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */ set(x = 0, y = x) {
        this.x = x;
        this.y = y;
        return this;
    }
    toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    /**
   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
   * @readonly
   */ static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
    }
}
const tempPoint = new Point();
;
 //# sourceMappingURL=Point.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "ObservablePoint": (()=>ObservablePoint)
});
"use strict";
class ObservablePoint {
    /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */ constructor(observer, x, y){
        this._x = x || 0;
        this._y = y || 0;
        this._observer = observer;
    }
    /**
   * Creates a clone of this point.
   * @param observer - Optional observer to pass to the new observable point.
   * @returns a copy of this observable point
   */ clone(observer) {
        return new ObservablePoint(observer ?? this._observer, this._x, this._y);
    }
    /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */ set(x = 0, y = x) {
        if (this._x !== x || this._y !== y) {
            this._x = x;
            this._y = y;
            this._observer._onUpdate(this);
        }
        return this;
    }
    /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `PointData`
   * @returns The observable point instance itself
   */ copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
            this._x = p.x;
            this._y = p.y;
            this._observer._onUpdate(this);
        }
        return this;
    }
    /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */ copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */ equals(p) {
        return p.x === this._x && p.y === this._y;
    }
    toString() {
        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
    }
    /** Position of the observable point on the x axis. */ get x() {
        return this._x;
    }
    set x(value) {
        if (this._x !== value) {
            this._x = value;
            this._observer._onUpdate(this);
        }
    }
    /** Position of the observable point on the y axis. */ get y() {
        return this._y;
    }
    set y(value) {
        if (this._y !== value) {
            this._y = value;
            this._observer._onUpdate(this);
        }
    }
}
;
 //# sourceMappingURL=ObservablePoint.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/misc/const.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "DEG_TO_RAD": (()=>DEG_TO_RAD),
    "PI_2": (()=>PI_2),
    "RAD_TO_DEG": (()=>RAD_TO_DEG)
});
"use strict";
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
;
 //# sourceMappingURL=const.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Matrix": (()=>Matrix)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/misc/const.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class Matrix {
    /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){
        /** An array of the current matrix. Only populated when `toArray` is called */ this.array = null;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */ fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    }
    /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */ set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    }
    /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */ toArray(transpose, out) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        const array = out || this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    }
    /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, transformed through this matrix
   */ apply(pos, newPos) {
        newPos = newPos || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        const x = pos.x;
        const y = pos.y;
        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;
        return newPos;
    }
    /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, inverse-transformed through this matrix
   */ applyInverse(pos, newPos) {
        newPos = newPos || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a * d + c * -b);
        const x = pos.x;
        const y = pos.y;
        newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
        newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
        return newPos;
    }
    /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */ translate(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    }
    /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */ scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    }
    /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */ rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
    }
    /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */ append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
    }
    /**
   * Appends two matrix's and sets the result to this matrix. AB = A * B
   * @param a - The matrix to append.
   * @param b - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */ appendFrom(a, b) {
        const a1 = a.a;
        const b1 = a.b;
        const c1 = a.c;
        const d1 = a.d;
        const tx = a.tx;
        const ty = a.ty;
        const a2 = b.a;
        const b2 = b.b;
        const c2 = b.c;
        const d2 = b.d;
        this.a = a1 * a2 + b1 * c2;
        this.b = a1 * b2 + b1 * d2;
        this.c = c1 * a2 + d1 * c2;
        this.d = c1 * b2 + d1 * d2;
        this.tx = tx * a2 + ty * c2 + b.tx;
        this.ty = tx * b2 + ty * d2 + b.ty;
        return this;
    }
    /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */ setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - (pivotX * this.a + pivotY * this.c);
        this.ty = y - (pivotX * this.b + pivotY * this.d);
        return this;
    }
    /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */ prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
    }
    /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */ decompose(transform) {
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d = this.d;
        const pivot = transform.pivot;
        const skewX = -Math.atan2(-c, d);
        const skewY = Math.atan2(b, a);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PI_2"] - delta) < 1e-5) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        } else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);
        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
        return transform;
    }
    /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */ invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
    }
    /** Checks if this matrix is an identity matrix */ isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */ identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
    }
    /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */ clone() {
        const matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */ copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param matrix - The matrix to copy from.
   * @returns this
   */ copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    }
    /**
   * check to see if two matrices are the same
   * @param matrix - The matrix to compare to.
   */ equals(matrix) {
        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
    }
    toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    /**
   * A default (identity) matrix.
   *
   * This is a shared object, if you want to modify it consider creating a new `Matrix`
   * @readonly
   */ static get IDENTITY() {
        return identityMatrix.identity();
    }
    /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   * Use this object for fast but temporary calculations, as it may be mutated later on.
   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
   * @readonly
   */ static get shared() {
        return tempMatrix.identity();
    }
}
const tempMatrix = new Matrix();
const identityMatrix = new Matrix();
;
 //# sourceMappingURL=Matrix.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/misc/pow2.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "isPow2": (()=>isPow2),
    "log2": (()=>log2),
    "nextPow2": (()=>nextPow2)
});
"use strict";
function nextPow2(v) {
    v += v === 0 ? 1 : 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
}
function isPow2(v) {
    return !(v & v - 1) && !!v;
}
function log2(v) {
    let r = (v > 65535 ? 1 : 0) << 4;
    v >>>= r;
    let shift = (v > 255 ? 1 : 0) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15 ? 1 : 0) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3 ? 1 : 0) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
}
;
 //# sourceMappingURL=pow2.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Rectangle": (()=>Rectangle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
;
"use strict";
const tempPoints = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]()
];
class Rectangle {
    /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */ constructor(x = 0, y = 0, width = 0, height = 0){
        /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'rectangle'
     */ this.type = "rectangle";
        this.x = Number(x);
        this.y = Number(y);
        this.width = Number(width);
        this.height = Number(height);
    }
    /** Returns the left edge of the rectangle. */ get left() {
        return this.x;
    }
    /** Returns the right edge of the rectangle. */ get right() {
        return this.x + this.width;
    }
    /** Returns the top edge of the rectangle. */ get top() {
        return this.y;
    }
    /** Returns the bottom edge of the rectangle. */ get bottom() {
        return this.y + this.height;
    }
    /** Determines whether the Rectangle is empty. */ isEmpty() {
        return this.left === this.right || this.top === this.bottom;
    }
    /** A constant empty rectangle. This is a new object every time the property is accessed */ static get EMPTY() {
        return new Rectangle(0, 0, 0, 0);
    }
    /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */ clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    /**
   * Converts a Bounds object to a Rectangle object.
   * @param bounds - The bounds to copy and convert to a rectangle.
   * @returns Returns itself.
   */ copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
    }
    /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */ copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
    }
    /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */ copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */ contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
                return true;
            }
        }
        return false;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */ strokeContains(x, y, strokeWidth) {
        const { width, height } = this;
        if (width <= 0 || height <= 0) return false;
        const _x = this.x;
        const _y = this.y;
        const outerLeft = _x - strokeWidth / 2;
        const outerRight = _x + width + strokeWidth / 2;
        const outerTop = _y - strokeWidth / 2;
        const outerBottom = _y + height + strokeWidth / 2;
        const innerLeft = _x + strokeWidth / 2;
        const innerRight = _x + width - strokeWidth / 2;
        const innerTop = _y + strokeWidth / 2;
        const innerBottom = _y + height - strokeWidth / 2;
        return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);
    }
    /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */ intersects(other, transform) {
        if (!transform) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
                return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
            return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
        }
        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s === 0) {
            return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
        }
        const nx = s * (lb.y - lt.y);
        const ny = s * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
        }
        const mx = s * (lt.y - rt.y);
        const my = s * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
        }
        return true;
    }
    /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */ pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
    }
    /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */ fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
    }
    /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */ ceil(resolution = 1, eps = 1e-3) {
        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
    }
    /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */ enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
    }
    /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */ getBounds(out) {
        out || (out = new Rectangle());
        out.copyFrom(this);
        return out;
    }
    toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
}
;
 //# sourceMappingURL=Rectangle.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "groupD8": (()=>groupD8)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
;
"use strict";
const ux = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
];
const uy = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
];
const vx = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
];
const vy = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
    for(let i = 0; i < 16; i++){
        const row = [];
        rotationCayley.push(row);
        for(let j = 0; j < 16; j++){
            const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
            const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
            const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
            const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
            for(let k = 0; k < 16; k++){
                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                    row.push(k);
                    break;
                }
            }
        }
    }
    for(let i = 0; i < 16; i++){
        const mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
        rotationMatrices.push(mat);
    }
}
init();
const groupD8 = {
    /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ E: 0,
    /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ SE: 1,
    /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ S: 2,
    /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ SW: 3,
    /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ W: 4,
    /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ NW: 5,
    /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ N: 6,
    /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ NE: 7,
    /**
   * Reflection about Y-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ MIRROR_VERTICAL: 8,
    /**
   * Reflection about the main diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ MAIN_DIAGONAL: 10,
    /**
   * Reflection about X-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ MIRROR_HORIZONTAL: 12,
    /**
   * Reflection about reverse diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */ REVERSE_DIAGONAL: 14,
    /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */ uX: (ind)=>ux[ind],
    /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */ uY: (ind)=>uy[ind],
    /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */ vX: (ind)=>vx[ind],
    /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */ vY: (ind)=>vy[ind],
    /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */ inv: (rotation)=>{
        if (rotation & 8) {
            return rotation & 15;
        }
        return -rotation & 7;
    },
    /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */ add: (rotationSecond, rotationFirst)=>rotationCayley[rotationSecond][rotationFirst],
    /**
   * Reverse of `add`.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */ sub: (rotationSecond, rotationFirst)=>rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof maths.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */ rotate180: (rotation)=>rotation ^ 4,
    /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */ isVertical: (rotation)=>(rotation & 3) === 2,
    // rotation % 4 === 2
    /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof maths.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */ byDirection: (dx, dy)=>{
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return groupD8.S;
            }
            return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return groupD8.E;
            }
            return groupD8.W;
        } else if (dy > 0) {
            if (dx > 0) {
                return groupD8.SE;
            }
            return groupD8.SW;
        } else if (dx > 0) {
            return groupD8.NE;
        }
        return groupD8.NW;
    },
    /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof maths.groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */ matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0)=>{
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
};
;
 //# sourceMappingURL=groupD8.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/shapes/Circle.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Circle": (()=>Circle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
"use strict";
class Circle {
    /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */ constructor(x = 0, y = 0, radius = 0){
        /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'circle'
     */ this.type = "circle";
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */ clone() {
        return new Circle(this.x, this.y, this.radius);
    }
    /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */ contains(x, y) {
        if (this.radius <= 0) return false;
        const r2 = this.radius * this.radius;
        let dx = this.x - x;
        let dy = this.y - y;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @returns Whether the x/y coordinates are within this Circle
   */ strokeContains(x, y, width) {
        if (this.radius === 0) return false;
        const dx = this.x - x;
        const dy = this.y - y;
        const r = this.radius;
        const w2 = width / 2;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < r + w2 && distance > r - w2;
    }
    /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */ getBounds(out) {
        out || (out = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]());
        out.x = this.x - this.radius;
        out.y = this.y - this.radius;
        out.width = this.radius * 2;
        out.height = this.radius * 2;
        return out;
    }
    /**
   * Copies another circle to this one.
   * @param circle - The circle to copy from.
   * @returns Returns itself.
   */ copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
    }
    /**
   * Copies this circle to another one.
   * @param circle - The circle to copy to.
   * @returns Returns given parameter.
   */ copyTo(circle) {
        circle.copyFrom(this);
        return circle;
    }
    toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
}
;
 //# sourceMappingURL=Circle.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "squaredDistanceToLineSegment": (()=>squaredDistanceToLineSegment)
});
"use strict";
function squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {
    const a = x - x1;
    const b = y - y1;
    const c = x2 - x1;
    const d = y2 - y1;
    const dot = a * c + b * d;
    const lenSq = c * c + d * d;
    let param = -1;
    if (lenSq !== 0) {
        param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * c;
        yy = y1 + param * d;
    }
    const dx = x - xx;
    const dy = y - yy;
    return dx * dx + dy * dy;
}
;
 //# sourceMappingURL=squaredDistanceToLineSegment.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Polygon": (()=>Polygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$squaredDistanceToLineSegment$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class Polygon {
    /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */ constructor(...points){
        /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'polygon'
     */ this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
            const p = [];
            for(let i = 0, il = flat.length; i < il; i++){
                p.push(flat[i].x, flat[i].y);
            }
            flat = p;
        }
        this.points = flat;
        this.closePath = true;
    }
    /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */ clone() {
        const points = this.points.slice();
        const polygon = new Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
    }
    /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */ contains(x, y) {
        let inside = false;
        const length = this.points.length / 2;
        for(let i = 0, j = length - 1; i < length; j = i++){
            const xi = this.points[i * 2];
            const yi = this.points[i * 2 + 1];
            const xj = this.points[j * 2];
            const yj = this.points[j * 2 + 1];
            const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
            if (intersect) {
                inside = !inside;
            }
        }
        return inside;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this polygon
   */ strokeContains(x, y, strokeWidth) {
        const halfStrokeWidth = strokeWidth / 2;
        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
        const { points } = this;
        const iterationLength = points.length - (this.closePath ? 0 : 2);
        for(let i = 0; i < iterationLength; i += 2){
            const x1 = points[i];
            const y1 = points[i + 1];
            const x2 = points[(i + 2) % points.length];
            const y2 = points[(i + 3) % points.length];
            const distanceSqrd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$squaredDistanceToLineSegment$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squaredDistanceToLineSegment"])(x, y, x1, y1, x2, y2);
            if (distanceSqrd <= halfStrokeWidthSqrd) {
                return true;
            }
        }
        return false;
    }
    /**
   * Returns the framing rectangle of the polygon as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */ getBounds(out) {
        out || (out = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]());
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for(let i = 0, n = points.length; i < n; i += 2){
            const x = points[i];
            const y = points[i + 1];
            minX = x < minX ? x : minX;
            maxX = x > maxX ? x : maxX;
            minY = y < minY ? y : minY;
            maxY = y > maxY ? y : maxY;
        }
        out.x = minX;
        out.width = maxX - minX;
        out.y = minY;
        out.height = maxY - minY;
        return out;
    }
    /**
   * Copies another polygon to this one.
   * @param polygon - The polygon to copy from.
   * @returns Returns itself.
   */ copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
    }
    /**
   * Copies this polygon to another one.
   * @param polygon - The polygon to copy to.
   * @returns Returns given parameter.
   */ copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
    }
    toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint)=>`${pointsDesc}, ${currentPoint}`, "")}]`;
    }
    /**
   * Get the last X coordinate of the polygon
   * @readonly
   */ get lastX() {
        return this.points[this.points.length - 2];
    }
    /**
   * Get the last Y coordinate of the polygon
   * @readonly
   */ get lastY() {
        return this.points[this.points.length - 1];
    }
    /**
   * Get the first X coordinate of the polygon
   * @readonly
   */ get x() {
        return this.points[this.points.length - 2];
    }
    /**
   * Get the first Y coordinate of the polygon
   * @readonly
   */ get y() {
        return this.points[this.points.length - 1];
    }
}
;
 //# sourceMappingURL=Polygon.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Ellipse": (()=>Ellipse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
"use strict";
class Ellipse {
    /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */ constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0){
        /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'ellipse'
     */ this.type = "ellipse";
        this.x = x;
        this.y = y;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
    }
    /**
   * Creates a clone of this Ellipse instance
   * @returns {Ellipse} A copy of the ellipse
   */ clone() {
        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */ contains(x, y) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
        }
        let normx = (x - this.x) / this.halfWidth;
        let normy = (y - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width
   * @returns Whether the x/y coords are within this ellipse
   */ strokeContains(x, y, width) {
        const { halfWidth, halfHeight } = this;
        if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
        }
        const halfStrokeWidth = width / 2;
        const innerA = halfWidth - halfStrokeWidth;
        const innerB = halfHeight - halfStrokeWidth;
        const outerA = halfWidth + halfStrokeWidth;
        const outerB = halfHeight + halfStrokeWidth;
        const normalizedX = x - this.x;
        const normalizedY = y - this.y;
        const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
        const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
        return innerEllipse > 1 && outerEllipse <= 1;
    }
    /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */ getBounds(out) {
        out || (out = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]());
        out.x = this.x - this.halfWidth;
        out.y = this.y - this.halfHeight;
        out.width = this.halfWidth * 2;
        out.height = this.halfHeight * 2;
        return out;
    }
    /**
   * Copies another ellipse to this one.
   * @param ellipse - The ellipse to copy from.
   * @returns Returns itself.
   */ copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
    }
    /**
   * Copies this ellipse to another one.
   * @param ellipse - The ellipse to copy to.
   * @returns Returns given parameter.
   */ copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
    }
    toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
}
;
 //# sourceMappingURL=Ellipse.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "RoundedRectangle": (()=>RoundedRectangle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
"use strict";
const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth)=>{
    const dx = pX - cornerX;
    const dy = pY - cornerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
};
class RoundedRectangle {
    /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */ constructor(x = 0, y = 0, width = 0, height = 0, radius = 20){
        /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'roundedRectangle'
     */ this.type = "roundedRectangle";
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.radius = radius;
    }
    /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */ getBounds(out) {
        out || (out = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]());
        out.x = this.x;
        out.y = this.y;
        out.width = this.width;
        out.height = this.height;
        return out;
    }
    /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */ clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */ copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
    }
    /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */ copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */ contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
                    return true;
                }
                let dx = x - (this.x + radius);
                let dy = y - (this.y + radius);
                const radius2 = radius * radius;
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
                dx = x - (this.x + radius);
                if (dx * dx + dy * dy <= radius2) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */ strokeContains(pX, pY, strokeWidth) {
        const { x, y, width, height, radius } = this;
        const halfStrokeWidth = strokeWidth / 2;
        const innerX = x + radius;
        const innerY = y + radius;
        const innerWidth = width - radius * 2;
        const innerHeight = height - radius * 2;
        const rightBound = x + width;
        const bottomBound = y + height;
        if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
            return true;
        }
        if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
            return true;
        }
        return(// Top-left
        pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth));
    }
    toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
}
;
 //# sourceMappingURL=RoundedRectangle.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FederatedEvent": (()=>FederatedEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
;
"use strict";
class FederatedEvent {
    /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */ constructor(manager){
        /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */ this.bubbles = true;
        /** @deprecated since 7.0.0 */ this.cancelBubble = true;
        /**
     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always
     * false (for now).
     */ this.cancelable = false;
        /**
     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events
     * API.
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     */ this.composed = false;
        /** Flags whether the default response of the user agent was prevent through this event. */ this.defaultPrevented = false;
        /**
     * The propagation phase.
     * @default {@link FederatedEvent.NONE}
     */ this.eventPhase = FederatedEvent.prototype.NONE;
        /** Flags whether propagation was stopped. */ this.propagationStopped = false;
        /** Flags whether propagation was immediately stopped. */ this.propagationImmediatelyStopped = false;
        /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */ this.layer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        /** The coordinates of the event relative to the DOM document. This is a non-standard property. */ this.page = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
    }
    /** @readonly */ get layerX() {
        return this.layer.x;
    }
    /** @readonly */ get layerY() {
        return this.layer.y;
    }
    /** @readonly */ get pageX() {
        return this.page.x;
    }
    /** @readonly */ get pageY() {
        return this.page.y;
    }
    /**
   * Fallback for the deprecated @code{InteractionEvent.data}.
   * @deprecated since 7.0.0
   */ get data() {
        return this;
    }
    /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */ composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
    }
    /**
   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
   * @deprecated
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */ initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    /**
   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */ initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    /** Prevent default behavior of PixiJS and the user agent. */ preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
    }
    /**
   * Stop this event from propagating to any addition listeners, including on the
   * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
   * event targets on the propagation path.
   */ stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
    }
    /**
   * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
   * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
;
 //# sourceMappingURL=FederatedEvent.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "EventsTicker": (()=>EventsTicker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class EventsTickerClass {
    constructor(){
        /** The frequency that fake events will be fired. */ this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
    }
    /**
   * Initializes the event ticker.
   * @param events - The event system.
   */ init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
    }
    /** Whether to pause the update checks or not. */ get pauseUpdate() {
        return this._pauseUpdate;
    }
    set pauseUpdate(paused) {
        this._pauseUpdate = paused;
    }
    /** Adds the ticker listener. */ addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].system.add(this._tickerUpdate, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].INTERACTION);
        this._tickerAdded = true;
    }
    /** Removes the ticker listener. */ removeTickerListener() {
        if (!this._tickerAdded) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
    }
    /** Sets flag to not fire extra events when the user has already moved there mouse */ pointerMoved() {
        this._didMove = true;
    }
    /** Updates the state of interactive objects. */ _update() {
        if (!this.domElement || this._pauseUpdate) {
            return;
        }
        if (this._didMove) {
            this._didMove = false;
            return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
        }));
    }
    /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link Ticker.system}.
   * @param ticker - The throttled ticker.
   */ _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
            return;
        }
        this._deltaTime = 0;
        this._update();
    }
}
const EventsTicker = new EventsTickerClass();
;
 //# sourceMappingURL=EventTicker.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FederatedMouseEvent": (()=>FederatedMouseEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class FederatedMouseEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedEvent"] {
    constructor(){
        super(...arguments);
        /** The coordinates of the mouse event relative to the canvas. */ this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        /** The movement in this pointer relative to the last `mousemove` event. */ this.movement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */ this.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        /** The pointer coordinates in world space. */ this.global = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
        /**
     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly
     * different semantics than native PointerEvent screenX/screenY.
     */ this.screen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
    }
    /** @readonly */ get clientX() {
        return this.client.x;
    }
    /** @readonly */ get clientY() {
        return this.client.y;
    }
    /**
   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */ get x() {
        return this.clientX;
    }
    /**
   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */ get y() {
        return this.clientY;
    }
    /** @readonly */ get movementX() {
        return this.movement.x;
    }
    /** @readonly */ get movementY() {
        return this.movement.y;
    }
    /** @readonly */ get offsetX() {
        return this.offset.x;
    }
    /** @readonly */ get offsetY() {
        return this.offset.y;
    }
    /** @readonly */ get globalX() {
        return this.global.x;
    }
    /** @readonly */ get globalY() {
        return this.global.y;
    }
    /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
   * @readonly
   */ get screenX() {
        return this.screen.x;
    }
    /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
   * @readonly
   */ get screenY() {
        return this.screen.y;
    }
    /**
   * This will return the local coordinates of the specified container for this InteractionData
   * @param {Container} container - The Container that you would like the local
   *  coords off
   * @param {PointData} point - A Point object in which to store the value, optional (otherwise
   *  will create a new point)
   * @param {PointData} globalPos - A Point object containing your custom global coords, optional
   *  (otherwise will use the current global coords)
   * @returns - A point containing the coordinates of the InteractionData position relative
   *  to the Container
   */ getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
    }
    /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */ getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   */ // eslint-disable-next-line max-params
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
    }
}
;
 //# sourceMappingURL=FederatedMouseEvent.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FederatedPointerEvent": (()=>FederatedPointerEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-ssr] (ecmascript)");
;
"use strict";
class FederatedPointerEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] {
    constructor(){
        super(...arguments);
        /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     */ this.width = 0;
        /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     */ this.height = 0;
        /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     */ this.isPrimary = false;
    }
    // Only included for completeness for now
    getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [
                this
            ];
        }
        return [];
    }
    // Only included for completeness for now
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
    }
}
;
 //# sourceMappingURL=FederatedPointerEvent.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FederatedWheelEvent": (()=>FederatedWheelEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-ssr] (ecmascript)");
;
"use strict";
class FederatedWheelEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] {
    constructor(){
        super(...arguments);
        /** Units specified in pixels. */ this.DOM_DELTA_PIXEL = 0;
        /** Units specified in lines. */ this.DOM_DELTA_LINE = 1;
        /** Units specified in pages. */ this.DOM_DELTA_PAGE = 2;
    }
}
/** Units specified in pixels. */ FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
/** Units specified in lines. */ FederatedWheelEvent.DOM_DELTA_LINE = 1;
/** Units specified in pages. */ FederatedWheelEvent.DOM_DELTA_PAGE = 2;
;
 //# sourceMappingURL=FederatedWheelEvent.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/EventBoundary.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "EventBoundary": (()=>EventBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/pixi.js/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/pixi.js/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
const tempLocalMapping = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
class EventBoundary {
    /**
   * @param rootTarget - The holder of the event boundary.
   */ constructor(rootTarget){
        /**
     * Emits events after they were dispatched into the scene graph.
     *
     * This can be used for global events listening, regardless of the scene graph being used. It should
     * not be used by interactive libraries for normal use.
     *
     * Special events that do not bubble all the way to the root target are not emitted from here,
     * e.g. pointerenter, pointerleave, click.
     */ this.dispatch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]();
        /**
     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.
     *
     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of
     * the Pointer Event API's approach.
     */ this.moveOnAll = false;
        /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */ this.enableGlobalMoveEvents = true;
        /**
     * State object for mapping methods.
     * @see EventBoundary#trackingData
     */ this.mappingState = {
            trackingData: {}
        };
        /**
     * The event pool maps event constructors to an free pool of instances of those specific events.
     * @see EventBoundary#allocateEvent
     * @see EventBoundary#freeEvent
     */ this.eventPool = /* @__PURE__ */ new Map();
        /** Every interactive element gathered from the scene. Only used in `pointermove` */ this._allInteractiveElements = [];
        /** Every element that passed the hit test. Only used in `pointermove` */ this._hitElements = [];
        /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */ this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
    }
    /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */ addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
            fn,
            priority: 0
        });
        this.mappingTable[type].sort((a, b)=>a.priority - b.priority);
    }
    /**
   * Dispatches the given event
   * @param e - The event to dispatch.
   * @param type - The type of event to dispatch. Defaults to `e.type`.
   */ dispatchEvent(e, type) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
        this.dispatch.emit(type || e.type, e);
    }
    /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e - The event to map.
   */ mapEvent(e) {
        if (!this.rootTarget) {
            return;
        }
        const mappers = this.mappingTable[e.type];
        if (mappers) {
            for(let i = 0, j = mappers.length; i < j; i++){
                mappers[i].fn(e);
            }
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`[EventBoundary]: Event mapping not defined for ${e.type}`);
        }
    }
    /**
   * Finds the Container that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x - The x coordinate of the event.
   * @param y - The y coordinate of the event.
   */ hitTest(x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
        return invertedPath && invertedPath[0];
    }
    /**
   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
   * target {@code e.target}.
   * @param e - The event to propagate.
   * @param type - The type of event to propagate. Defaults to `e.type`.
   */ propagate(e, type) {
        if (!e.target) {
            return;
        }
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for(let i = 0, j = composedPath.length - 1; i < j; i++){
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
        e.eventPhase = e.AT_TARGET;
        e.currentTarget = e.target;
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        e.eventPhase = e.BUBBLING_PHASE;
        for(let i = composedPath.length - 2; i >= 0; i--){
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
    }
    /**
   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */ all(e, type, targets = this._allInteractiveElements) {
        if (targets.length === 0) return;
        e.eventPhase = e.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [
            type
        ];
        for(let i = targets.length - 1; i >= 0; i--){
            events.forEach((event)=>{
                e.currentTarget = targets[i];
                this.notifyTarget(e, event);
            });
        }
    }
    /**
   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
   * {@code target}. The last element in the path is {@code target}.
   * @param target - The target to find the propagation path to.
   */ propagationPath(target) {
        const propagationPath = [
            target
        ];
        for(let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++){
            if (!target.parent) {
                throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
    }
    hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget)) return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
                if (nestedHit) {
                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                        continue;
                    }
                    const isInteractive = currentTarget.isInteractive();
                    if (nestedHit.length > 0 || isInteractive) {
                        if (isInteractive) this._allInteractiveElements.push(currentTarget);
                        nestedHit.push(currentTarget);
                    }
                    if (this._hitElements.length === 0) this._hitElements = nestedHit;
                    shouldReturn = true;
                }
            }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0) return null;
        if (shouldReturn) return this._hitElements;
        if (isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [
                currentTarget
            ] : [];
        }
        return null;
    }
    /**
   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
   * @param currentTarget - The Container that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the container.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */ hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);
                if (nestedHit) {
                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                        continue;
                    }
                    const isInteractive = currentTarget.isInteractive();
                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);
                    return nestedHit;
                }
            }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [
                currentTarget
            ] : [];
        }
        return null;
    }
    _isInteractive(int) {
        return int === "static" || int === "dynamic";
    }
    _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable || !container.measurable) {
            return true;
        }
        if (container.eventMode === "none") {
            return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
        }
        return false;
    }
    /**
   * Checks whether the container or any of its children cannot pass the hit test at all.
   *
   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
   * and {@link Container._maskEffect} for pruning.
   * @param container - The container to prune.
   * @param location - The location to test for overlap.
   */ hitPruneFn(container, location) {
        if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
                return true;
            }
        }
        if (container.effects && container.effects.length) {
            for(let i = 0; i < container.effects.length; i++){
                const effect = container.effects[i];
                if (effect.containsPoint) {
                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                    if (!effectContainsPoint) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
   * Checks whether the container passes hit testing for the given location.
   * @param container - The container to test.
   * @param location - The location to test for overlap.
   * @returns - Whether `container` passes hit testing for `location`.
   */ hitTestFn(container, location) {
        if (container.hitArea) {
            return true;
        }
        if (container?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
        }
        return false;
    }
    /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type - The type of event to notify. Defaults to `e.type`.
   */ notifyTarget(e, type) {
        if (!e.currentTarget.isInteractive()) {
            return;
        }
        type ?? (type = e.type);
        const handlerKey = `on${type}`;
        e.currentTarget[handlerKey]?.(e);
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this._notifyListeners(e, key);
        if (e.eventPhase === e.AT_TARGET) {
            this._notifyListeners(e, type);
        }
    }
    /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from - The upstream `pointerdown` event.
   */ mapPointerDown(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerdown");
        if (e.pointerType === "touch") {
            this.dispatchEvent(e, "touchstart");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const isRightButton = e.button === 2;
            this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */ mapPointerMove(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse) this.dispatchEvent(outEvent, "mouseout");
            if (!e.composedPath().includes(outTarget)) {
                const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while(leaveEvent.target && !e.composedPath().includes(leaveEvent.target)){
                    leaveEvent.currentTarget = leaveEvent.target;
                    this.notifyTarget(leaveEvent);
                    if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
                    leaveEvent.target = leaveEvent.target.parent;
                }
                this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse) this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while(overTargetAncestor && overTargetAncestor !== this.rootTarget.parent){
                if (overTargetAncestor === e.target) break;
                overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
                const enterEvent = this.clonePointerEvent(e, "pointerenter");
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while(enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent){
                    enterEvent.currentTarget = enterEvent.target;
                    this.notifyTarget(enterEvent);
                    if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
                    enterEvent.target = enterEvent.target.parent;
                }
                this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e.target?.cursor;
        }
        if (allMethods.length > 0) {
            this.all(e, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */ mapPointerOver(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e = this.createPointerEvent(from);
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        this.dispatchEvent(e, "pointerover");
        if (isMouse) this.dispatchEvent(e, "mouseover");
        if (e.pointerType === "mouse") this.cursor = e.target?.cursor;
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while(enterEvent.target && enterEvent.target !== this.rootTarget.parent){
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
        this.freeEvent(enterEvent);
    }
    /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */ mapPointerOut(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse) this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while(leaveEvent.target && leaveEvent.target !== this.rootTarget.parent){
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
        }
        this.cursor = null;
    }
    /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */ mapPointerUp(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const now = performance.now();
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerup");
        if (e.pointerType === "touch") {
            this.dispatchEvent(e, "touchend");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const isRightButton = e.button === 2;
            this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while(currentTarget && !e.composedPath().includes(currentTarget)){
                e.currentTarget = currentTarget;
                this.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") {
                    this.notifyTarget(e, "touchendoutside");
                } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                    const isRightButton = e.button === 2;
                    this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
                }
                currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
        }
        if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
                trackingData.clicksByButton[from.button] = {
                    clickCount: 0,
                    target: clickEvent.target,
                    timeStamp: now
                };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                ++clickHistory.clickCount;
            } else {
                clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
                const isRightButton = clickEvent.button === 2;
                this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
                this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
        }
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */ mapPointerUpOutside(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e = this.createPointerEvent(from);
        if (pressTarget) {
            let currentTarget = pressTarget;
            while(currentTarget){
                e.currentTarget = currentTarget;
                this.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") {
                    this.notifyTarget(e, "touchendoutside");
                } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                    this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
                }
                currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */ mapWheel(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedWheelEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
    }
    /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */ findMountedTarget(propagationPath) {
        if (!propagationPath) {
            return null;
        }
        let currentTarget = propagationPath[0];
        for(let i = 1; i < propagationPath.length; i++){
            if (propagationPath[i].parent === currentTarget) {
                currentTarget = propagationPath[i];
            } else {
                break;
            }
        }
        return currentTarget;
    }
    /**
   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The {@code originalEvent} for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */ createPointerEvent(from, type, target) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"]);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
            event.type = type;
        }
        return event;
    }
    /**
   * Creates a wheel event whose {@code originalEvent} is {@code from}.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */ createWheelEvent(from) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedWheelEvent"]);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
    }
    /**
   * Clones the event {@code from}, with an optional {@code type} override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */ clonePointerEvent(from, type) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"]);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
    }
    /**
   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
    }
    /**
   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyPointerData(from, to) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"] && to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
    }
    /**
   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyMouseData(from, to) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] && to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedMouseEvent"])) return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
    }
    /**
   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
    }
    /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */ trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            };
        }
        return this.mappingState.trackingData[id];
    }
    /**
   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   */ allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.defaultPrevented = false;
        event.path = null;
        event.target = null;
        return event;
    }
    /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */ freeEvent(event) {
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
    }
    /**
   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */ _notifyListeners(e, type) {
        const listeners = e.currentTarget._events[type];
        if (!listeners) return;
        if ("fn" in listeners) {
            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e);
        } else {
            for(let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++){
                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
                listeners[i].fn.call(listeners[i].context, e);
            }
        }
    }
}
;
 //# sourceMappingURL=EventBoundary.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/EventSystem.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "EventSystem": (()=>EventSystem)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventBoundary$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/EventBoundary.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
};
const _EventSystem = class _EventSystem {
    /**
   * @param {Renderer} renderer
   */ constructor(renderer){
        /** Does the device support touch events https://www.w3.org/TR/touch-events/ */ this.supportsTouchEvents = "ontouchstart" in globalThis;
        /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */ this.supportsPointerEvents = !!globalThis.PointerEvent;
        /**
     * The DOM element to which the root event listeners are bound. This is automatically set to
     * the renderer's {@link Renderer#view view}.
     */ this.domElement = null;
        /** The resolution used to convert between the DOM client space into world space. */ this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventBoundary$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventBoundary"](null);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedPointerEvent"](null);
        this._rootWheelEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedWheelEvent"](null);
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        };
        this.features = new Proxy({
            ..._EventSystem.defaultEventFeatures
        }, {
            set: (target, key, value)=>{
                if (key === "globalMove") {
                    this.rootBoundary.enableGlobalMoveEvents = value;
                }
                target[key] = value;
                return true;
            }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
    }
    /**
   * The default interaction mode for all display objects.
   * @see Container.eventMode
   * @type {EventMode}
   * @readonly
   * @since 7.2.0
   */ static get defaultEventMode() {
        return this._defaultEventMode;
    }
    /**
   * Runner init called, view is available at this point.
   * @ignore
   */ init(options) {
        const { canvas, resolution } = this.renderer;
        this.setTargetElement(canvas);
        this.resolution = resolution;
        _EventSystem._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
    }
    /**
   * Handle changing resolution.
   * @ignore
   */ resolutionChange(resolution) {
        this.resolution = resolution;
    }
    /** Destroys all event listeners and detaches the renderer. */ destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
    }
    /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * @param mode - cursor mode, a key from the cursorStyles dictionary
   */ setCursor(mode) {
        mode || (mode = "default");
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
        }
        if (this._currentCursor === mode) {
            return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
            switch(typeof style){
                case "string":
                    if (applyStyles) {
                        this.domElement.style.cursor = style;
                    }
                    break;
                case "function":
                    style(mode);
                    break;
                case "object":
                    if (applyStyles) {
                        Object.assign(this.domElement.style, style);
                    }
                    break;
            }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
        }
    }
    /**
   * The global pointer event.
   * Useful for getting the pointer position without listening to events.
   * @since 7.2.0
   */ get pointer() {
        return this._rootPointerEvent;
    }
    /**
   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerDown(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
                nativeEvent.preventDefault();
            }
        }
        for(let i = 0, j = events.length; i < j; i++){
            const nativeEvent2 = events[i];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */ _onPointerMove(nativeEvent) {
        if (!this.features.move) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerUp(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerOverOut(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */ onWheel(nativeEvent) {
        if (!this.features.wheel) return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
    }
    /**
   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
   *
   * To deregister the current DOM element without setting a new one, pass {@code null}.
   * @param element - The new DOM element.
   */ setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].domElement = element;
        this._addEvents();
    }
    /** Register event listeners on {@link Renderer#domElement this.domElement}. */ _addEvents() {
        if (this._eventsAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].addTickerListener();
        const style = this.domElement.style;
        if (style) {
            if (globalThis.navigator.msPointerEnabled) {
                style.msContentZooming = "none";
                style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
                style.touchAction = "none";
            }
        }
        if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
                this.domElement.addEventListener("touchstart", this._onPointerDown, true);
                this.domElement.addEventListener("touchend", this._onPointerUp, true);
                this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
        });
        this._eventsAdded = true;
    }
    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */ _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventsTicker"].removeTickerListener();
        const style = this.domElement.style;
        if (style) {
            if (globalThis.navigator.msPointerEnabled) {
                style.msContentZooming = "";
                style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
                style.touchAction = "";
            }
        }
        if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
                this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
                this.domElement.removeEventListener("touchend", this._onPointerUp, true);
                this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
    }
    /**
   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
   * resulting value is stored in the point. This takes into account the fact that the DOM
   * element could be scaled and positioned anywhere on the screen.
   * @param  {PointData} point - the point that the result will be stored in
   * @param  {number} x - the x coord of the position to map
   * @param  {number} y - the y coord of the position to map
   */ mapPositionToPoint(point, x, y) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
    }
    /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */ _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for(let i = 0, li = event.changedTouches.length; i < li; i++){
                const touch = event.changedTouches[i];
                if (typeof touch.button === "undefined") touch.button = 0;
                if (typeof touch.buttons === "undefined") touch.buttons = 1;
                if (typeof touch.isPrimary === "undefined") {
                    touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
                }
                if (typeof touch.width === "undefined") touch.width = touch.radiusX || 1;
                if (typeof touch.height === "undefined") touch.height = touch.radiusY || 1;
                if (typeof touch.tiltX === "undefined") touch.tiltX = 0;
                if (typeof touch.tiltY === "undefined") touch.tiltY = 0;
                if (typeof touch.pointerType === "undefined") touch.pointerType = "touch";
                if (typeof touch.pointerId === "undefined") touch.pointerId = touch.identifier || 0;
                if (typeof touch.pressure === "undefined") touch.pressure = touch.force || 0.5;
                if (typeof touch.twist === "undefined") touch.twist = 0;
                if (typeof touch.tangentialPressure === "undefined") touch.tangentialPressure = 0;
                if (typeof touch.layerX === "undefined") touch.layerX = touch.offsetX = touch.clientX;
                if (typeof touch.layerY === "undefined") touch.layerY = touch.offsetY = touch.clientY;
                touch.isNormalized = true;
                touch.type = event.type;
                normalizedEvents.push(touch);
            }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined") tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined") tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined") tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined") tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined") tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined") tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined") tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined") tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined") tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined") tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
        } else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */ normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
    }
    /**
   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */ _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
            event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
    }
    /**
   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
   * @param event
   * @param nativeEvent
   */ _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
    }
};
/** @ignore */ _EventSystem.extension = {
    name: "events",
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    priority: -1
};
/**
 * The event features that are enabled by the EventSystem
 * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.
 * @since 7.2.0
 */ _EventSystem.defaultEventFeatures = {
    /** Enables pointer events associated with pointer movement. */ move: true,
    /** Enables global pointer move events. */ globalMove: true,
    /** Enables pointer events associated with clicking. */ click: true,
    /** Enables wheel events. */ wheel: true
};
let EventSystem = _EventSystem;
;
 //# sourceMappingURL=EventSystem.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FederatedContainer": (()=>FederatedContainer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/EventSystem.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const FederatedContainer = {
    /**
   * Property-based event handler for the `click` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onclick = (event) => {
   *  //some function here that happens on click
   * }
   */ onclick: null,
    /**
   * Property-based event handler for the `mousedown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmousedown = (event) => {
   *  //some function here that happens on mousedown
   * }
   */ onmousedown: null,
    /**
   * Property-based event handler for the `mouseenter` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseenter = (event) => {
   *  //some function here that happens on mouseenter
   * }
   */ onmouseenter: null,
    /**
   * Property-based event handler for the `mouseleave` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseleave = (event) => {
   *  //some function here that happens on mouseleave
   * }
   */ onmouseleave: null,
    /**
   * Property-based event handler for the `mousemove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmousemove = (event) => {
   *  //some function here that happens on mousemove
   * }
   */ onmousemove: null,
    /**
   * Property-based event handler for the `globalmousemove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobalmousemove = (event) => {
   *  //some function here that happens on globalmousemove
   * }
   */ onglobalmousemove: null,
    /**
   * Property-based event handler for the `mouseout` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseout = (event) => {
   *  //some function here that happens on mouseout
   * }
   */ onmouseout: null,
    /**
   * Property-based event handler for the `mouseover` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseover = (event) => {
   *  //some function here that happens on mouseover
   * }
   */ onmouseover: null,
    /**
   * Property-based event handler for the `mouseup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseup = (event) => {
   *  //some function here that happens on mouseup
   * }
   */ onmouseup: null,
    /**
   * Property-based event handler for the `mouseupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseupoutside = (event) => {
   *  //some function here that happens on mouseupoutside
   * }
   */ onmouseupoutside: null,
    /**
   * Property-based event handler for the `pointercancel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointercancel = (event) => {
   *  //some function here that happens on pointercancel
   * }
   */ onpointercancel: null,
    /**
   * Property-based event handler for the `pointerdown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerdown = (event) => {
   *  //some function here that happens on pointerdown
   * }
   */ onpointerdown: null,
    /**
   * Property-based event handler for the `pointerenter` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerenter = (event) => {
   *  //some function here that happens on pointerenter
   * }
   */ onpointerenter: null,
    /**
   * Property-based event handler for the `pointerleave` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerleave = (event) => {
   *  //some function here that happens on pointerleave
   * }
   */ onpointerleave: null,
    /**
   * Property-based event handler for the `pointermove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointermove = (event) => {
   *  //some function here that happens on pointermove
   * }
   */ onpointermove: null,
    /**
   * Property-based event handler for the `globalpointermove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobalpointermove = (event) => {
   *  //some function here that happens on globalpointermove
   * }
   */ onglobalpointermove: null,
    /**
   * Property-based event handler for the `pointerout` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerout = (event) => {
   *  //some function here that happens on pointerout
   * }
   */ onpointerout: null,
    /**
   * Property-based event handler for the `pointerover` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerover = (event) => {
   *  //some function here that happens on pointerover
   * }
   */ onpointerover: null,
    /**
   * Property-based event handler for the `pointertap` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointertap = (event) => {
   *  //some function here that happens on pointertap
   * }
   */ onpointertap: null,
    /**
   * Property-based event handler for the `pointerup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerup = (event) => {
   *  //some function here that happens on pointerup
   * }
   */ onpointerup: null,
    /**
   * Property-based event handler for the `pointerupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerupoutside = (event) => {
   *  //some function here that happens on pointerupoutside
   * }
   */ onpointerupoutside: null,
    /**
   * Property-based event handler for the `rightclick` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightclick = (event) => {
   *  //some function here that happens on rightclick
   * }
   */ onrightclick: null,
    /**
   * Property-based event handler for the `rightdown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightdown = (event) => {
   *  //some function here that happens on rightdown
   * }
   */ onrightdown: null,
    /**
   * Property-based event handler for the `rightup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightup = (event) => {
   *  //some function here that happens on rightup
   * }
   */ onrightup: null,
    /**
   * Property-based event handler for the `rightupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightupoutside = (event) => {
   *  //some function here that happens on rightupoutside
   * }
   */ onrightupoutside: null,
    /**
   * Property-based event handler for the `tap` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontap = (event) => {
   *  //some function here that happens on tap
   * }
   */ ontap: null,
    /**
   * Property-based event handler for the `touchcancel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchcancel = (event) => {
   *  //some function here that happens on touchcancel
   * }
   */ ontouchcancel: null,
    /**
   * Property-based event handler for the `touchend` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchend = (event) => {
   *  //some function here that happens on touchend
   * }
   */ ontouchend: null,
    /**
   * Property-based event handler for the `touchendoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchendoutside = (event) => {
   *  //some function here that happens on touchendoutside
   * }
   */ ontouchendoutside: null,
    /**
   * Property-based event handler for the `touchmove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchmove = (event) => {
   *  //some function here that happens on touchmove
   * }
   */ ontouchmove: null,
    /**
   * Property-based event handler for the `globaltouchmove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobaltouchmove = (event) => {
   *  //some function here that happens on globaltouchmove
   * }
   */ onglobaltouchmove: null,
    /**
   * Property-based event handler for the `touchstart` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchstart = (event) => {
   *  //some function here that happens on touchstart
   * }
   */ ontouchstart: null,
    /**
   * Property-based event handler for the `wheel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onwheel = (event) => {
   *  //some function here that happens on wheel
   * }
   */ onwheel: null,
    /**
   * Enable interaction events for the Container. Touch, pointer and mouse
   * @memberof scene.Container#
   */ get interactive () {
        return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive (value){
        this.eventMode = value ? "static" : "passive";
    },
    /**
   * @ignore
   */ _internalEventMode: void 0,
    /**
   * Enable interaction events for the Container. Touch, pointer and mouse.
   * There are 5 types of interaction settings:
   * - `'none'`: Ignores all interaction events, even on its children.
   * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
   * Interactive children will still emit events.
   * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
   * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
   * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
   * allow for interaction when the mouse isn't moving
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.on('tap', (event) => {
   *     // Handle event
   * });
   * @memberof scene.Container#
   * @since 7.2.0
   */ get eventMode () {
        return this._internalEventMode ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventSystem"].defaultEventMode;
    },
    set eventMode (value){
        this._internalEventMode = value;
    },
    /**
   * Determines if the container is interactive or not
   * @returns {boolean} Whether the container is interactive or not
   * @memberof scene.Container#
   * @since 7.2.0
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'dynamic';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'none';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'passive';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'auto';
   * sprite.isInteractive(); // false
   */ isInteractive () {
        return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    /**
   * Determines if the children to the container can be clicked/touched
   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
   * @memberof scene.Container#
   */ interactiveChildren: true,
    /**
   * Interaction shape. Children will be hit first, then this shape will be checked.
   * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
   * @example
   * import { Rectangle, Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.interactive = true;
   * sprite.hitArea = new Rectangle(0, 0, 100, 100);
   * @member {IHitArea}
   * @memberof scene.Container#
   */ hitArea: null,
    /**
   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
   * seeks to be compatible with the DOM's `addEventListener` with support for options.
   * @memberof scene.Container
   * @param type - The type of event to listen to.
   * @param listener - The listener callback or object.
   * @param options - Listener options, used for capture phase.
   * @example
   * // Tell the user whether they did a single, double, triple, or nth click.
   * button.addEventListener('click', {
   *     handleEvent(e): {
   *         let prefix;
   *
   *         switch (e.detail) {
   *             case 1: prefix = 'single'; break;
   *             case 2: prefix = 'double'; break;
   *             case 3: prefix = 'triple'; break;
   *             default: prefix = e.detail + 'th'; break;
   *         }
   *
   *         console.log('That was a ' + prefix + 'click');
   *     }
   * });
   *
   * // But skip the first click!
   * button.parent.addEventListener('click', function blockClickOnce(e) {
   *     e.stopImmediatePropagation();
   *     button.parent.removeEventListener('click', blockClickOnce, true);
   * }, {
   *     capture: true,
   * });
   */ addEventListener (type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const signal = typeof options === "object" ? options.signal : void 0;
        const once = typeof options === "object" ? options.once === true : false;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
        const emitter = this;
        if (signal) {
            signal.addEventListener("abort", ()=>{
                emitter.off(type, listenerFn, context);
            });
        }
        if (once) {
            emitter.once(type, listenerFn, context);
        } else {
            emitter.on(type, listenerFn, context);
        }
    },
    /**
   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
   * seeks to be compatible with the DOM's `removeEventListener` with support for options.
   * @memberof scene.Container
   * @param type - The type of event the listener is bound to.
   * @param listener - The listener callback or object.
   * @param options - The original listener options. This is required to deregister a capture phase listener.
   */ removeEventListener (type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context);
    },
    /**
   * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
   *
   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
   * @memberof scene.Container
   * @param e - The event to dispatch.
   * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
   * @example
   * // Reuse a click event!
   * button.dispatchEvent(clickEvent);
   */ dispatchEvent (e) {
        if (!(e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedEvent"])) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e.defaultPrevented = false;
        e.path = null;
        e.target = this;
        e.manager.dispatchEvent(e);
        return !e.defaultPrevented;
    }
};
;
 //# sourceMappingURL=FederatedEventTarget.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/events/init.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/EventSystem.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEventTarget$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventSystem"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"].mixin(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEventTarget$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedContainer"]); //# sourceMappingURL=init.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "AccessibilitySystem": (()=>AccessibilitySystem)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isMobile$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/browser/isMobile.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/data/removeItems.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilitySystem {
    // 2fps
    // eslint-disable-next-line jsdoc/require-param
    /**
   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
   */ constructor(renderer, _mobileInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isMobile$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMobile"]){
        this._mobileInfo = _mobileInfo;
        /** Setting this to true will visually show the divs. */ this.debug = false;
        /** Internal variable, see isActive getter. */ this._isActive = false;
        /** Internal variable, see isMobileAccessibility getter. */ this._isMobileAccessibility = false;
        /** A simple pool for storing divs. */ this._pool = [];
        /** This is a tick used to check if an object is no longer being rendered. */ this._renderId = 0;
        /** The array of currently active accessible items. */ this._children = [];
        /** Count to throttle div updates on android devices. */ this._androidUpdateCount = 0;
        /**  The frequency to update the div elements. */ this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
        }
        const div = document.createElement("div");
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.position = "absolute";
        div.style.top = `${DIV_TOUCH_POS_X}px`;
        div.style.left = `${DIV_TOUCH_POS_Y}px`;
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this._div = div;
        this._renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @member {boolean}
   * @readonly
   */ get isActive() {
        return this._isActive;
    }
    /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @member {boolean}
   * @readonly
   */ get isMobileAccessibility() {
        return this._isMobileAccessibility;
    }
    get hookDiv() {
        return this._hookDiv;
    }
    /**
   * Creates the touch hooks.
   * @private
   */ _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", ()=>{
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    /**
   * Destroys the touch hooks.
   * @private
   */ _destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */ _activate() {
        if (this._isActive) {
            return;
        }
        this._isActive = true;
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.add(this);
        this._renderer.view.canvas.parentNode?.appendChild(this._div);
    }
    /**
   * Deactivating will cause the Accessibility layer to be hidden.
   * This is called when a user moves the mouse.
   * @private
   */ _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
            return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.remove(this);
        this._div.parentNode?.removeChild(this._div);
    }
    /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {Container} container - The Container to check.
   */ _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
            return;
        }
        if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
                this._addChild(container);
            }
            container._renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
            for(let i = 0; i < children.length; i++){
                this._updateAccessibleObjects(children[i]);
            }
        }
    }
    /**
   * Runner init called, view is available at this point.
   * @ignore
   */ init(options) {
        this.debug = options?.debug ?? this.debug;
        this._renderer.runners.postrender.remove(this);
    }
    /**
   * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.
   * Only fires while active.
   * @ignore
   */ postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
        }
        if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        const { x, y, width, height } = this._renderer.view.canvas.getBoundingClientRect();
        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
        const sx = width / viewWidth * resolution;
        const sy = height / viewHeight * resolution;
        let div = this._div;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.width = `${viewWidth}px`;
        div.style.height = `${viewHeight}px`;
        for(let i = 0; i < this._children.length; i++){
            const child = this._children[i];
            if (child._renderId !== this._renderId) {
                child._accessibleActive = false;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeItems"])(this._children, i, 1);
                this._div.removeChild(child._accessibleDiv);
                this._pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
                i--;
            } else {
                div = child._accessibleDiv;
                let hitArea = child.hitArea;
                const wt = child.worldTransform;
                if (child.hitArea) {
                    div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                    div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                    div.style.width = `${hitArea.width * wt.a * sx}px`;
                    div.style.height = `${hitArea.height * wt.d * sy}px`;
                } else {
                    hitArea = child.getBounds().rectangle;
                    this._capHitArea(hitArea);
                    div.style.left = `${hitArea.x * sx}px`;
                    div.style.top = `${hitArea.y * sy}px`;
                    div.style.width = `${hitArea.width * sx}px`;
                    div.style.height = `${hitArea.height * sy}px`;
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle || "";
                    }
                    if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                        div.setAttribute("aria-label", child.accessibleHint || "");
                    }
                }
                if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
                    div.title = child.accessibleTitle || "";
                    div.tabIndex = child.tabIndex;
                    if (this.debug) {
                        this._updateDebugHTML(div);
                    }
                }
            }
        }
        this._renderId++;
    }
    /**
   * private function that will visually add the information to the
   * accessibility div
   * @param {HTMLElement} div -
   */ _updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
    }
    /**
   * Adjust the hit area based on the bounds of a display object
   * @param {Rectangle} hitArea - Bounds of the child
   */ _capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
        }
    }
    /**
   * Adds a Container to the accessibility manager
   * @private
   * @param {Container} container - The child to make accessible.
   */ _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
            div = document.createElement("button");
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
                div.setAttribute("aria-live", "off");
            } else {
                div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                div.setAttribute("aria-relevant", "additions");
            } else {
                div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
            this._updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        container._accessibleDiv.tabIndex = container.tabIndex;
    }
    /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */ _dispatchEvent(e, type) {
        const { container: target } = e.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FederatedEvent"](boundary), {
            target
        });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type.forEach((type2)=>boundary.dispatchEvent(event, type2));
    }
    /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */ _onClick(e) {
        this._dispatchEvent(e, [
            "click",
            "pointertap",
            "tap"
        ]);
    }
    /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */ _onFocus(e) {
        if (!e.target.getAttribute("aria-live")) {
            e.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e, [
            "mouseover"
        ]);
    }
    /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */ _onFocusOut(e) {
        if (!e.target.getAttribute("aria-live")) {
            e.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e, [
            "mouseout"
        ]);
    }
    /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */ _onKeyDown(e) {
        if (e.keyCode !== KEY_CODE_TAB) {
            return;
        }
        this._activate();
    }
    /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */ _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this._deactivate();
    }
    /** Destroys the accessibility manager */ destroy() {
        this._destroyTouchHook();
        this._div = null;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown);
        this._pool = null;
        this._children = null;
        this._renderer = null;
    }
}
/** @ignore */ AccessibilitySystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    name: "accessibility"
};
;
 //# sourceMappingURL=AccessibilitySystem.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "accessibilityTarget": (()=>accessibilityTarget)
});
"use strict";
const accessibilityTarget = {
    /**
   * Flag for if the object is accessible. If true AccessibilityManager will overlay a
   * shadow div with attributes set
   * @member {boolean}
   * @memberof scene.Container#
   */ accessible: false,
    /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
   * @member {string}
   * @memberof scene.Container#
   */ accessibleTitle: null,
    /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof scene.Container#
   */ accessibleHint: null,
    /**
   * @member {number}
   * @memberof scene.Container#
   * @todo Needs docs.
   */ tabIndex: 0,
    /**
   * @member {boolean}
   * @memberof scene.Container#
   * @private
   */ _accessibleActive: false,
    /**
   * @memberof scene.Container#
   * @private
   */ _accessibleDiv: null,
    /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof scene.Container#
   * @default 'button'
   */ accessibleType: "button",
    /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @type {PointerEvents}
   * @memberof scene.Container#
   * @default 'auto'
   */ accessiblePointerEvents: "auto",
    /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof scene.Container#
   * @default true
   */ accessibleChildren: true,
    /**
   * @member {number}
   * @memberof scene.Container#
   * @private
   */ _renderId: -1
};
;
 //# sourceMappingURL=accessibilityTarget.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/accessibility/init.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$accessibility$2f$AccessibilitySystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$accessibility$2f$accessibilityTarget$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$accessibility$2f$AccessibilitySystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AccessibilitySystem"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"].mixin(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$accessibility$2f$accessibilityTarget$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["accessibilityTarget"]); //# sourceMappingURL=init.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Color": (()=>Color)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@pixi/colord/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$plugins$2f$names$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@pixi/colord/plugins/names.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extend"])([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$plugins$2f$names$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
const _Color = class _Color {
    /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */ constructor(value = 16777215){
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
    }
    /** Get red component (0 - 1) */ get red() {
        return this._components[0];
    }
    /** Get green component (0 - 1) */ get green() {
        return this._components[1];
    }
    /** Get blue component (0 - 1) */ get blue() {
        return this._components[2];
    }
    /** Get alpha component (0 - 1) */ get alpha() {
        return this._components[3];
    }
    /**
   * Set the value, suitable for chaining
   * @param value
   * @see Color.value
   */ setValue(value) {
        this.value = value;
        return this;
    }
    /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
   *   {@link Color.premultiply premultiply} or {@link Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   */ set value(value) {
        if (value instanceof _Color) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
        } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._value = this._cloneSource(value);
            this._normalize(this._value);
        }
    }
    get value() {
        return this._value;
    }
    /**
   * Copy a color source internally.
   * @param value - Color source
   */ _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
            return {
                ...value
            };
        }
        return value;
    }
    /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */ _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
            return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
                return false;
            }
            return value1.every((v, i)=>v === value2[i]);
        } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
                return false;
            }
            return keys1.every((key)=>value1[key] === value2[key]);
        }
        return value1 === value2;
    }
    /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */ toRgba() {
        const [r, g, b, a] = this._components;
        return {
            r,
            g,
            b,
            a
        };
    }
    /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */ toRgb() {
        const [r, g, b] = this._components;
        return {
            r,
            g,
            b
        };
    }
    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */ toRgbaString() {
        const [r, g, b] = this.toUint8RgbArray();
        return `rgba(${r},${g},${b},${this.alpha})`;
    }
    toUint8RgbArray(out) {
        const [r, g, b] = this._components;
        if (!this._arrayRgb) {
            this._arrayRgb = [];
        }
        out || (out = this._arrayRgb);
        out[0] = Math.round(r * 255);
        out[1] = Math.round(g * 255);
        out[2] = Math.round(b * 255);
        return out;
    }
    toArray(out) {
        if (!this._arrayRgba) {
            this._arrayRgba = [];
        }
        out || (out = this._arrayRgba);
        const [r, g, b, a] = this._components;
        out[0] = r;
        out[1] = g;
        out[2] = b;
        out[3] = a;
        return out;
    }
    toRgbArray(out) {
        if (!this._arrayRgb) {
            this._arrayRgb = [];
        }
        out || (out = this._arrayRgb);
        const [r, g, b] = this._components;
        out[0] = r;
        out[1] = g;
        out[2] = b;
        return out;
    }
    /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */ toNumber() {
        return this._int;
    }
    /**
   * Convert to a BGR number
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   */ toBgrNumber() {
        const [r, g, b] = this.toUint8RgbArray();
        return (b << 16) + (g << 8) + r;
    }
    /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */ toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
    }
    /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {ColorSource} value - The color to multiply by.
   */ multiply(value) {
        const [r, g, b, a] = _Color._temp.setValue(value)._components;
        this._components[0] *= r;
        this._components[1] *= g;
        this._components[2] *= b;
        this._components[3] *= a;
        this._refreshInt();
        this._value = null;
        return this;
    }
    /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {Color} - Itself.
   */ premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
    }
    /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */ toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
            return (255 << 24) + this._int;
        }
        if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
        }
        let r = this._int >> 16 & 255;
        let g = this._int >> 8 & 255;
        let b = this._int & 255;
        if (applyToRGB) {
            r = r * alpha + 0.5 | 0;
            g = g * alpha + 0.5 | 0;
            b = b * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
    }
    /**
   * Convert to a hexadecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */ toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
    }
    /**
   * Convert to a hexadecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */ toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
    }
    /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */ setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
    }
    /**
   * Normalize the input value into rgba
   * @param value - Input value
   */ _normalize(value) {
        let r;
        let g;
        let b;
        let a;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r = (int >> 16 & 255) / 255;
            g = (int >> 8 & 255) / 255;
            b = (int & 255) / 255;
            a = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r, g, b, a = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r, g, b, a = 255] = value;
            r /= 255;
            g /= 255;
            b /= 255;
            a /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
                const match = _Color.HEX_PATTERN.exec(value);
                if (match) {
                    value = `#${match[2]}`;
                }
            }
            const color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["colord"])(value);
            if (color.isValid()) {
                ({ r, g, b, a } = color.rgba);
                r /= 255;
                g /= 255;
                b /= 255;
            }
        }
        if (r !== void 0) {
            this._components[0] = r;
            this._components[1] = g;
            this._components[2] = b;
            this._components[3] = a;
            this._refreshInt();
        } else {
            throw new Error(`Unable to convert color ${value}`);
        }
    }
    /** Refresh the internal color rgb number */ _refreshInt() {
        this._clamp(this._components);
        const [r, g, b] = this._components;
        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
    }
    /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */ _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
        }
        value.forEach((v, i)=>{
            value[i] = Math.min(Math.max(v, min), max);
        });
        return value;
    }
    /**
   * Check if the value is a color-like object
   * @param value - Value to check
   * @returns True if the value is a color-like object
   * @static
   * @example
   * import { Color } from 'pixi.js';
   * Color.isColorLike('white'); // returns true
   * Color.isColorLike(0xffffff); // returns true
   * Color.isColorLike([1, 1, 1]); // returns true
   */ static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
    }
};
/**
 * Default Color object for static uses
 * @example
 * import { Color } from 'pixi.js';
 * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'
 */ _Color.shared = new _Color();
/**
 * Temporary Color object for static uses internally.
 * As to not conflict with Color.shared.
 * @ignore
 */ _Color._temp = new _Color();
/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;
;
 //# sourceMappingURL=Color.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/filters/FilterEffect.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FilterEffect": (()=>FilterEffect)
});
"use strict";
class FilterEffect {
    constructor(){
        /** the pipe that knows how to handle this effect */ this.pipe = "filter";
        /** the priority of this effect */ this.priority = 1;
    }
    destroy() {
        for(let i = 0; i < this.filters.length; i++){
            this.filters[i].destroy();
        }
        this.filters = null;
        this.filterArea = null;
    }
}
;
 //# sourceMappingURL=FilterEffect.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/filters/FilterSystem.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FilterSystem": (()=>FilterSystem)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$BindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getFastGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getRenderableBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/types.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const quadGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"]({
    attributes: {
        aPosition: {
            buffer: new Float32Array([
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1
            ]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
        }
    },
    indexBuffer: new Uint32Array([
        0,
        1,
        2,
        0,
        2,
        3
    ])
});
class FilterSystem {
    constructor(renderer){
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uInputSize: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputPixel: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputClamp: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uGlobalFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputTexture: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            }
        });
        this._globalFilterBindGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$BindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BindGroup"]({});
        this.renderer = renderer;
    }
    /**
   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
   * @readonly
   */ get activeBackTexture() {
        return this._activeFilterData?.backTexture;
    }
    push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
        }
        const filterData = this._filterStack[this._filterStackIndex];
        this._filterStackIndex++;
        if (filters.length === 0) {
            filterData.skip = true;
            return;
        }
        const bounds = filterData.bounds;
        if (instruction.renderables) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getRenderableBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGlobalRenderableBounds"])(instruction.renderables, bounds);
        } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getFastGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFastGlobalBounds"])(instruction.container, bounds);
        }
        if (instruction.container) {
            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
            const filterFrameTransform = renderGroup.cacheToLocalTransform;
            if (filterFrameTransform) {
                bounds.applyMatrix(filterFrameTransform);
            }
        }
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        let resolution = Infinity;
        let padding = 0;
        let antialias = true;
        let blendRequired = false;
        let enabled = false;
        let clipToViewport = true;
        for(let i = 0; i < filters.length; i++){
            const filter = filters[i];
            resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);
            padding += filter.padding;
            if (filter.antialias === "off") {
                antialias = false;
            } else if (filter.antialias === "inherit") {
                antialias && (antialias = colorTextureSource.antialias);
            }
            if (!filter.clipToViewport) {
                clipToViewport = false;
            }
            const isCompatible = !!(filter.compatibleRenderers & renderer.type);
            if (!isCompatible) {
                enabled = false;
                break;
            }
            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
                enabled = false;
                break;
            }
            enabled = filter.enabled || enabled;
            blendRequired || (blendRequired = filter.blendRequired);
        }
        if (!enabled) {
            filterData.skip = true;
            return;
        }
        if (clipToViewport) {
            const viewPort = renderer.renderTarget.rootViewPort;
            const rootResolution = renderer.renderTarget.renderTarget.resolution;
            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
        }
        bounds.scale(resolution).ceil().scale(1 / resolution).pad(padding | 0);
        if (!bounds.isPositive) {
            filterData.skip = true;
            return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
        filterData.inputTexture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].getOptimalTexture(bounds.width, bounds.height, resolution, antialias);
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
            offset: bounds
        });
    }
    pop() {
        const renderer = this.renderer;
        this._filterStackIndex--;
        const filterData = this._filterStack[this._filterStackIndex];
        if (filterData.skip) {
            return;
        }
        this._activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY;
        renderer.renderTarget.finishRenderPass();
        if (filterData.blendRequired) {
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
        }
        filterData.backTexture = backTexture;
        const filters = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (filters.length === 1) {
            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(inputTexture);
        } else {
            let flip = filterData.inputTexture;
            let flop = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);
            let i = 0;
            for(i = 0; i < filters.length - 1; ++i){
                const filter = filters[i];
                filter.apply(this, flip, flop, true);
                const t = flip;
                flip = flop;
                flop = t;
            }
            filters[i].apply(this, flip, filterData.previousRenderSurface, false);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(flip);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(flop);
        }
        if (filterData.blendRequired) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(backTexture);
        }
    }
    getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);
        let x = bounds.minX;
        let y = bounds.minY;
        if (previousBounds) {
            x -= previousBounds.minX;
            y -= previousBounds.minY;
        }
        x = Math.floor(x * backgroundResolution);
        y = Math.floor(y * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {
            x,
            y
        }, {
            width,
            height
        }, {
            x: 0,
            y: 0
        });
        return backTexture;
    }
    applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._filterStack[this._filterStackIndex];
        const bounds = filterData.bounds;
        const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"].shared;
        const previousRenderSurface = filterData.previousRenderSurface;
        const isFinalTarget = previousRenderSurface === output;
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let currentIndex = this._filterStackIndex - 1;
        while(currentIndex > 0 && this._filterStack[currentIndex].skip){
            --currentIndex;
        }
        if (currentIndex > 0) {
            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
        }
        const filterUniforms = this._filterGlobalUniforms;
        const uniforms = filterUniforms.uniforms;
        const outputFrame = uniforms.uOutputFrame;
        const inputSize = uniforms.uInputSize;
        const inputPixel = uniforms.uInputPixel;
        const inputClamp = uniforms.uInputClamp;
        const globalFrame = uniforms.uGlobalFrame;
        const outputTexture = uniforms.uOutputTexture;
        if (isFinalTarget) {
            let lastIndex = this._filterStackIndex;
            while(lastIndex > 0){
                lastIndex--;
                const filterData2 = this._filterStack[this._filterStackIndex - 1];
                if (!filterData2.skip) {
                    offset.x = filterData2.bounds.minX;
                    offset.y = filterData2.bounds.minY;
                    break;
                }
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
        } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
        }
        outputFrame[2] = input.frame.width;
        outputFrame[3] = input.frame.height;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
        renderer.renderTarget.bind(output, !!clear);
        if (output instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            outputTexture[0] = output.frame.width;
            outputTexture[1] = output.frame.height;
        } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
        }
        outputTexture[2] = renderTarget.isRoot ? -1 : 1;
        filterUniforms.update();
        if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        filter.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter,
            state: filter._state,
            topology: "triangle-list"
        });
        if (renderer.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RendererType"].WEBGL) {
            renderer.renderTarget.finishRenderPass();
        }
    }
    _getFilterData() {
        return {
            skip: false,
            inputTexture: null,
            bounds: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"](),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
        };
    }
    /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */ calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);
        const worldTransform = sprite.worldTransform.copyTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].shared);
        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
        if (renderGroup && renderGroup.cacheToLocalTransform) {
            worldTransform.prepend(renderGroup.cacheToLocalTransform);
        }
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
    }
}
/** @ignore */ FilterSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    name: "filter"
};
;
 //# sourceMappingURL=FilterSystem.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/filters/FilterPipe.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "FilterPipe": (()=>FilterPipe)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
class FilterPipe {
    constructor(renderer){
        this._renderer = renderer;
    }
    push(filterEffect, container, instructionSet) {
        const renderPipes = this._renderer.renderPipes;
        renderPipes.batch.break(instructionSet);
        instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
        });
    }
    pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
        });
    }
    execute(instruction) {
        if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
        }
    }
    destroy() {
        this._renderer = null;
    }
}
FilterPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "filter"
};
;
 //# sourceMappingURL=FilterPipe.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/filters/init.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/filters/FilterSystem.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/filters/FilterPipe.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilterSystem"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilterPipe"]); //# sourceMappingURL=init.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/culling/cullingMixin.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "cullingMixin": (()=>cullingMixin)
});
"use strict";
const cullingMixin = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
};
;
 //# sourceMappingURL=cullingMixin.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/app/ResizePlugin.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizePlugin": (()=>ResizePlugin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
class ResizePlugin {
    /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */ static init(options) {
        Object.defineProperty(this, "resizeTo", /**
       * The HTML element or window to automatically resize the
       * renderer's view element to match width and height.
       * @member {Window|HTMLElement}
       * @name resizeTo
       * @memberof app.Application#
       */ {
            set (dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                    globalThis.addEventListener("resize", this.queueResize);
                    this.resize();
                }
            },
            get () {
                return this._resizeTo;
            }
        });
        this.queueResize = ()=>{
            if (!this._resizeTo) {
                return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(()=>this.resize());
        };
        this._cancelResize = ()=>{
            if (this._resizeId) {
                cancelAnimationFrame(this._resizeId);
                this._resizeId = null;
            }
        };
        this.resize = ()=>{
            if (!this._resizeTo) {
                return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
                width = globalThis.innerWidth;
                height = globalThis.innerHeight;
            } else {
                const { clientWidth, clientHeight } = this._resizeTo;
                width = clientWidth;
                height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
    }
    /**
   * Clean up the ticker, scoped to application
   * @static
   * @private
   */ static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
    }
}
/** @ignore */ ResizePlugin.extension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].Application;
;
 //# sourceMappingURL=ResizePlugin.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/app/TickerPlugin.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "TickerPlugin": (()=>TickerPlugin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class TickerPlugin {
    /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */ static init(options) {
        options = Object.assign({
            autoStart: true,
            sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
            set (ticker) {
                if (this._ticker) {
                    this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                    ticker.add(this.render, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].LOW);
                }
            },
            get () {
                return this._ticker;
            }
        });
        this.stop = ()=>{
            this._ticker.stop();
        };
        this.start = ()=>{
            this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].shared : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"]();
        if (options.autoStart) {
            this.start();
        }
    }
    /**
   * Clean up the ticker, scoped to application.
   * @static
   * @private
   */ static destroy() {
        if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
        }
    }
}
/** @ignore */ TickerPlugin.extension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].Application;
;
 //# sourceMappingURL=TickerPlugin.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/app/init.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$app$2f$ResizePlugin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/app/ResizePlugin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$app$2f$TickerPlugin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/app/TickerPlugin.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$app$2f$ResizePlugin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ResizePlugin"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$app$2f$TickerPlugin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TickerPlugin"]); //# sourceMappingURL=init.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "UPDATE_PRIORITY": (()=>UPDATE_PRIORITY)
});
"use strict";
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});
;
 //# sourceMappingURL=const.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/ticker/TickerListener.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "TickerListener": (()=>TickerListener)
});
"use strict";
class TickerListener {
    /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */ constructor(fn, context = null, priority = 0, once = false){
        /** The next item in chain. */ this.next = null;
        /** The previous item in chain. */ this.previous = null;
        /** `true` if this listener has been destroyed already. */ this._destroyed = false;
        this._fn = fn;
        this._context = context;
        this.priority = priority;
        this._once = once;
    }
    /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */ match(fn, context = null) {
        return this._fn === fn && this._context === context;
    }
    /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */ emit(ticker) {
        if (this._fn) {
            if (this._context) {
                this._fn.call(this._context, ticker);
            } else {
                this._fn(ticker);
            }
        }
        const redirect = this.next;
        if (this._once) {
            this.destroy(true);
        }
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */ connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */ destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
}
;
 //# sourceMappingURL=TickerListener.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Ticker": (()=>Ticker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/TickerListener.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const _Ticker = class _Ticker {
    constructor(){
        /**
     * Whether or not this ticker should invoke the method
     * {@link ticker.Ticker#start|start} automatically when a listener is added.
     */ this.autoStart = false;
        /**
     * Scalar time value from last frame to this frame.
     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}
     * and is scaled with {@link ticker.Ticker#speed|speed}.
     * **Note:** The cap may be exceeded by scaling.
     */ this.deltaTime = 1;
        /**
     * The last time {@link ticker.Ticker#update|update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     */ this.lastTime = -1;
        /**
     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.
     * @example
     * // Scales ticker.deltaTime to what would be
     * // the equivalent of approximately 120 FPS
     * ticker.speed = 2;
     */ this.speed = 1;
        /**
     * Whether or not this ticker has been started.
     * `true` if {@link ticker.Ticker#start|start} has been called.
     * `false` if {@link ticker.Ticker#stop|Stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`
     * and a listener is added.
     */ this.started = false;
        /** Internal current frame request ID */ this._requestId = null;
        /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     */ this._maxElapsedMS = 100;
        /**
     * Internal value managed by minFPS property setter and getter.
     * This is the minimum allowed milliseconds between updates.
     */ this._minElapsedMS = 0;
        /** If enabled, deleting is disabled.*/ this._protected = false;
        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;
        this._head = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TickerListener"](null, null, Infinity);
        this.deltaMS = 1 / _Ticker.targetFPMS;
        this.elapsedMS = 1 / _Ticker.targetFPMS;
        this._tick = (time)=>{
            this._requestId = null;
            if (this.started) {
                this.update(time);
                if (this.started && this._requestId === null && this._head.next) {
                    this._requestId = requestAnimationFrame(this._tick);
                }
            }
        };
    }
    /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */ _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    /**
   * Conditionally cancels a pending animation frame.
   * @private
   */ _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */ _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        } else if (this.autoStart) {
            this.start();
        }
    }
    /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */ add(fn, context, priority = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].NORMAL) {
        return this._addListener(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TickerListener"](fn, context, priority));
    }
    /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */ addOnce(fn, context, priority = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].NORMAL) {
        return this._addListener(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TickerListener"](fn, context, priority, true));
    }
    /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */ _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
            listener.connect(previous);
        } else {
            while(current){
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */ remove(fn, context) {
        let listener = this._head.next;
        while(listener){
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            } else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */ get count() {
        if (!this._head) {
            return 0;
        }
        let count = 0;
        let current = this._head;
        while(current = current.next){
            count++;
        }
        return count;
    }
    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */ start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */ stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */ destroy() {
        if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while(listener){
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    /**
   * Triggers an update. An update entails setting the
   * current {@link ticker.Ticker#elapsedMS|elapsedMS},
   * the current {@link ticker.Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */ update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
                const delta = currentTime - this._lastFrame | 0;
                if (delta < this._minElapsedMS) {
                    return;
                }
                this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while(listener){
                listener = listener.emit(this);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link ticker.Ticker#speed|speed}, which is specific
   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
   * @member {number}
   * @readonly
   */ get FPS() {
        return 1e3 / this.elapsedMS;
    }
    /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */ get minFPS() {
        return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
        const minFPS = Math.min(this.maxFPS, fps);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */ get maxFPS() {
        if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
    }
    set maxFPS(fps) {
        if (fps === 0) {
            this._minElapsedMS = 0;
        } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
    }
    /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */ static get shared() {
        if (!_Ticker._shared) {
            const shared = _Ticker._shared = new _Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return _Ticker._shared;
    }
    /**
   * The system ticker instance used by {@link BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */ static get system() {
        if (!_Ticker._system) {
            const system = _Ticker._system = new _Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return _Ticker._system;
    }
};
/**
 * Target frames per millisecond.
 * @static
 */ _Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;
;
 //# sourceMappingURL=Ticker.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Spritesheet": (()=>Spritesheet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const _Spritesheet = class _Spritesheet {
    /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   */ constructor(texture, data){
        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];
        this._texture = texture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"] ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
        } else {
            this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
    }
    /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */ parse() {
        return new Promise((resolve)=>{
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
                this._processFrames(0);
                this._processAnimations();
                this._parseComplete();
            } else {
                this._nextBatch();
            }
        });
    }
    /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */ _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet.BATCH_SIZE;
        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){
            const i = this._frameKeys[frameIndex];
            const data = this._frames[i];
            const rect = data.frame;
            if (rect) {
                let frame = null;
                let trim = null;
                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
                const orig = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    frame = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                } else {
                    frame = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
                    source: this.textureSource,
                    frame,
                    orig,
                    trim,
                    rotate: data.rotated ? 2 : 0,
                    defaultAnchor: data.anchor,
                    defaultBorders: data.borders,
                    label: i.toString()
                });
            }
            frameIndex++;
        }
    }
    /** Parse animations config. */ _processAnimations() {
        const animations = this.data.animations || {};
        for(const animName in animations){
            this.animations[animName] = [];
            for(let i = 0; i < animations[animName].length; i++){
                const frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    /** The parse has completed. */ _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    /** Begin the next batch of textures. */ _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(()=>{
            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
                this._nextBatch();
            } else {
                this._processAnimations();
                this._parseComplete();
            }
        }, 0);
    }
    /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */ destroy(destroyBase = false) {
        for(const i in this.textures){
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
    }
};
/** The maximum number of Textures to build per process. */ _Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;
;
 //# sourceMappingURL=Spritesheet.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "spritesheetAsset": (()=>spritesheetAsset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/path.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const validImages = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out = {};
    keys.forEach((key)=>{
        out[key] = asset;
    });
    Object.keys(asset.textures).forEach((key)=>{
        out[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
        const basePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].dirname(keys[0]);
        asset.linkedSheets.forEach((item, i)=>{
            const out2 = getCacheableAssets([
                `${basePath}/${asset.data.meta.related_multi_packs[i]}`
            ], item, true);
            Object.assign(out, out2);
        });
    }
    return out;
}
const spritesheetAsset = {
    extension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].Asset,
    /** Handle the caching of the related Spritesheet Textures */ cache: {
        test: (asset)=>asset instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Spritesheet"],
        getCacheableAssets: (keys, asset)=>getCacheableAssets(keys, asset, false)
    },
    /** Resolve the resolution of the asset. */ resolver: {
        extension: {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ResolveParser,
            name: "resolveSpritesheet"
        },
        test: (value)=>{
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
        },
        parse: (value)=>{
            const split = value.split(".");
            return {
                resolution: parseFloat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Resolver"].RETINA_PREFIX.exec(value)?.[1] ?? "1"),
                format: split[split.length - 2],
                src: value
            };
        }
    },
    /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */ loader: {
        name: "spritesheetLoader",
        extension: {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
            priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoaderParserPriority"].Normal,
            name: "spritesheetLoader"
        },
        async testParse (asset, options) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse (asset, options, loader) {
            const { texture: imageTexture, // if user need to use preloaded texture
            imageFilename } = options?.data ?? {};
            let basePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
                basePath += "/";
            }
            let texture;
            if (imageTexture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
                texture = imageTexture;
            } else {
                const imagePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copySearchParams"])(basePath + (imageFilename ?? asset.meta.image), options.src);
                const assets = await loader.load([
                    imagePath
                ]);
                texture = assets[imagePath];
            }
            const spritesheet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Spritesheet"](texture.source, asset);
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
                const promises = [];
                for (const item of multiPacks){
                    if (typeof item !== "string") {
                        continue;
                    }
                    let itemUrl = basePath + item;
                    if (options.data?.ignoreMultiPack) {
                        continue;
                    }
                    itemUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copySearchParams"])(itemUrl, options.src);
                    promises.push(loader.load({
                        src: itemUrl,
                        data: {
                            ignoreMultiPack: true
                        }
                    }));
                }
                const res = await Promise.all(promises);
                spritesheet.linkedSheets = res;
                res.forEach((item)=>{
                    item.linkedSheets = [
                        spritesheet
                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));
                });
            }
            return spritesheet;
        },
        async unload (spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
        }
    }
};
;
 //# sourceMappingURL=spritesheetAsset.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/spritesheet/init.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$spritesheetAsset$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$spritesheetAsset$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["spritesheetAsset"]); //# sourceMappingURL=init.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/utils/convertToList.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "convertToList": (()=>convertToList)
});
"use strict";
const convertToList = (input, transform, forceTransform = false)=>{
    if (!Array.isArray(input)) {
        input = [
            input
        ];
    }
    if (!transform) {
        return input;
    }
    return input.map((item)=>{
        if (typeof item === "string" || forceTransform) {
            return transform(item);
        }
        return item;
    });
};
;
 //# sourceMappingURL=convertToList.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "createStringVariations": (()=>createStringVariations)
});
"use strict";
function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for(let i = 0; i < id.length; i++){
        const value = id[i];
        if (depth < ids.length - 1) {
            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
        } else {
            tags.push(base.replace(result[depth], value));
        }
    }
}
function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
        const ids = [];
        result.forEach((vars)=>{
            const split = vars.substring(1, vars.length - 1).split(",");
            ids.push(split);
        });
        processX(string, ids, 0, result, tags);
    } else {
        tags.push(string);
    }
    return tags;
}
;
 //# sourceMappingURL=createStringVariations.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "isSingleItem": (()=>isSingleItem)
});
"use strict";
const isSingleItem = (item)=>!Array.isArray(item);
;
 //# sourceMappingURL=isSingleItem.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Resolver": (()=>Resolver),
    "getUrlExtension": (()=>getUrlExtension)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/utils/convertToList.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$createStringVariations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$isSingleItem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/path.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class Resolver {
    constructor(){
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */ this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        /**
     * A function that generates a bundle asset id key from a bundleId and an assetId
     * @param bundleId - the bundleId
     * @param assetId  - the assetId
     * @returns the bundle asset id key
     */ this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        /**
     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId
     * @param bundleId - the bundleId
     * @param assetBundleId - the bundle asset id key
     * @returns the assetId
     */ this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
    }
    /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */ setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
    }
    /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */ prefer(...preferOrders) {
        preferOrders.forEach((prefer)=>{
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
                prefer.priority = Object.keys(prefer.params);
            }
        });
        this._resolverHash = {};
    }
    /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */ set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */ set rootPath(rootPath) {
        this._rootPath = rootPath;
    }
    get rootPath() {
        return this._rootPath;
    }
    /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */ get parsers() {
        return this._parsers;
    }
    /** Used for testing, this resets the resolver to its initial state */ reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
    }
    /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */ setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
        } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
    }
    /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */ getAlias(asset) {
        const { alias, src } = asset;
        const aliasesToUse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(alias || src, (value)=>{
            if (typeof value === "string") return value;
            if (Array.isArray(value)) return value.map((v)=>v?.src ?? v);
            if (value?.src) return value.src;
            return value;
        }, true);
        return aliasesToUse;
    }
    /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */ addManifest(manifest) {
        if (this._manifest) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle)=>{
            this.addBundle(bundle.name, bundle.assets);
        });
    }
    /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */ addBundle(bundleId, assets) {
        const assetNames = [];
        let convertedAssets = assets;
        if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src])=>{
                if (typeof src === "string" || Array.isArray(src)) {
                    return {
                        alias,
                        src
                    };
                }
                return {
                    alias,
                    ...src
                };
            });
        }
        convertedAssets.forEach((asset)=>{
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
                assetNames.push(bundleAssetId);
                ids = [
                    aliases,
                    bundleAssetId
                ];
            } else {
                const bundleIds = aliases.map((name)=>this._createBundleAssetId(bundleId, name));
                assetNames.push(...bundleIds);
                ids = [
                    ...aliases,
                    ...bundleIds
                ];
            }
            this.add({
                ...asset,
                ...{
                    alias: ids,
                    src: srcs
                }
            });
        });
        this._bundles[bundleId] = assetNames;
    }
    /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */ add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
            assets.push(...aliases);
        } else {
            assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key)=>{
            if (this.hasKey(key)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`[Resolver] already has key: ${key} overwriting`);
            }
        };
        const assetArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(assets);
        assetArray.forEach((asset)=>{
            const { src } = asset;
            let { data, format, loadParser } = asset;
            const srcsToUse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(src).map((src2)=>{
                if (typeof src2 === "string") {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$createStringVariations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createStringVariations"])(src2);
                }
                return Array.isArray(src2) ? src2 : [
                    src2
                ];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs)=>{
                srcs.forEach((src2)=>{
                    let formattedAsset = {};
                    if (typeof src2 !== "object") {
                        formattedAsset.src = src2;
                        for(let i = 0; i < this._parsers.length; i++){
                            const parser = this._parsers[i];
                            if (parser.test(src2)) {
                                formattedAsset = parser.parse(src2);
                                break;
                            }
                        }
                    } else {
                        data = src2.data ?? data;
                        format = src2.format ?? format;
                        loadParser = src2.loadParser ?? loadParser;
                        formattedAsset = {
                            ...formattedAsset,
                            ...src2
                        };
                    }
                    if (!aliasesToUse) {
                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                    }
                    formattedAsset = this._buildResolvedAsset(formattedAsset, {
                        aliases: aliasesToUse,
                        data,
                        format,
                        loadParser
                    });
                    resolvedAssets.push(formattedAsset);
                });
            });
            aliasesToUse.forEach((alias)=>{
                this._assetMap[alias] = resolvedAssets;
            });
        });
    }
    // TODO: this needs an overload like load did in Assets
    /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */ resolveBundle(bundleIds) {
        const singleAsset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$isSingleItem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSingleItem"])(bundleIds);
        bundleIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(bundleIds);
        const out = {};
        bundleIds.forEach((bundleId)=>{
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
                const results = this.resolve(assetNames);
                const assets = {};
                for(const key in results){
                    const asset = results[key];
                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
                }
                out[bundleId] = assets;
            }
        });
        return singleAsset ? out[bundleIds[0]] : out;
    }
    /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */ resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
            const out = {};
            for(const i in result){
                out[i] = result[i].src;
            }
            return out;
        }
        return result.src;
    }
    resolve(keys) {
        const singleAsset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$isSingleItem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSingleItem"])(keys);
        keys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(keys);
        const result = {};
        keys.forEach((key)=>{
            if (!this._resolverHash[key]) {
                if (this._assetMap[key]) {
                    let assets = this._assetMap[key];
                    const preferredOrder = this._getPreferredOrder(assets);
                    preferredOrder?.priority.forEach((priorityKey)=>{
                        preferredOrder.params[priorityKey].forEach((value)=>{
                            const filteredAssets = assets.filter((asset)=>{
                                if (asset[priorityKey]) {
                                    return asset[priorityKey] === value;
                                }
                                return false;
                            });
                            if (filteredAssets.length) {
                                assets = filteredAssets;
                            }
                        });
                    });
                    this._resolverHash[key] = assets[0];
                } else {
                    this._resolverHash[key] = this._buildResolvedAsset({
                        alias: [
                            key
                        ],
                        src: key
                    }, {});
                }
            }
            result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys[0]] : result;
    }
    /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */ hasKey(key) {
        return !!this._assetMap[key];
    }
    /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */ hasBundle(key) {
        return !!this._bundles[key];
    }
    /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */ _getPreferredOrder(assets) {
        for(let i = 0; i < assets.length; i++){
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference)=>preference.params.format.includes(asset.format));
            if (preferred) {
                return preferred;
            }
        }
        return this._preferredOrder[0];
    }
    /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */ _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams) return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, format } = data;
        if (this._basePath || this._rootPath) {
            formattedAsset.src = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [
            formattedAsset.src
        ];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = {
            ...assetData || {},
            ...formattedAsset.data
        };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
        return formattedAsset;
    }
}
/**
 * The prefix that denotes a URL is for a retina asset.
 * @static
 * @name RETINA_PREFIX
 * @type {RegExp}
 * @default /@([0-9\.]+)x/
 * @example `@2x`
 */ Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
}
;
 //# sourceMappingURL=Resolver.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "LoaderParserPriority": (()=>LoaderParserPriority)
});
"use strict";
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2)=>{
    LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
    LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
    LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
    return LoaderParserPriority2;
})(LoaderParserPriority || {});
;
 //# sourceMappingURL=LoaderParser.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "copySearchParams": (()=>copySearchParams)
});
"use strict";
const copySearchParams = (targetUrl, sourceUrl)=>{
    const searchParams = sourceUrl.split("?")[1];
    if (searchParams) {
        targetUrl += `?${searchParams}`;
    }
    return targetUrl;
};
;
 //# sourceMappingURL=copySearchParams.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Cache": (()=>Cache)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/assets/utils/convertToList.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class CacheClass {
    constructor(){
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
    }
    /** Clear all entries. */ reset() {
        this._cacheMap.clear();
        this._cache.clear();
    }
    /**
   * Check if the key exists
   * @param key - The key to check
   */ has(key) {
        return this._cache.has(key);
    }
    /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */ get(key) {
        const result = this._cache.get(key);
        if (!result) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
    }
    /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */ set(key, value) {
        const keys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$convertToList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertToList"])(key);
        let cacheableAssets;
        for(let i = 0; i < this.parsers.length; i++){
            const parser = this.parsers[i];
            if (parser.test(value)) {
                cacheableAssets = parser.getCacheableAssets(keys, value);
                break;
            }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
            keys.forEach((key2)=>{
                cacheableMap.set(key2, value);
            });
        }
        const cacheKeys = [
            ...cacheableMap.keys()
        ];
        const cachedAssets = {
            cacheKeys,
            keys
        };
        keys.forEach((key2)=>{
            this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2)=>{
            const val = cacheableAssets ? cacheableAssets[key2] : value;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
        });
    }
    /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */ remove(key) {
        if (!this._cacheMap.has(key)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
        }
        const cacheMap = this._cacheMap.get(key);
        const cacheKeys = cacheMap.cacheKeys;
        cacheKeys.forEach((key2)=>{
            this._cache.delete(key2);
        });
        cacheMap.keys.forEach((key2)=>{
            this._cacheMap.delete(key2);
        });
    }
    /** All loader parsers registered */ get parsers() {
        return this._parsers;
    }
}
const Cache = new CacheClass();
;
 //# sourceMappingURL=Cache.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "BrowserAdapter": (()=>BrowserAdapter)
});
"use strict";
const BrowserAdapter = {
    createCanvas: (width, height)=>{
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
    },
    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
    getWebGLRenderingContext: ()=>WebGLRenderingContext,
    getNavigator: ()=>navigator,
    getBaseUrl: ()=>document.baseURI ?? window.location.href,
    getFontFaceSet: ()=>document.fonts,
    fetch: (url, options)=>fetch(url, options),
    parseXML: (xml)=>{
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
    }
};
;
 //# sourceMappingURL=BrowserAdapter.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/environment-browser/browserAll.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$accessibility$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/accessibility/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$app$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/app/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/events/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/spritesheet/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/rendering/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/graphics/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/mesh/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/particle-container/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/text/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/text-html/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$init$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/filters/init.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict"; //# sourceMappingURL=browserAll.mjs.map
}}),
"[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "DOMAdapter": (()=>DOMAdapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$BrowserAdapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs [app-ssr] (ecmascript)");
;
"use strict";
let currentAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$BrowserAdapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BrowserAdapter"];
const DOMAdapter = {
    /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */ get () {
        return currentAdapter;
    },
    /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */ set (adapter) {
        currentAdapter = adapter;
    }
};
;
 //# sourceMappingURL=adapter.mjs.map
}}),

};

//# sourceMappingURL=node_modules_pixi_js_lib_1765a4._.js.map