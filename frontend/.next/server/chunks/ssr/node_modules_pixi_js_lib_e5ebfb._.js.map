{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"BackgroundSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n\n/**\n * Options for the background system.\n * @property {ColorSource} [backgroundColor='black']\n * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n * @property {ColorSource} [background] - Alias for backgroundColor\n * @property {number} [backgroundAlpha=1] -\n * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n * @property {boolean} [clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n * @memberof rendering\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @memberof rendering.SharedRendererOptions\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /**\n     * Alias for backgroundColor\n     * @memberof rendering.SharedRendererOptions\n     */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @memberof rendering.SharedRendererOptions\n     * @default 1\n     */\n    backgroundAlpha: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @memberof rendering.SharedRendererOptions\n     * @default true\n     */\n    clearBeforeRender: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @memberof rendering\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AA+CO,MAAM,iBAAA,GAAN,MAAM,iBACb,CAAA;IA0CI,WACA,EAAA;QACI,IAAA,CAAK,iBAAoB,GAAA,IAAA,CAAA;QAEpB,IAAA,CAAA,gBAAA,GAAmB,yJAAI,QAAA,CAAM,CAAQ,CAAA,CAAA;QAE1C,IAAA,CAAK,KAAA,GAAQ,IAAK,CAAA,gBAAA,CAAA;QAClB,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;IAAA;;;GAAA,GAMO,KAAK,OACZ,EAAA;QACI,OAAA,GAAU;YAAE,GAAG,iBAAiB,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAE3D,IAAA,CAAK,iBAAA,GAAoB,OAAQ,CAAA,iBAAA,CAAA;QACjC,IAAA,CAAK,KAAQ,GAAA,OAAA,CAAQ,UAAc,IAAA,OAAA,CAAQ,eAAA,IAAmB,IAAK,CAAA,gBAAA,CAAA;QACnE,IAAA,CAAK,KAAA,GAAQ,OAAQ,CAAA,eAAA,CAAA;QAEhB,IAAA,CAAA,gBAAA,CAAiB,QAAS,CAAA,OAAA,CAAQ,eAAe,CAAA,CAAA;IAAA,CAC1D;IAAA,oDAAA,GAGA,IAAI,KACJ,GAAA;QACI,OAAO,IAAK,CAAA,gBAAA,CAAA;IAAA,CAChB;IAEA,IAAI,MAAM,KACV,EAAA;QACS,IAAA,CAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,CAAA,CAAA;IAAA,CACxC;IAAA,oFAAA,GAGA,IAAI,KACJ,GAAA;QACI,OAAO,IAAA,CAAK,gBAAiB,CAAA,KAAA,CAAA;IAAA,CACjC;IAEA,IAAI,MAAM,KACV,EAAA;QACS,IAAA,CAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,CAAA,CAAA;IAAA,CACxC;IAAA,mDAAA,GAGA,IAAI,SACJ,GAAA;QACW,OAAA,IAAA,CAAK,gBAAA,CAAiB,OAAQ,EAAA,CAAA;IAAA,CACzC;IAAA;;;;GAAA,GAOO,OACP,GAAA,CAAA,CAEA;AACJ,CAAA,CAAA;AAAA,YAAA,GAzGa,iBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,YAAA;uKACd,gBAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,YAAA;IACN,QAAU,EAAA,CAAA;AACd,CAAA,CAAA;AAAA,uCAAA,GAXS,iBAAA,CAcK,cAA0C,GAAA;IAAA;;;GAAA,GAKpD,eAAiB,EAAA,CAAA;IAAA;;;GAAA,GAKjB,eAAiB,EAAA,CAAA;IAAA;;;GAAA,GAKjB,iBAAmB,EAAA,IAAA;AACvB,CAAA,CAAA;AA9BG,IAAM,gBAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"file":"colorToUniform.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts"],"sourcesContent":["export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n"],"names":[],"mappings":";;;;;AAAO,SAAS,cAAe,CAAA,GAAA,EAAa,KAAe,EAAA,GAAA,EAAmB,MAC9E,EAAA;IAEI,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IACvC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,CAAA,GAAK,GAAQ,IAAA,GAAA,CAAA;IAClC,GAAA,CAAA,MAAA,EAAQ,CAAK,GAAA,CAAA,GAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAC/B,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB,CAAA;AAEgB,SAAA,mBAAA,CAAoB,IAAc,EAAA,GAAA,EAAmB,MACrE,EAAA;IACU,MAAA,KAAA,GAAA,CAAU,IAAQ,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAEtC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,IAAO,GAAA,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IACxC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,CAAA,GAAK,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAC/C,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,EAAA,GAAM,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAChD,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB","ignoreList":[0]}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"file":"BindGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts"],"sourcesContent":["import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"file":"types.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/types.ts"],"sourcesContent":["import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n"],"names":["RendererType"],"mappings":";;;;AA2BY,IAAA,YAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,aAAL,KAAA;IAEHA,aAAAA,CAAAA,aAAAA,CAAA,QAAA,GAAQ,CAAR,CAAA,GAAA,OAAA,CAAA;IACAA,aAAAA,CAAAA,aAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IACAA,aAAAA,CAAAA,aAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAJQA,OAAAA,aAAAA,CAAAA;AAAA,CAAA,EAAA,YAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"file":"types.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts"],"sourcesContent":["// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n"],"names":[],"mappings":";;;;;AACO,MAAM,oBAAuB,GAAA;IAChC,KAAA;IACA,KAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;CACJ,CAAA;AAGO,MAAM,iBAAoB,GAAA,oBAAA,CAAqB,MAAO,CAAA,CAAC,KAAK,IACnE,KAAA;IACI,GAAA,CAAI,IAAI,CAAI,GAAA,IAAA,CAAA;IAEL,OAAA,GAAA,CAAA;AACX,CAAA,EAAG,CAAA,CAAoC","ignoreList":[0]}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"file":"getDefaultUniformValue.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts"],"sourcesContent":["/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n"],"names":[],"mappings":";;;;AAMgB,SAAA,sBAAA,CACZ,IAAA,EACA,IAEJ,EAAA;IACI,OAAQ,IACR;QACI,KAAK,KAAA;YACM,OAAA,CAAA,CAAA;QAEX,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QACpC,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBACxB,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEb,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC3B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACN,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEhB,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC9B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;IAAA,CACvB;IAEO,OAAA,IAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"file":"createIdFromString.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts"],"sourcesContent":["const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,QAAA,GAAA,aAAA,GAA0C,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAC3D,MAAM,MAAA,GAAA,aAAA,GAAwC,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAEzC,SAAA,kBAAA,CAAmB,KAAA,EAAe,OAClD,EAAA;IACQ,IAAA,EAAA,GAAK,MAAA,CAAO,KAAK,CAAA,CAAA;IAErB,IAAI,OAAO,KACX,CAAA,EAAA;QACQ,IAAA,QAAA,CAAS,OAAO,CAAA,KAAM,KAC1B,CAAA,EAAA;YACI,QAAA,CAAS,OAAO,CAAI,GAAA,CAAA,CAAA;QAAA,CACxB;QAEA,MAAA,CAAO,KAAK,CAAA,GAAI,EAAK,GAAA,QAAA,CAAS,OAAO,CAAA,EAAA,CAAA;IAAA,CACzC;IAEO,OAAA,EAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"file":"UniformGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts"],"sourcesContent":["import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAoFO,MAAM,aAAA,GAAN,MAAM,aACb,CAAA;IAAA;;;;GAAA,GAsDI,WAAA,CAAY,iBAAA,EAA6B,OACzC,CAAA;QA7CA,gFAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAGlB,iEAAA,GAAgB,IAAA,CAAA,GAAA,kKAAc,MAAA,EAAI,SAAS,CAAA,CAAA;QAE3C,kGAAA,GAAA,IAAA,CAAO,aAAgB,GAAA,cAAA,CAAA;QAEvB,6EAAA,GAAO,IAAA,CAAA,WAAA,kKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAenC,iDAAA,GAAA,IAAA,CAAgB,cAAiB,GAAA,IAAA,CAAA;QAMjC;;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QASlB,8DAAA;QAAA,IAAA,CAAgB,SAAY,GAAA,KAAA,CAAA;QASxB,OAAA,GAAU;YAAE,GAAG,aAAa,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEvD,IAAA,CAAK,iBAAoB,GAAA,iBAAA,CAAA;QAEzB,MAAM,WAAW,CAAA,CAAC,CAAA;QAElB,IAAA,MAAW,KAAK,iBAChB,CAAA;YACU,MAAA,WAAA,GAAc,iBAAA,CAAkB,CAAC,CAAA,CAAA;YAEvC,WAAA,CAAY,IAAO,GAAA,CAAA,CAAA;YACP,WAAA,CAAA,IAAA,GAAO,YAAY,IAAQ,IAAA,CAAA,CAAA;YAEvC,IAAI,2LAAC,oBAAA,CAAkB,WAAY,CAAA,IAAI,CACvC,EAAA;gBAEU,MAAA,IAAI,KAAM,CAAA,CAAA,aAAA,EAAgB,WAAY,CAAA,IAAI,CAAA,gDAAA,4LAAmD,uBAAqB,CAAA,IAAA,CAAK,IAAI,CAAC,CAAE,CAAA,CAAA,CAAA;YAAA,CACxI;YAEA,WAAA,CAAY,KAAA,IAAA,CAAZ,WAAY,CAAA,KAAA,2NAAU,yBAAA,EAAuB,WAAY,CAAA,IAAA,EAAM,YAAY,IAAI,CAAA,CAAA,CAAA;YAEtE,QAAA,CAAA,CAAC,CAAA,GAAI,WAAY,CAAA,KAAA,CAAA;QAAA,CAC9B;QAEA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;QAEhB,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA;QAChB,IAAA,CAAK,GAAA,GAAM,OAAQ,CAAA,GAAA,CAAA;QACnB,IAAA,CAAK,QAAA,GAAW,OAAQ,CAAA,QAAA,CAAA;QAExB,IAAA,CAAK,UAAa,IAAA,8NAAA,EAAmB,MAAO,CAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,GAAA,CACvD,CAAC,IAAM,CAAG,EAAA,CAAC,CAAA,CAAA,EAAK,iBAAkB,CAAA,CAAmC,CAAA,CAAkB,IAAI,CAAA,CAAA,EAC7F,IAAA,CAAK,GAAG,CAAA,EAAG,eAAe,CAAA,CAAA;IAAA,CAChC;IAAA,+GAAA,GAGO,MACP,GAAA;QACS,IAAA,CAAA,QAAA,EAAA,CAAA;IAAA,CAET;AACJ,CAAA,CAAA;AAAA,mDAAA,GAlGa,aAAA,CAGK,cAAsC,GAAA;IAAA,qEAAA,GAEhD,GAAK,EAAA,KAAA;IAAA,qGAAA,GAEL,QAAU,EAAA,KAAA;AACd,CAAA,CAAA;AARG,IAAM,YAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 416, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"file":"GlobalUniformSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @memberof rendering\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 562, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 568, "column": 0}, "map": {"version":3,"file":"sayHello.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/utils/sayHello.ts"],"sourcesContent":["import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n"],"names":[],"mappings":";;;;;;;;AAGA,IAAI,SAAY,GAAA,KAAA,CAAA;AAOT,SAAS,SAAS,IACzB,EAAA;IACI,IAAI,SACJ,EAAA;QACI,OAAA;IAAA,CACJ;IAEI,iKAAA,aAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAE,SAAU,CAAA,WAAA,EAAc,CAAA,OAAA,CAAQ,QAAQ,CAAA,GAAI,CAChF,CAAA,EAAA;QACI,MAAM,IAAO,GAAA;YACT,CAAA,8BAAA,uKAAiC,UAAO,CAAA,EAAA,EAAK,IAAI,CAAA;;AAAA,CAAA;YACjD,qCAAA;YACA,qCAAA;YACA,qCAAA;YACA,qCAAA;YACA,qDAAA;YACA,qDAAA;SACJ,CAAA;QAEW,UAAA,CAAA,OAAA,CAAQ,GAAI,CAAA,GAAG,IAAI,CAAA,CAAA;IAAA,CAClC,MAAA,IACS,WAAW,OACpB,EAAA;QACI,UAAA,CAAW,OAAA,CAAQ,GAAI,CAAA,CAAA,OAAA,uKAAU,UAAO,CAAA,GAAA,EAAM,IAAI,CAA2B,yBAAA,CAAA,CAAA,CAAA;IAAA,CACjF;IAEY,SAAA,GAAA,IAAA,CAAA;AAChB","ignoreList":[0]}},
    {"offset": {"line": 601, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 607, "column": 0}, "map": {"version":3,"file":"HelloSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @memberof rendering\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @memberof rendering.SharedRendererOptions\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @memberof rendering\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AA0BO,MAAM,WACb,CAAA;IAoBI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAAA;;;GAAA,GAMO,KAAK,OACZ,EAAA;QACI,IAAI,QAAQ,KACZ,EAAA;YACQ,IAAA,IAAA,GAAO,IAAA,CAAK,SAAU,CAAA,IAAA,CAAA;YAE1B,IAAI,IAAK,CAAA,SAAA,CAAU,IAAS,2KAAA,eAAA,CAAa,KACzC,EAAA;gBACI,IAAA,IAAQ,CAAK,CAAA,EAAA,IAAA,CAAK,SAA4B,CAAA,OAAA,CAAQ,YAAY,CAAA,CAAA,CAAA;YAAA,CACtE;aAEA,sKAAA,EAAS,IAAI,CAAA,CAAA;QAAA,CACjB;IAAA,CACJ;AACJ,CAAA;AAAA,YAAA,GA5Ca,WAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,YAAA;uKACd,gBAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,OAAA;IACN,QAAU,EAAA,CAAA,CAAA;AACd,CAAA,CAAA;AAAA,wCAAA,GAXS,WAAA,CAcK,cAAqC,GAAA;IAAA,+BAAA,GAE/C,KAAO,EAAA,KAAA;AACX,CAAA","ignoreList":[0]}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 654, "column": 0}, "map": {"version":3,"file":"getCanvasTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts"],"sourcesContent":["import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n"],"names":[],"mappings":";;;;;;;;;AAMA,MAAM,WAAA,GAAA,aAAA,GAAA,IAAuD,GAAI,EAAA,CAAA;AAEjD,SAAA,gBAAA,CAAiB,MAAA,EAAiB,OAClD,EAAA;IACI,IAAI,CAAC,WAAA,CAAY,GAAI,CAAA,MAAM,CAC3B,EAAA;QACU,MAAA,OAAA,GAAU,gMAAI,WAAQ,CAAA;YACxB,MAAA,EAAQ,iNAAI,eAAa,CAAA;gBACrB,QAAU,EAAA,MAAA;gBACV,GAAG,OAAA;YAAA,CACN,CAAA;QAAA,CACJ,CAAA,CAAA;QAED,MAAM,YAAY,MAClB;YACI,IAAI,WAAY,CAAA,GAAA,CAAI,MAAM,CAAA,KAAM,OAChC,EAAA;gBACI,WAAA,CAAY,MAAA,CAAO,MAAM,CAAA,CAAA;YAAA,CAC7B;QAAA,CACJ,CAAA;QAEQ,OAAA,CAAA,IAAA,CAAK,WAAW,SAAS,CAAA,CAAA;QACzB,OAAA,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,SAAS,CAAA,CAAA;QAE5B,WAAA,CAAA,GAAA,CAAI,QAAQ,OAAO,CAAA,CAAA;IAAA,CACnC;IAEO,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC,CAAA;AAEO,SAAS,uBAAuB,MACvC,EAAA;IACW,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC","ignoreList":[0]}},
    {"offset": {"line": 688, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"file":"RenderTarget.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 838, "column": 0}, "map": {"version":3,"file":"ViewSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @memberof rendering\n * @property {number} [width=800] - The width of the screen.\n * @property {number} [height=600] - The height of the screen.\n * @property {ICanvas} [canvas] - The canvas to use as a view, optional.\n * @property {boolean} [autoDensity=false] - Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n * @property {number} [resolution] - The resolution / device pixel ratio of the renderer.\n * @property {boolean} [antialias=false] - Whether to enable anti-aliasing. This may affect performance.\n * @property {boolean} [depth] -\n * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n * @property {boolean} [multiView] - TODO: multiView\n * @property {number} [backgroundAlpha] - The alpha of the background.\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     * @memberof rendering.SharedRendererOptions\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    height?: number;\n    /**\n     * The canvas to use as a view, optional.\n     * @memberof rendering.SharedRendererOptions\n     */\n    canvas?: ICanvas;\n    /** @deprecated */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     * @memberof rendering.SharedRendererOptions\n     */\n    autoDensity?: boolean;\n    /**\n     * The resolution / device pixel ratio of the renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    resolution?: number;\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @memberof rendering.SharedRendererOptions\n     */\n    antialias?: boolean;\n    /**\n     * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    depth?: boolean;\n\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @default 1\n     */\n    backgroundAlpha?: number;\n}\n\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * @member {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = options.backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 947, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"file":"executeInstructions.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts"],"sourcesContent":["import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n"],"names":[],"mappings":";;;;AAIgB,SAAA,mBAAA,CAAoB,WAAA,EAA0B,QAC9D,EAAA;IACI,MAAM,iBAAiB,WAAY,CAAA,cAAA,CAAA;IACnC,MAAM,eAAe,cAAe,CAAA,YAAA,CAAA;IAEpC,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,cAAA,CAAe,eAAA,EAAiB,CACpD,EAAA,CAAA;QACU,MAAA,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAA;QAEjC,QAAS,CAAA,WAAA,CAAY,YAAiC,CAAA,CAA2B,OAAA,CAAQ,WAAW,CAAA,CAAA;IAAA,CACzG;AACJ","ignoreList":[0]}},
    {"offset": {"line": 967, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 973, "column": 0}, "map": {"version":3,"file":"clearList.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/utils/clearList.ts"],"sourcesContent":["/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAOgB,SAAA,SAAA,CAAU,IAAA,EAAsB,KAChD,EAAA;IACc,KAAA,IAAA,CAAA,KAAA,GAAA,CAAA,CAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,KAAA,EAAO,CAAI,GAAA,IAAA,CAAK,MAAA,EAAQ,CACrC,EAAA,CAAA;QACQ,IAAA,IAAA,CAAK,CAAC,CACV,EAAA;YACI,IAAA,CAAK,CAAC,CAAI,GAAA,IAAA,CAAA;QAAA,CAGd,MAAA;YACI,MAAA;QAAA,CACJ;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 995, "column": 0}, "map": {"version":3,"file":"validateRenderables.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts"],"sourcesContent":["import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n"],"names":[],"mappings":";;;;AAIgB,SAAA,mBAAA,CAAoB,WAAA,EAA0B,WAC9D,EAAA;IACI,MAAM,EAAE,IAAA,EAAM,KAAM,EAAA,GAAI,WAAY,CAAA,2BAAA,CAAA;IAEpC,IAAI,eAAkB,GAAA,KAAA,CAAA;IAEtB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,EAAO,CAC3B,EAAA,CAAA;QACU,MAAA,SAAA,GAAY,IAAA,CAAK,CAAC,CAAA,CAAA;QAMxB,MAAM,UAAa,GAAA,SAAA,CAAA;QACb,MAAA,IAAA,GAAO,WAAY,CAAA,UAAA,CAAW,YAAiC,CAAA,CAAA;QAEnD,eAAA,GAAA,IAAA,CAAK,kBAAA,CAAmB,SAAS,CAAA,CAAA;QAEnD,IAAI,eACJ,EAAA;YACI,MAAA;QAAA,CACJ;IAAA,CACJ;IAEA,WAAA,CAAY,kBAAqB,GAAA,eAAA,CAAA;IAE1B,OAAA,eAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 1016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1022, "column": 0}, "map": {"version":3,"file":"updateRenderGroupTransforms.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts"],"sourcesContent":["import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1128, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"file":"buildInstructions.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/utils/buildInstructions.ts"],"sourcesContent":["import type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Renderer, RenderPipes } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @deprecated since 8.3.0\n */\nexport function buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\nexport function buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\nexport function buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n{\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n\n    instructionSet.reset();\n\n    // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n    const renderer = (rendererOrPipes as Renderer).renderPipes\n        ? (rendererOrPipes as Renderer)\n        : (rendererOrPipes as RenderPipes).batch.renderer;\n    const renderPipes = renderer.renderPipes;\n\n    // TODO add some events / runners for build start\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n\n    if (root.sortableChildren)\n    {\n        root.sortChildren();\n    }\n\n    collectAllRenderablesAdvanced(root, instructionSet, renderer, true);\n\n    // TODO add some events / runners for build end\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n}\n\n/**\n * @param container\n * @param instructionSet\n * @param renderer\n * @deprecated since 8.3.0\n */\nexport function collectAllRenderables(container: Container, instructionSet: InstructionSet, renderer: RenderPipes): void;\nexport function collectAllRenderables(container: Container, instructionSet: InstructionSet, renderer: Renderer): void;\nexport function collectAllRenderables(\n    container: Container, instructionSet: InstructionSet, rendererOrPipes: Renderer | RenderPipes\n): void\n{\n    // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n    const renderer = (rendererOrPipes as Renderer).renderPipes\n        ? (rendererOrPipes as Renderer)\n        : (rendererOrPipes as RenderPipes).batch.renderer;\n\n    // if there is 0b01 or 0b10 the return value\n    if (container.globalDisplayStatus < 0b111 || !container.includeInBuild) return;\n\n    if (container.sortableChildren)\n    {\n        container.sortChildren();\n    }\n\n    if (container.isSimple)\n    {\n        collectAllRenderablesSimple(container, instructionSet, renderer);\n    }\n    else\n    {\n        collectAllRenderablesAdvanced(container, instructionSet, renderer, false);\n    }\n}\n\nfunction collectAllRenderablesSimple(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderer: Renderer,\n): void\n{\n    if (container.renderPipeId)\n    {\n        const renderable = container as Renderable;\n        const { renderPipes, renderableGC } = renderer;\n\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(renderable, container.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[renderable.renderPipeId].addRenderable(renderable, instructionSet);\n\n        renderableGC.addRenderable(renderable, instructionSet);\n\n        renderable.didViewUpdate = false;\n    }\n\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            collectAllRenderables(children[i], instructionSet, renderer);\n        }\n    }\n}\n\nfunction collectAllRenderablesAdvanced(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderer: Renderer,\n    isRoot: boolean\n): void\n{\n    const { renderPipes, renderableGC } = renderer;\n\n    if (!isRoot && container.renderGroup)\n    {\n        renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n    }\n    else\n    {\n        for (let i = 0; i < container.effects.length; i++)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.push(effect, container, instructionSet);\n        }\n\n        const renderable = container as Renderable;\n        const renderPipeId = renderable.renderPipeId;\n\n        if (renderPipeId)\n        {\n            // TODO add blends in\n            renderPipes.blendMode.setBlendMode(renderable, renderable.groupBlendMode, instructionSet);\n\n            const pipe = renderPipes[renderPipeId as keyof RenderPipes]as RenderPipe<any>;\n\n            pipe.addRenderable(renderable, instructionSet);\n\n            renderableGC.addRenderable(renderable, instructionSet);\n\n            renderable.didViewUpdate = false;\n        }\n\n        const children = container.children;\n\n        if (children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                collectAllRenderables(children[i], instructionSet, renderer);\n            }\n        }\n\n        // loop backwards through effects\n        for (let i = container.effects.length - 1; i >= 0; i--)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.pop(effect, container, instructionSet);\n        }\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1225, "column": 0}, "map": {"version":3,"file":"RenderGroupSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { buildInstructions } from './utils/buildInstructions';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender();\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1369, "column": 0}, "map": {"version":3,"file":"TextureGCSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @memberof rendering\n * @property {boolean} [textureGCActive=true] - If set to true, this will enable the garbage collector on the GPU.\n * @property {number} [textureGCAMaxIdle=60 * 60] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [textureGCCheckCountMax=600] - Frames between two garbage collections.\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystem.textureGCMaxIdle}\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @memberof rendering\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystem.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n"],"names":[],"mappings":";;;;;;AA6CO,MAAM,gBAAA,GAAN,MAAM,gBACb,CAAA;IAAA,0DAAA,GAkEI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QAEjB,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;QACb,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA;IAAA,CACtB;IAEO,KAAK,OACZ,EAAA;QACI,OAAA,GAAU;YAAE,GAAG,gBAAgB,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAE1D,IAAA,CAAK,aAAA,GAAgB,OAAQ,CAAA,sBAAA,CAAA;QACxB,IAAA,CAAA,OAAA,GAAU,OAAQ,CAAA,iBAAA,IAAqB,OAAQ,CAAA,gBAAA,CAAA;QACpD,IAAA,CAAK,MAAA,GAAS,OAAQ,CAAA,eAAA,CAAA;IAAA,CAC1B;IAAA;;;GAAA,GAMU,UACV,GAAA;QACQ,IAAA,CAAC,IAAK,CAAA,SAAA,CAAU,iBACpB,EAAA;YACI,OAAA;QAAA,CACJ;QAEK,IAAA,CAAA,KAAA,EAAA,CAAA;QAEL,IAAI,CAAC,IAAK,CAAA,MAAA,EAAQ,OAAA;QAEb,IAAA,CAAA,UAAA,EAAA,CAAA;QAED,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAK,aAC3B,EAAA;YACI,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA;YAElB,IAAA,CAAK,GAAI,EAAA,CAAA;QAAA,CACb;IAAA,CACJ;IAAA;;;GAAA,GAMO,GACP,GAAA;QACU,MAAA,eAAA,GAAkB,IAAK,CAAA,SAAA,CAAU,OAAQ,CAAA,eAAA,CAAA;QAE/C,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,eAAA,CAAgB,MAAA,EAAQ,CAC5C,EAAA,CAAA;YACU,MAAA,OAAA,GAAU,eAAA,CAAgB,CAAC,CAAA,CAAA;YAGjC,IACI,OAAQ,CAAA,kBAAA,IACL,OAAQ,CAAA,QAAA,IACR,OAAQ,CAAA,QAAA,GAAW,CACnB,CAAA,IAAA,IAAA,CAAK,KAAQ,GAAA,OAAA,CAAQ,QAAW,GAAA,IAAA,CAAK,OAE5C,EAAA;gBACI,OAAA,CAAQ,QAAW,GAAA,CAAA,CAAA,CAAA;gBACnB,OAAA,CAAQ,MAAO,EAAA,CAAA;YAAA,CACnB;QAAA,CACJ;IAAA,CACJ;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA,CAAA;AAAA,YAAA,GA3Ia,gBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA,CAAA;AAAA,4CAAA,GATS,gBAAA,CAYK,cAAyC,GAAA;IAAA;;;GAAA,GAKnD,eAAiB,EAAA,IAAA;IAAA;;;GAAA,GAKjB,iBAAmB,EAAA,IAAA;IAAA;;;GAAA,GAKnB,kBAAkB,EAAK,GAAA,EAAA;IAAA;;;GAAA,GAKvB,sBAAwB,EAAA,GAAA;AAC5B,CAAA,CAAA;AAjCG,IAAM,eAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 1450, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1456, "column": 0}, "map": {"version":3,"file":"RenderTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts"],"sourcesContent":["import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link rendering.Texture}\n * @memberof rendering\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAUO,MAAM,mNAAsB,UACnC,CAAA;IACI,OAAc,OAAO,OACrB,EAAA;QACI,OAAO,IAAI,aAAc,CAAA;YACrB,MAAA,EAAQ,kNAAI,gBAAA,CAAc,OAAO,CAAA;QAAA,CACpC,CAAA,CAAA;IAAA,CACL;IAAA;;;;;;GAAA,GASO,MAAA,CAAO,KAAe,EAAA,MAAA,EAAgB,UAC7C,EAAA;QACI,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KAAO,EAAA,MAAA,EAAQ,UAAU,CAAA,CAAA;QAErC,OAAA,IAAA,CAAA;IAAA,CACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1483, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1489, "column": 0}, "map": {"version":3,"file":"GenerateTextureSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts"],"sourcesContent":["import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAsCA,MAAM,QAAA,GAAW,uKAAI,YAAU,EAAA,CAAA;AAC/B,MAAM,UAAA,GAAa,iLAAI,SAAO,EAAA,CAAA;AAC9B,MAAM,OAAuB,GAAA;IAAC,CAAG;IAAA,CAAA;IAAG;IAAG,CAAC;CAAA,CAAA;AASjC,MAAM,qBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAAA;;;;;;;;;;GAAA,GAaO,gBAAgB,OACvB,EAAA;QACI,IAAI,yLAAmB,YACvB,EAAA;YACc,OAAA,GAAA;gBACN,MAAQ,EAAA,OAAA;gBACR,KAAO,EAAA,KAAA,CAAA;gBACP,sBAAsB,CAAA,CAAC;gBACvB,UAAY,EAAA,KAAA,CAAA;YAAA,CAChB,CAAA;QAAA,CACJ;QAEA,MAAM,UAAa,GAAA,OAAA,CAAQ,UAAc,IAAA,IAAA,CAAK,SAAU,CAAA,UAAA,CAAA;QACxD,MAAM,SAAY,GAAA,OAAA,CAAQ,SAAa,IAAA,IAAA,CAAK,SAAA,CAAU,IAAK,CAAA,SAAA,CAAA;QAE3D,MAAM,YAAY,OAAQ,CAAA,MAAA,CAAA;QAE1B,IAAI,aAAa,OAAQ,CAAA,UAAA,CAAA;QAEzB,IAAI,UACJ,EAAA;YACI,MAAM,cAAc,KAAM,CAAA,OAAA,CAAQ,UAAU,CAAA,IAAK,WAAW,MAAW,KAAA,CAAA,CAAA;YAEvE,UAAA,GAAa,cAAc,UAAa,uJAAA,SAAA,CAAM,MAAA,CAAO,QAAS,CAAA,UAAU,EAAE,OAAQ,EAAA,CAAA;QAAA,CAGtF,MAAA;YACiB,UAAA,GAAA,OAAA,CAAA;QAAA,CACjB;QAEM,MAAA,MAAA,GAAS,QAAQ,KAAO,EAAA,MAAA,CAAO,QAAQ,CACtC,6LAAA,iBAAA,EAAe,SAAW,EAAA,UAAU,CAAE,CAAA,SAAA,CAAA;QAE7C,MAAA,CAAO,KAAA,GAAQ,IAAK,CAAA,GAAA,CAAI,OAAO,KAAO,EAAA,CAAA,GAAI,UAAU,CAAI,GAAA,CAAA,CAAA;QACxD,MAAA,CAAO,MAAA,GAAS,IAAK,CAAA,GAAA,CAAI,OAAO,MAAQ,EAAA,CAAA,GAAI,UAAU,CAAI,GAAA,CAAA,CAAA;QAEpD,MAAA,MAAA,sMAAS,gBAAA,CAAc,MAAO,CAAA;YAChC,GAAG,OAAQ,CAAA,oBAAA;YACX,OAAO,MAAO,CAAA,KAAA;YACd,QAAQ,MAAO,CAAA,MAAA;YACf,UAAA;YACA,SAAA;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,mKAAY,SAAA,CAAO,MAAO,CAAA,SAAA,CAAU,CAAC,MAAO,CAAA,CAAA,EAAG,CAAC,MAAA,CAAO,CAAC,CAAA,CAAA;QAE9D,IAAA,CAAK,SAAA,CAAU,MAAO,CAAA;YAClB,SAAA;YACA,SAAA;YACA,MAAA;YACA,UAAA;QAAA,CACH,CAAA,CAAA;QAED,MAAA,CAAO,MAAA,CAAO,aAAc,EAAA,CAAA;QAErB,OAAA,MAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ,CAAA;AAAA,YAAA,GA3Fa,qBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,kBAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1583, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1589, "column": 0}, "map": {"version":3,"file":"ExtractSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * @memberof rendering\n */\nexport interface ImageOptions\n{\n    /** The format of the image. */\n    format?: Formats;\n    /** The quality of the image. */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport interface BaseExtractOptions\n{\n    /** The target to extract. */\n    target: Container | Texture;\n    /** The region of the target to extract. */\n    frame?: Rectangle;\n    /** The resolution of the extracted content. */\n    resolution?: number;\n    /** The color used to clear the extracted content. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * @memberof rendering\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * @memberof rendering\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /** The filename to use when downloading the content. */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .circle(0, 0, 50);\n *     .fill(0xFF0000)\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof rendering\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /** Default options for creating an image. */\n    public static defaultImageOptions: ImageOptions = {\n        /** The format of the image. */\n        format: 'png' as Formats,\n        /** The quality of the image. */\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param options - The options for creating the image, or the target to extract\n     * @returns - HTML Image of the target\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     * `Extract.canvas` and then running toDataURL on that.\n     * @param options - The options for creating the image, or the target to extract\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Will return a texture of the target\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns - A texture of the target\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Will extract a HTMLImage of the target and download it\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * @param options - The options for logging the image, or the target to log\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1763, "column": 0}, "map": {"version":3,"file":"clean.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/utils/data/clean.ts"],"sourcesContent":["/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @memberof utils\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @memberof utils\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n"],"names":["cleanHash"],"mappings":";;;;;AASO,SAAS,UAAa,IAC7B,EAAA;IACI,IAAI,KAAQ,GAAA,KAAA,CAAA;IAEZ,IAAA,MAAW,KAAK,IAChB,CAAA;QAEQ,IAAA,IAAA,CAAK,CAAC,CAAA,IAAK,KACf,CAAA,EAAA;YACY,KAAA,GAAA,IAAA,CAAA;YACR,MAAA;QAAA,CACJ;IAAA,CACJ;IAEA,IAAI,CAAC,KAAA,EAAc,OAAA,IAAA,CAAA;IAEbA,MAAAA,UAAAA,GAAAA,aAAAA,GAAmB,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;IAEpC,IAAA,MAAW,KAAK,IAChB,CAAA;QACU,MAAA,KAAA,GAAQ,IAAA,CAAK,CAAC,CAAA,CAAA;QAEpB,IAAI,KACJ,EAAA;YACIA,UAAAA,CAAU,CAAC,CAAI,GAAA,KAAA,CAAA;QAAA,CACnB;IAAA,CACJ;IAEOA,OAAAA,UAAAA,CAAAA;AACX,CAAA;AAiBO,SAAS,WAAc,GAC9B,EAAA;IACI,IAAI,MAAS,GAAA,CAAA,CAAA;IAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,GAAA,CAAI,MAAA,EAAQ,CAChC,EAAA,CAAA;QAEQ,IAAA,GAAA,CAAI,CAAC,CAAA,IAAK,KACd,CAAA,EAAA;YACI,MAAA,EAAA,CAAA;QAAA,CAGJ,MAAA;YACI,GAAA,CAAI,CAAI,GAAA,MAAM,CAAI,GAAA,GAAA,CAAI,CAAC,CAAA,CAAA;QAAA,CAC3B;IAAA,CACJ;IAEA,GAAA,CAAI,MAAU,IAAA,MAAA,CAAA;IAEP,OAAA,GAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 1800, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"file":"RenderableGCSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @memberof rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCFrequency: number;\n}\n/**\n * System plugin to the renderer to manage renderable garbage collection. When rendering\n * stuff with the renderer will assign resources to each renderable. This could be for example\n * a batchable Sprite, or a text texture. If the renderable is not used for a certain amount of time\n * its resources will be tided up by its render pipe.\n * @memberof rendering\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /** default options for the renderableGCSystem */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        renderableGCActive: true,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        renderableGCMaxUnusedTime: 60000,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        renderableGCFrequency: 30000,\n    };\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see renderableGCSystem.defaultMaxIdle\n     */\n    public maxUnusedTime: number;\n\n    private _renderer: Renderer;\n\n    private readonly _managedRenderables: Renderable[] = [];\n    private _handler: number;\n    private _frequency: number;\n    private _now: number;\n\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    private _hashHandler: number;\n\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    private _arrayHandler: number;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    public prerender(): void\n    {\n        this._now = performance.now();\n    }\n\n    public addRenderable(renderable: Renderable, instructionSet: InstructionSet): void\n    {\n        if (!this.enabled) return;\n\n        renderable._lastUsed = this._now;\n\n        if (renderable._lastInstructionTick === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastInstructionTick = instructionSet.tick;\n    }\n\n    /** Runs the scheduled garbage collection */\n    public run(): void\n    {\n        const now = performance.now();\n\n        const managedRenderables = this._managedRenderables;\n\n        const renderPipes = this._renderer.renderPipes;\n\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentIndex = renderGroup?.instructionSet?.tick ?? -1;\n\n            if (renderable._lastInstructionTick !== currentIndex && now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                // remove from the array as this has been destroyed..\n                renderable._lastInstructionTick = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1950, "column": 0}, "map": {"version":3,"file":"SchedulerSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @memberof rendering\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,GAAM,GAAA,CAAA,CAAA;AAMH,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAaH,IAAA,CAAiB,MAAA,GAQX,EAAC,CAAA;QAGP,qHAAA,GAAA,IAAA,CAAQ,OAAU,GAAA,CAAA,CAAA;IAAA,CAAA;IAAA,4DAAA,GAGX,IACP,GAAA;+JACI,SAAA,CAAO,MAAO,CAAA,GAAA,CAAI,IAAK,CAAA,OAAA,EAAS,IAAI,CAAA,CAAA;IAAA,CACxC;IAAA;;;;;;GAAA,GASO,MAAO,CAAA,IAAA,EAAiC,QAAkB,EAAA,SAAA,GAAY,IAC7E,EAAA;QACI,MAAM,EAAK,GAAA,GAAA,EAAA,CAAA;QAEX,IAAI,MAAS,GAAA,CAAA,CAAA;QAEb,IAAI,SACJ,EAAA;YACI,IAAA,CAAK,OAAW,IAAA,GAAA,CAAA;YAChB,MAAA,GAAS,IAAK,CAAA,OAAA,CAAA;QAAA,CAClB;QAEA,IAAA,CAAK,MAAA,CAAO,IAAK,CAAA;YACb,IAAA;YACA,QAAA;YACA,KAAA,EAAO,YAAY,GAAI,EAAA;YACvB,MAAA;YACA,IAAA,EAAM,YAAY,GAAI,EAAA;YACtB,MAAQ,EAAA,IAAA;YACR,EAAA;QAAA,CACH,CAAA,CAAA;QAEM,OAAA,EAAA,CAAA;IAAA,CACX;IAAA;;;GAAA,GAMO,OAAO,EACd,EAAA;QACI,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,MAAA,EAAQ,CACxC,EAAA,CAAA;YACI,IAAI,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAE,EAAA,KAAO,EAC1B,EAAA;gBACS,IAAA,CAAA,MAAA,CAAO,MAAO,CAAA,CAAA,EAAG,CAAC,CAAA,CAAA;gBAEvB,OAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAAA;;;GAAA,GAMQ,OACR,GAAA;QACU,MAAA,GAAA,GAAM,YAAY,GAAI,EAAA,CAAA;QAE5B,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,MAAA,EAAQ,CACxC,EAAA,CAAA;YACU,MAAA,IAAA,GAAO,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;YAE1B,IAAK,MAAM,IAAK,CAAA,MAAA,GAAU,IAAK,CAAA,IAAA,IAAQ,KAAK,QAC5C,EAAA;gBACU,MAAA,OAAA,GAAU,MAAM,IAAK,CAAA,KAAA,CAAA;gBAE3B,IAAA,CAAK,IAAA,CAAK,OAAO,CAAA,CAAA;gBACjB,IAAA,CAAK,IAAO,GAAA,GAAA,CAAA;YAAA,CAChB;QAAA,CACJ;IAAA,CACJ;IAAA;;;;GAAA,GAOO,OACP,GAAA;QACI,gKAAA,CAAO,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,EAAS,IAAI,CAAA,CAAA;QAEvC,IAAA,CAAK,MAAA,CAAO,MAAS,GAAA,CAAA,CAAA;IAAA,CACzB;AACJ,CAAA;AAAA,YAAA,GAlHa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,YAAA;uKACd,gBAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,WAAA;IACN,QAAU,EAAA,CAAA;AACd,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2036, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"file":"BlendModePipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        let filterEffect = this._filterHash[blendMode];\n\n        // this does need an execute?\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect,\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2166, "column": 0}, "map": {"version":3,"file":"State.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts"],"sourcesContent":["import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2322, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts"],"sourcesContent":["/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n"],"names":["BufferUsage"],"mappings":";;;;AAKY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAMHA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,YAAA,GAAY,CAAZ,CAAA,GAAA,WAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAMAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,QAAA,GAAQ,EAAR,CAAA,GAAA,OAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,EAAT,CAAA,GAAA,QAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,EAAV,CAAA,GAAA,SAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,GAAV,CAAA,GAAA,SAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,GAAX,CAAA,GAAA,UAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,gBAAA,GAAgB,GAAhB,CAAA,GAAA,eAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,IAAT,CAAA,GAAA,QAAA,CAAA;IAhDQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2348, "column": 0}, "map": {"version":3,"file":"Buffer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;AA0EO,MAAM,qMAAe,UAK5B,CAAA;IAAA;;;GAAA,GAqFI,YAAY,OACZ,CAAA;QACQ,IAAA,EAAE,IAAM,EAAA,IAAA,EAAS,GAAA,OAAA,CAAA;QACrB,MAAM,EAAE,KAAA,EAAO,KAAO,EAAA,WAAA,EAAgB,GAAA,OAAA,CAAA;QAEhC,KAAA,EAAA,CAAA;QAvEV;;;;KAAA,GAAA;;;;KAAA,GAAA;;;KAAA,GAAA,iEAAA,GAAgB,IAAA,CAAA,GAAA,IAAc,oKAAA,EAAI,QAAQ,CAAA,CAAA;QAO1C;;;;KAAA,GAAA,IAAA,CAAgB,aAAgB,GAAA,QAAA,CAAA;QAOhC;;;;KAAA,GAAO,IAAA,CAAA,WAAA,GAAc,qKAAA,EAAI,UAAU,CAAA,CAAA;QAOnC;;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAalB;;;KAAA,GAAA,IAAA,CAAO,SAAY,GAAA,CAAA,CAAA;QAUnB,IAAA,CAAQ,UAAyB,GAAA,IAAA,CAAA;QAUjC;;;;;;;KAAA,GAAA,IAAA,CAAO,WAAc,GAAA,IAAA,CAAA;QAMrB;;;KAAA,GAAA,IAAA,CAAO,SAAY,GAAA,KAAA,CAAA;QAaf,IAAI,gBAAgB,KACpB,EAAA;YACW,IAAA,GAAA,IAAI,aAAa,IAAgB,CAAA,CAAA;QAAA,CAC5C;QAEA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;QAEb,IAAA,IAAA,CAAA,IAAA,GAAU,IAAqB,EAAA,UAAA,CAAA,CAAA;QAEzB,MAAA,gBAAA,GAAmB,CAAC,CAAC,IAAA,CAAA;QAE3B,IAAA,CAAK,UAAa,GAAA;YACd,IAAA;YACA,KAAA;YACA,gBAAA;YACA,KAAA;QAAA,CACJ,CAAA;QAEA,IAAA,CAAK,WAAA,GAAc,WAAe,IAAA,IAAA,CAAA;IAAA,CACtC;IAAA,2BAAA,GAGA,IAAI,IACJ,GAAA;QACI,OAAO,IAAK,CAAA,KAAA,CAAA;IAAA,CAChB;IAEA,IAAI,KAAK,KACT,EAAA;QACI,IAAA,CAAK,eAAgB,CAAA,KAAA,EAAO,KAAM,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;IAAA,CAClD;IAEA,IAAI,SACJ,GAAA;QACQ,IAAA,CAAC,IAAA,CAAK,UACV,EAAA;YACI,IAAA,CAAK,UAAa,GAAA,IAAI,UAAY,CAAA,IAAA,CAAK,IAAA,CAAa,MAAM,CAAA,CAAA;QAAA,CAC9D;QAEA,OAAO,IAAK,CAAA,UAAA,CAAA;IAAA,CAChB;IAAA,wCAAA,GAGA,IAAI,MACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,UAAA,CAAW,KAAA,6LAAQ,cAAY,CAAA,MAAA,CAAA,CAAA;IAAA,CAClD;IAEA,IAAI,OAAO,KACX,EAAA;QACI,IAAI,KACJ,EAAA;YACS,IAAA,CAAA,UAAA,CAAW,KAAA,8LAAS,cAAY,CAAA,MAAA,CAAA;QAAA,CAGzC,MAAA;YACS,IAAA,CAAA,UAAA,CAAW,KAAS,IAAA,CAAC,wMAAY,CAAA,MAAA,CAAA;QAAA,CAC1C;IAAA,CACJ;IAAA;;;;;;GAAA,GASO,eAAA,CAAgB,KAAmB,EAAA,IAAA,EAAc,OACxD,EAAA;QAES,IAAA,CAAA,SAAA,EAAA,CAAA;QAEA,IAAA,CAAA,WAAA,GAAe,OAAO,KAAM,CAAA,iBAAA,CAAA;QAG7B,IAAA,IAAA,CAAK,KAAA,KAAU,KACnB,EAAA;YACQ,IAAA,OAAA,EAAc,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;YAErC,OAAA;QAAA,CACJ;QAGA,MAAM,UAAU,IAAK,CAAA,KAAA,CAAA;QAErB,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;QACb,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAGlB,IAAI,CAAC,OAAA,IAAW,OAAQ,CAAA,MAAA,KAAW,MAAM,MACzC,EAAA;YACI,IAAI,CAAC,IAAK,CAAA,WAAA,IAAe,WAAW,KAAM,CAAA,UAAA,GAAa,QAAQ,UAC/D,EAAA;gBACQ,IAAA,OAAA,EAAc,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;YAAA,CAGzC,MAAA;gBACS,IAAA,CAAA,UAAA,CAAW,IAAA,GAAO,KAAM,CAAA,UAAA,CAAA;gBACxB,IAAA,CAAA,WAAA,GAAc,qKAAA,EAAI,UAAU,CAAA,CAAA;gBAC5B,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;YAAA,CAC5B;YAEA,OAAA;QAAA,CACJ;QAEI,IAAA,OAAA,EAAc,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;IAAA,CACzC;IAAA;;;;;GAAA,GAQO,OAAO,WACd,EAAA;QACS,IAAA,CAAA,WAAA,GAAc,eAAe,IAAK,CAAA,WAAA,CAAA;QAElC,IAAA,CAAA,SAAA,EAAA,CAAA;QAEA,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;IAAA,CAC5B;IAAA,wBAAA,GAGO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QAEZ,IAAA,CAAA,IAAA,CAAK,WAAW,IAAI,CAAA,CAAA;QACpB,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;QAExB,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;QACZ,IAAA,CAAK,UAAsB,GAAA,IAAA,CAAA;QAE5B,IAAA,CAAK,kBAAmB,EAAA,CAAA;IAAA,CAC5B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2502, "column": 0}, "map": {"version":3,"file":"ensureIsBuffer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts"],"sourcesContent":["import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n"],"names":[],"mappings":";;;;;;;;AAcgB,SAAA,cAAA,CAAe,MAAA,EAAwC,KACvE,EAAA;IACQ,IAAA,CAAA,CAAE,6MAAkB,SACxB,CAAA,EAAA;QACI,IAAI,KAAgB,GAAA,KAAA,6LAAQ,cAAY,CAAA,KAAA,6LAAQ,cAAY,CAAA,MAAA,CAAA;QAG5D,IAAI,kBAAkB,KACtB,EAAA;YACI,IAAI,KACJ,EAAA;gBACa,MAAA,GAAA,IAAI,YAAY,MAAM,CAAA,CAAA;gBACvB,KAAA,6LAAA,cAAA,CAAY,KAAA,6LAAQ,cAAY,CAAA,QAAA,CAAA;YAAA,CAI5C,MAAA;gBACa,MAAA,GAAA,IAAI,aAAa,MAAM,CAAA,CAAA;gBACxB,KAAA,6LAAA,cAAA,CAAY,MAAA,6LAAS,cAAY,CAAA,QAAA,CAAA;YAAA,CAC7C;QAAA,CACJ;QAEA,MAAA,GAAS,+LAAI,SAAO,CAAA;YAChB,IAAM,EAAA,MAAA;YACN,KAAA,EAAO,QAAQ,mBAAsB,GAAA,oBAAA;YACrC,KAAA;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"file":"getGeometryBounds.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts"],"sourcesContent":["import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n"],"names":[],"mappings":";;;;AAUgB,SAAA,iBAAA,CAAkB,QAAoB,EAAA,WAAA,EAAqB,MAC3E,EAAA;IACU,MAAA,SAAA,GAAY,QAAS,CAAA,YAAA,CAAa,WAAW,CAAA,CAAA;IAEnD,IAAI,CAAC,SACL,EAAA;QACI,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QAEP,OAAA,MAAA,CAAA;IAAA,CACX;IAEM,MAAA,IAAA,GAAO,UAAU,MAAO,CAAA,IAAA,CAAA;IAE9B,IAAI,IAAO,GAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,CAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,CAAA,QAAA,CAAA;IAEX,MAAM,WAAW,IAAK,CAAA,iBAAA,CAAA;IAGhB,MAAA,MAAA,GAAA,CAAU,SAAU,CAAA,MAAA,IAAU,CAAK,IAAA,QAAA,CAAA;IACzC,MAAM,MAAU,GAAA,CAAA,SAAA,CAAU,MAAW,IAAA,CAAA,GAAI,CAAM,IAAA,QAAA,CAAA;IAE/C,IAAA,IAAS,IAAI,MAAQ,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,EAAQ,KAAK,MAC3C,CAAA;QACU,MAAA,CAAA,GAAI,IAAA,CAAK,CAAC,CAAA,CAAA;QACV,MAAA,CAAA,GAAI,IAAK,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;QAEpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;IAAA,CACxB;IAEA,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IAEP,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2575, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2581, "column": 0}, "map": {"version":3,"file":"Geometry.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2715, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2721, "column": 0}, "map": {"version":3,"file":"BatchGeometry.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts"],"sourcesContent":["import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,qBAAA,GAAwB,IAAI,YAAA,CAAa,CAAC,CAAA,CAAA;AAChD,MAAM,oBAAA,GAAuB,IAAI,WAAA,CAAY,CAAC,CAAA,CAAA;AAEvC,MAAM,qNAAsB,WACnC,CAAA;IACI,WACA,EAAA;QACI,MAAM,UAAa,GAAA,CAAA,CAAA;QAEb,MAAA,eAAA,GAAkB,+LAAI,SAAO,CAAA;YAC/B,IAAM,EAAA,qBAAA;YACN,KAAO,EAAA,wBAAA;YACP,KAAA,4LAAO,cAAY,CAAA,MAAA,6LAAS,cAAY,CAAA,QAAA;YACxC,WAAa,EAAA,KAAA;QAAA,CAChB,CAAA,CAAA;QAEK,MAAA,WAAA,GAAc,+LAAI,SAAO,CAAA;YAC3B,IAAM,EAAA,oBAAA;YACN,KAAO,EAAA,oBAAA;YACP,KAAA,4LAAO,cAAY,CAAA,KAAA,6LAAQ,cAAY,CAAA,QAAA;YAAA,wBAAA;YACvC,WAAa,EAAA,KAAA;QAAA,CAChB,CAAA,CAAA;QAED,MAAM,SAAS,UAAa,GAAA,CAAA,CAAA;QAEtB,KAAA,CAAA;YACF,UAAY,EAAA;gBACR,SAAW,EAAA;oBACP,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,WAAA;oBACR,MAAA;oBACA,MAAQ,EAAA,CAAA;gBAAA,CACZ;gBACA,GAAK,EAAA;oBACD,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,WAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;gBACA,MAAQ,EAAA;oBACJ,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,UAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;gBACA,kBAAoB,EAAA;oBAChB,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,UAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;YAAA,CACJ;YACA,WAAA;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2789, "column": 0}, "map": {"version":3,"file":"compileInputs.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts"],"sourcesContent":["function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAA,CAAc,cAAA,EAAwB,GAC/C,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,iBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAEO,SAAS,aAAc,CAAA,SAAA,EAAkB,QAAkB,EAAA,IAAA,GAAO,KACzE,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,aAAA,CAAc,UAAU,OAAO,CAAA,CAAA;IAErB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACkB,aAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC1C;IAAA,CACH,CAAA,CAAA;IAGD,MAAM,SAAY,GAAA,OAAA,CAAA;IAElB,IAAI,IACJ,EAAA;QACI,SAAA,CAAU,IAAK,EAAA,CAAA;IAAA,CACnB;IAEA,MAAM,WAAc,GAAA,SAAA,CACf,GAAI,CAAA,CAAC,OAAS,EAAA,CAAA,GAAM,CAAoB,iBAAA,EAAA,CAAC,CAAK,EAAA,EAAA,OAAO,CAAG,CAAA,CAAA,CAAA,CACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,IAAI,aAAgB,GAAA,QAAA,CAAS,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAAA,CAAA;IAE3C,aAAA,GAAA,aAAA,CAAc,OAAA,CAAQ,QAAU,EAAA,CAAA;AAAA,EAAK,WAAW,CAAA;AAAA,CAAI,CAAA,CAAA;IAE7D,OAAA,aAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2827, "column": 0}, "map": {"version":3,"file":"compileOutputs.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts"],"sourcesContent":["function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,cAAA,CAAe,cAAA,EAAwB,GAChD,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,kBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAEA,SAAS,oBAAoB,KAC7B,EAAA;IACI,MAAM,KAAQ,GAAA,cAAA,CAAA;IAER,MAAA,KAAA,GAAQ,KAAM,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAEvB,OAAA,KAAA,GAAQ,KAAM,CAAA,CAAC,CAAI,GAAA,EAAA,CAAA;AAC9B,CAAA;AAEA,SAAS,cAAc,KACvB,EAAA;IACI,MAAM,KAAQ,GAAA,UAAA,CAAA;IAEP,OAAA,KAAA,CAAM,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAA,CAAA;AAClC,CAAA;AAEgB,SAAA,cAAA,CAAe,SAAA,EAAkB,QACjD,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,cAAA,CAAe,UAAU,OAAO,CAAA,CAAA;IAEtB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACmB,cAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC3C;IAAA,CACH,CAAA,CAAA;IAED,IAAI,KAAQ,GAAA,CAAA,CAAA;IAGZ,MAAM,aAAa,OACd,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OACN,KAAA;QACI,IAAI,OAAQ,CAAA,OAAA,CAAQ,SAAS,CAAA,GAAI,CACjC,CAAA,EAAA;YACW,OAAA,OAAA,CAAA;QAAA,CACX;QAEO,OAAA,CAAA,UAAA,EAAa,KAAO,EAAA,CAAA,EAAA,EAAK,OAAO,CAAA,CAAA,CAAA;IAAA,CAC1C,CACA,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAGf,MAAM,SAAY,GAAA,OAAA,CACb,IAAK,EAAA,CACL,GAAA,CAAI,CAAC,OAAA,GAAY,CAAc,WAAA,EAAA,aAAA,CAAc,OAAO,CAAC,CAAG,CAAA,CAAA,CAAA,CACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,MAAM,OAAU,GAAA,CAAA;YAAA,EACN,OACG,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OAAY,GAAA,CAAA,CAAA,EAAI,mBAAoB,CAAA,OAAO,CAAC,CAAA,CAAE,CACnD,CAAA,IAAA,CAAK,KAAK,CAAC,CAAA,EAAA,CAAA,CAAA;IAGxB,IAAI,YAAe,GAAA,QAAA,CAAS,OAAQ,CAAA,mBAAA,EAAqB,EAAE,CAAA,CAAA;IAE5C,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,CAAA;AAAA,EAAK,UAAU,CAAA;AAAA,CAAI,CAAA,CAAA;IACtD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,WAAa,EAAA,CAAA;AAAA,EAAK,SAAS,CAAA;AAAA,CAAI,CAAA,CAAA;IACpD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,CAAA;AAAA,EAAK,OAAO,CAAA;AAAA,CAAI,CAAA,CAAA;IAE3D,OAAA,YAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2879, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2885, "column": 0}, "map": {"version":3,"file":"compileHooks.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts"],"sourcesContent":["export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n"],"names":[],"mappings":";;;;;AAAO,MAAM,WAAc,GAAA,iBAAA;AAMpB,SAAS,aAAa,UAC7B,EAAA;IACI,MAAM,QAAkC,CAAA,CAAC,CAAA;IAEzC,MAAM,WAAc,GAAA,UAAA,CACf,KAAM,CAAA,WAAW,GAChB,GAAI,CAAA,CAAC,IAAS,GAAA,IAAA,CAAK,OAAQ,CAAA,SAAA,EAAW,EAAE,CAAC,KAAK,EAAC,CAAA;IAEzC,WAAA,CAAA,OAAA,CAAQ,CAAC,IACrB,KAAA;QACU,KAAA,CAAA,IAAI,CAAA,GAAI,EAAC,CAAA;IAAA,CAClB,CAAA,CAAA;IAEM,OAAA,KAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2901, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2907, "column": 0}, "map": {"version":3,"file":"addBits.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;AAQgB,SAAA,OAAA,CAAQ,QAAkC,EAAA,KAAA,EAAiC,IAC3F,EAAA;IACI,IAAI,QACJ,EAAA;QACI,IAAA,MAAW,KAAK,QAChB,CAAA;YACU,MAAA,EAAA,GAAK,EAAE,iBAAkB,EAAA,CAAA;YAEzB,MAAA,IAAA,GAAO,KAAA,CAAM,EAAE,CAAA,CAAA;YAErB,IAAI,IACJ,EAAA;gBACQ,IAAA,aAAA,GAAgB,QAAA,CAAS,CAAC,CAAA,CAAA;gBAE9B,IAAI,MAAM,QACV,EAAA;oBACI,aAAA,GAAgB,cACX,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAC9B,CAAA,OAAA,CAAQ,qBAAqB,EAAE,CAAA,CAAA;gBAAA,CACxC;gBAEA,IAAI,IACJ,EAAA;oBACS,IAAA,CAAA,IAAA,CAAK,CAAS,MAAA,EAAA,IAAI,CAAQ,MAAA,CAAA,CAAA,CAAA;gBAAA,CACnC;gBACA,IAAA,CAAK,IAAA,CAAK,aAAa,CAAA,CAAA;YAAA,CAI3B,MAAA;mLAES,OAAA,EAAA,CAAA,EAAG,CAAC,CAA0C,wCAAA,CAAA,CAAA,CAAA;YAAA,CAEvD;QAAA,CACJ;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2935, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2941, "column": 0}, "map": {"version":3,"file":"injectBits.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts"],"sourcesContent":["/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n"],"names":[],"mappings":";;;;AAKgB,SAAA,UAAA,CAAW,WAAA,EAAqB,aAChD,EAAA;IACI,IAAI,GAAM,GAAA,WAAA,CAAA;IAEV,IAAA,MAAW,KAAK,aAChB,CAAA;QACU,MAAA,KAAA,GAAQ,aAAA,CAAc,CAAC,CAAA,CAAA;QAEvB,MAAA,QAAA,GAAW,KAAM,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;QAEhC,IAAI,SAAS,MACb,EAAA;YACI,GAAA,GAAM,IAAI,OAAQ,CAAA,CAAA,EAAA,EAAK,CAAC,CAAA,EAAA,CAAA,EAAM,CAAA,OAAA,EAAU,CAAC,CAAA;AAAA,EAAkB,KAAA,CAAM,IAAK,CAAA,IAAI,CAAC,CAAA;MAAA,EAAW,CAAC,CAAe,aAAA,CAAA,CAAA,CAAA;QAAA,CAI1G,MAAA;YACI,GAAA,GAAM,GAAI,CAAA,OAAA,CAAQ,CAAK,EAAA,EAAA,CAAC,CAAA,EAAA,CAAA,EAAM,EAAE,CAAA,CAAA;QAAA,CACpC;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2962, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2968, "column": 0}, "map": {"version":3,"file":"compileHighShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts"],"sourcesContent":["import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3032, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3038, "column": 0}, "map": {"version":3,"file":"defaultProgramTemplate.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts"],"sourcesContent":["const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n"],"names":[],"mappings":";;;;;;;AAAM,MAAA,iBAAA,GAAA,QAAA,GAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AA8C9B,MAAA,mBAAA,GAAA,QAAA,GAAgC,CAAA;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AAyBhC,MAAA,gBAAA,GAAA,QAAA,GAA6B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AAsC7B,MAAA,kBAAA,GAAA,QAAA,GAA+B,CAAA;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3175, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3181, "column": 0}, "map": {"version":3,"file":"globalUniformsBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts"],"sourcesContent":["export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;IAAA,CAUtB;AACJ,EAAA;AAEO,MAAM,sBAAyB,GAAA;IAClC,IAAM,EAAA,yBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;QAAA,CAAA;IAAA,CAQtB;AACJ,EAAA;AAEO,MAAM,mBAAsB,GAAA;IAC/B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 3228, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3234, "column": 0}, "map": {"version":3,"file":"extractStructAndGroups.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts"],"sourcesContent":["export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n"],"names":["name"],"mappings":";;;;AAeO,SAAS,uBAAuB,IACvC,EAAA;IAEI,MAAM,WAAc,GAAA,wCAAA,CAAA;IACpB,MAAM,YAAe,GAAA,iBAAA,CAAA;IACrB,MAAM,cAAiB,GAAA,mBAAA,CAAA;IACvB,MAAM,WAAc,GAAA,qBAAA,CAAA;IACpB,MAAM,WAAc,GAAA,WAAA,CAAA;IACpB,MAAM,aAAgB,GAAA,6BAAA,CAAA;IACtB,MAAM,mBAAsB,GAAA,0BAAA,CAAA;IAC5B,MAAM,UAAa,GAAA,gBAAA,CAAA;IAGnB,MAAM,SAAS,IAAK,CAAA,KAAA,CAAM,WAAW,CAAG,EAAA,GAAA,CAAI,CAAC,IAAU,GAAA,CAAA;YACnD,KAAA,EAAO,SAAS,IAAK,CAAA,KAAA,CAAM,YAAY,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YAC/C,OAAA,EAAS,SAAS,IAAK,CAAA,KAAA,CAAM,cAAc,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YACnD,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;YAC/B,WAAW,IAAK,CAAA,KAAA,CAAM,WAAW,CAAA,CAAE,CAAC,CAAM,KAAA,WAAA;YAC1C,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;QAAA,CACjC,CAAA,CAAA,CAAA;IAEF,IAAI,CAAC,MACL,EAAA;QACW,OAAA;YACH,QAAQ,EAAC;YACT,SAAS,EAAC;QAAA,CACd,CAAA;IAAA,CACJ;IAGA,MAAM,UAAU,IACX,CAAA,KAAA,CAAM,aAAa,CAClB,EAAA,GAAA,CAAI,CAAC,MACP,KAAA;QACI,MAAM,IAAO,GAAA,MAAA,CAAO,KAAM,CAAA,UAAU,CAAA,CAAE,CAAC,CAAA,CAAA;QACjC,MAAA,OAAA,GAAU,OAAO,KAAM,CAAA,mBAAmB,EAAE,MAAO,CAAA,CAAC,KAA6B,MACvF,KAAA;YACI,MAAM,CAACA,KAAM,EAAA,IAAI,CAAI,GAAA,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAA;YAErC,GAAA,CAAIA,KAAK,CAAA,IAAA,EAAM,CAAA,GAAI,KAAK,IAAK,EAAA,CAAA;YAEtB,OAAA,GAAA,CAAA;QAAA,CACX,EAAG,CAAA,CAAE,CAAA,CAAA;QAEL,IAAI,CAAC,OACL,EAAA;YACW,OAAA,IAAA,CAAA;QAAA,CACX;QAEO,OAAA;YAAE;YAAM,OAAQ;QAAA,CAAA,CAAA;IAAA,CAE1B,CACA,CAAA,MAAA,CAAO,CAAC,EAAE,IAAA,EAAW,GAAA,MAAA,CAAO,IAAK,CAAA,CAAC,QAAU,KAAM,CAAA,IAAA,KAAS,IAAI,CAAC,KAAK,EAAC,CAAA;IAEpE,OAAA;QACH,MAAA;QACA,OAAA;IAAA,CACJ,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3288, "column": 0}, "map": {"version":3,"file":"removeStructAndGroupDuplicates.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts"],"sourcesContent":["import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n"],"names":[],"mappings":";;;;AAEgB,SAAA,8BAAA,CACZ,sBAAA,EACA,wBAEJ,EAAA;IACU,MAAA,aAAA,GAAA,aAAA,GAAA,IAAoB,GAAI,EAAA,CAAA;IACxB,MAAA,eAAA,GAAA,aAAA,GAAA,IAAsB,GAAI,EAAA,CAAA;IAE1B,MAAA,OAAA,GAAU,CAAC;WAAG,sBAAuB,CAAA,OAAA,EAAS;WAAG,wBAAA,CAAyB,OAAO;KAAA,CAClF,MAAO,CAAA,CAAC,MACT,KAAA;QACI,IAAI,aAAc,CAAA,GAAA,CAAI,MAAO,CAAA,IAAI,CACjC,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACc,aAAA,CAAA,GAAA,CAAI,OAAO,IAAI,CAAA,CAAA;QAEtB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEC,MAAA,MAAA,GAAS,CAAC;WAAG,sBAAuB,CAAA,MAAA,EAAQ;WAAG,wBAAA,CAAyB,MAAM;KAAA,CAC/E,MAAO,CAAA,CAAC,KACT,KAAA;QACI,MAAM,MAAM,CAAG,EAAA,KAAA,CAAM,IAAI,CAAA,CAAA,EAAI,MAAM,OAAO,CAAA,CAAA,CAAA;QAEtC,IAAA,eAAA,CAAgB,GAAI,CAAA,GAAG,CAC3B,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACA,eAAA,CAAgB,GAAA,CAAI,GAAG,CAAA,CAAA;QAEhB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEE,OAAA;QAAE;QAAS,MAAO;IAAA,CAAA,CAAA;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 3323, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3329, "column": 0}, "map": {"version":3,"file":"generateLayoutHash.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts"],"sourcesContent":["import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;AAGgB,SAAA,kBAAA,CAAmB,EAAE,MAAA,EACrC,EAAA;IACI,MAAM,SAAwB,EAAC,CAAA;IAE/B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,CAAA,CAAC,CAAA;QAAA,CAC3B;QAEA,MAAA,CAAO,MAAM,KAAK,CAAA,CAAE,KAAM,CAAA,IAAI,CAAA,GAAI,KAAM,CAAA,OAAA,CAAA;IAAA,CAC5C;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3352, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts"],"sourcesContent":["export enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n"],"names":["ShaderStage"],"mappings":";;;;AAAY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,CAAV,CAAA,GAAA,SAAA,CAAA;IAJQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3370, "column": 0}, "map": {"version":3,"file":"generateGpuLayoutGroups.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts"],"sourcesContent":["import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;;;AAKgB,SAAA,uBAAA,CAAwB,EAAE,MAAA,EAC1C,EAAA;IACI,MAAM,SAA2C,EAAC,CAAA;IAElD,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,EAAC,CAAA;QAAA,CAC3B;QAEA,IAAI,MAAM,SACV,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,UAAA,4LAAY,cAAY,CAAA,MAAA,6LAAS,cAAY,CAAA,QAAA;gBAC7C,MAAQ,EAAA;oBACJ,IAAM,EAAA,SAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,SACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,sMAAY,cAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,IAAM,EAAA,WAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,YACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,sMAAY,cAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,UAAY,EAAA,OAAA;oBACZ,aAAe,EAAA,IAAA;oBACf,YAAc,EAAA,KAAA;gBAAA,CAClB;YAAA,CACH,CAAA,CAAA;QAAA,CACL;IAAA,CACJ;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3415, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3421, "column": 0}, "map": {"version":3,"file":"getAttributeInfoFromFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts"],"sourcesContent":["import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3588, "column": 0}, "map": {"version":3,"file":"extractAttributesFromGpuProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n"],"names":[],"mappings":";;;;;;AAMA,MAAM,oBAAqD,GAAA;IAEvD,GAAM,EAAA,SAAA;IACN,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IAEP,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,IAAM,EAAA,QAAA;IACN,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;AAClB,CAAA,CAAA;AAEO,SAAS,+BACZ,CAAA,EAAE,MAAQ,EAAA,UAAA,EAEd,EAAA;IACI,MAAM,UAAkD,CAAA,CAAC,CAAA;IAGzD,MAAM,aAAgB,GAAA,MAAA,CAAO,OAAQ,CAAA,CAAA,GAAA,EAAM,UAAU,CAAE,CAAA,CAAA,CAAA;IAEvD,IAAI,kBAAkB,CACtB,CAAA,EAAA;QAEI,MAAM,kBAAqB,GAAA,MAAA,CAAO,OAAQ,CAAA,IAAA,EAAM,aAAa,CAAA,CAAA;QAE7D,IAAI,uBAAuB,CAC3B,CAAA,EAAA;YACI,MAAM,qBAAwB,GAAA,MAAA,CAAO,SAAU,CAAA,aAAA,EAAe,kBAAkB,CAAA,CAAA;YAGhF,MAAM,WAAc,GAAA,yEAAA,CAAA;YAChB,IAAA,KAAA,CAAA;YAEJ,MAAA,CAAQ,KAAQ,GAAA,WAAA,CAAY,IAAK,CAAA,qBAAqB,CAAA,MAAO,IAC7D,CAAA;gBACI,MAAM,MAAS,GAAA,oBAAA,CAAqB,KAAM,CAAA,CAAC,CAAiB,CAAK,IAAA,SAAA,CAAA;gBAEzD,OAAA,CAAA,KAAA,CAAM,CAAC,CAAC,CAAI,GAAA;oBAChB,QAAU,EAAA,QAAA,CAAS,KAAM,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;oBAC/B,MAAA;oBACA,MAAA,gOAAQ,6BAAA,AAA2B,EAAA,MAAM,CAAE,CAAA,MAAA;oBAC3C,MAAQ,EAAA,CAAA;oBACR,QAAU,EAAA,KAAA;oBACV,KAAO,EAAA,CAAA;gBAAA,CACX,CAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,OAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3641, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3647, "column": 0}, "map": {"version":3,"file":"GpuProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3734, "column": 0}, "map": {"version":3,"file":"stripVersion.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts"],"sourcesContent":["export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,YAAA,CAAa,GAAA,EAAa,OAC1C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,EAAE,CAAA,CAAA;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 3744, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3750, "column": 0}, "map": {"version":3,"file":"ensurePrecision.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts"],"sourcesContent":["import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n"],"names":[],"mappings":";;;;AAsBgB,SAAA,eAAA,CACZ,GACA,EAAA,OAAA,EACA,UAEJ,EAAA;IACI,MAAM,qBAAwB,GAAA,UAAA,GAAa,OAAQ,CAAA,6BAAA,GAAgC,OAAQ,CAAA,2BAAA,CAAA;IAE3F,IAAI,GAAI,CAAA,SAAA,CAAU,CAAG,EAAA,CAAC,MAAM,WAC5B,EAAA;QAEI,IAAI,SAAY,GAAA,UAAA,GAAa,OAAQ,CAAA,0BAAA,GAA6B,OAAQ,CAAA,wBAAA,CAAA;QAGtE,IAAA,SAAA,KAAc,OAAW,IAAA,qBAAA,KAA0B,OACvD,EAAA;YACgB,SAAA,GAAA,SAAA,CAAA;QAAA,CAChB;QAEA,OAAO,CAAA,UAAA,EAAa,SAAS,CAAA;AAAA,EAAY,GAAG,CAAA,CAAA,CAAA;IAAA,CAChD,MAAA,IACS,0BAA0B,OAAW,IAAA,GAAA,CAAI,SAAA,CAAU,CAAG,EAAA,EAAE,MAAM,iBACvE,EAAA;QAEW,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,mBAAmB,CAAA,CAAA;IAAA,CAC7D;IAEO,OAAA,GAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3770, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3776, "column": 0}, "map": {"version":3,"file":"addProgramDefines.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts"],"sourcesContent":["export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,iBAAA,CAAkB,GAAa,EAAA,OAAA,EAAkB,UACjE,EAAA;IACQ,IAAA,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEpB,IAAI,UACJ,EAAA;QACU,GAAA,GAAA,GAAA,CAAI,OAAQ,CAAA,sBAAA,EAAwB,EAAE,CAAA,CAAA;QAErC,OAAA,CAAA;;;;;;;QAAA,EAOL,GAAG,CAAA;QAAA,CAAA,CAAA;IAAA,CAET;IAEO,OAAA,CAAA;;;;;;QAAA,EAMD,GAAG,CAAA;QAAA,CAAA,CAAA;AAEb","ignoreList":[0]}},
    {"offset": {"line": 3805, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3811, "column": 0}, "map": {"version":3,"file":"setProgramName.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts"],"sourcesContent":["const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,oBAA+C,CAAA,CAAC,CAAA;AACtD,MAAM,kBAA6C,CAAA,CAAC,CAAA;AAE7C,SAAS,eAAe,GAAa,EAAA,EAAE,OAAO,CAAe,YAAA,CAAA,EAAA,EAAsB,aAAa,IACvG,EAAA;IACW,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;IAE/B,IAAA,IAAQ,aAAa,WAAc,GAAA,SAAA,CAAA;IAE7B,MAAA,SAAA,GAAY,aAAa,iBAAoB,GAAA,eAAA,CAAA;IAE/C,IAAA,SAAA,CAAU,IAAI,CAClB,EAAA;QACI,SAAA,CAAU,IAAI,CAAA,EAAA,CAAA;QACN,IAAA,IAAA,CAAA,CAAA,EAAI,SAAU,CAAA,IAAI,CAAC,CAAA,CAAA,CAAA;IAAA,CAG/B,MAAA;QACI,SAAA,CAAU,IAAI,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAGI,IAAA,GAAA,CAAI,OAAQ,CAAA,qBAAqB,CAAM,KAAA,CAAA,CAAA,EAAW,OAAA,GAAA,CAAA;IAEhD,MAAA,UAAA,GAAa,CAAA,oBAAA,EAAuB,IAAI,CAAA,CAAA,CAAA;IAE9C,OAAO,GAAG,UAAU,CAAA;AAAA,EAAK,GAAG,CAAA,CAAA,CAAA;AAChC","ignoreList":[0]}},
    {"offset": {"line": 3834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3840, "column": 0}, "map": {"version":3,"file":"insertVersion.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts"],"sourcesContent":["export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,aAAA,CAAc,GAAA,EAAa,OAC3C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,CAAA;AAAA,EAAoB,GAAG,CAAA,CAAA,CAAA;AAClC","ignoreList":[0]}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3857, "column": 0}, "map": {"version":3,"file":"getTestContext.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n"],"names":[],"mappings":";;;;;;AAIA,IAAI,OAAA,CAAA;AAQG,SAAS,cAChB,GAAA;IACI,IAAI,CAAC,OAAA,IAAW,OAAS,EAAA,aAAA,EACzB,EAAA;QACI,MAAM,MAAS,gKAAA,aAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAE7C,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,OAAS,EAAA,CAAA,CAAE,CAAA,CAAA;IAAA,CAC3C;IAEO,OAAA,OAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3873, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3879, "column": 0}, "map": {"version":3,"file":"getMaxFragmentPrecision.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts"],"sourcesContent":["import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n"],"names":[],"mappings":";;;;;;AAIA,IAAI,oBAAA,CAAA;AAEG,SAAS,uBAChB,GAAA;IACI,IAAI,CAAC,oBACL,EAAA;QAC2B,oBAAA,GAAA,SAAA,CAAA;QACvB,MAAM,mNAAK,iBAAA,AAAe,EAAA,CAAA;QAE1B,IAAI,EACJ,EAAA;YACI,IAAI,GAAG,wBACP,EAAA;gBACI,MAAM,iBAAiB,EAAG,CAAA,wBAAA,CAAyB,EAAG,CAAA,eAAA,EAAiB,GAAG,UAAU,CAAA,CAAA;gBAE7D,oBAAA,GAAA,cAAA,CAAe,SAAA,GAAY,OAAU,GAAA,SAAA,CAAA;YAAA,CAChE;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,oBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3901, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3907, "column": 0}, "map": {"version":3,"file":"GlProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4003, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4009, "column": 0}, "map": {"version":3,"file":"compileHighShaderToProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts"],"sourcesContent":["import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAQO,SAAS,2BAA4B,CAAA,EAAE,IAAM,EAAA,IAAA,EACpD,EAAA;IACI,MAAM,SAAS,2NAAA,AAAkB,EAAA;QAC7B,QAAU,EAAA;YACN,QAAU,8LAAA,sBAAA;YACV,MAAQ,8LAAA,oBAAA;QAAA,CACZ;QACA,IAAM,EAAA;qNACF,oBAAA;eACG,IAAA;SACP;IAAA,CACH,CAAA,CAAA;IAED,mMAAO,aAAA,CAAW,IAAK,CAAA;QACnB,IAAA;QACA,MAAQ,EAAA;YACJ,QAAQ,MAAO,CAAA,MAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;QACA,QAAU,EAAA;YACN,QAAQ,MAAO,CAAA,QAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;IAAA,CACH,CAAA,CAAA;AACL,CAAA;AAEO,SAAS,0BAA2B,CAAA,EAAE,IAAM,EAAA,IAAA,EACnD,EAAA;IACI,OAAO,8LAAI,YAAU,CAAA;QACjB,IAAA;QACA,GAAG,6NAAA,AAAoB,EAAA;YACnB,QAAU,EAAA;gBACN,MAAQ,8LAAA,mBAAA;gBACR,QAAU,8LAAA,qBAAA;YAAA,CACd;YACA,IAAM,EAAA;yNACF,sBAAA;mBACG,IAAA;aACP;QAAA,CACH,CAAA;IAAA,CACJ,CAAA,CAAA;AACL","ignoreList":[0]}},
    {"offset": {"line": 4064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4070, "column": 0}, "map": {"version":3,"file":"colorBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts"],"sourcesContent":["export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n"],"names":[],"mappings":";;;;;AAAO,MAAM,QAAW,GAAA;IACpB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ,EAAA;AAEO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4099, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4105, "column": 0}, "map": {"version":3,"file":"generateTextureBatchBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4234, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4240, "column": 0}, "map": {"version":3,"file":"roundPixelsBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts"],"sourcesContent":["export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;AAAO,MAAM,cAAiB,GAAA;IAC1B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AACJ,EAAA;AAEO,MAAM,gBAAmB,GAAA;IAC5B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4275, "column": 0}, "map": {"version":3,"file":"getBatchSamplersUniformGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts"],"sourcesContent":["import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,gCAA8D,CAAA,CAAC,CAAA;AAQ9D,SAAS,6BAA6B,WAC7C,EAAA;IACQ,IAAA,yBAAA,GAA4B,6BAAA,CAA8B,WAAW,CAAA,CAAA;IAErE,IAAA,yBAAA,EAAkC,OAAA,yBAAA,CAAA;IAEhC,MAAA,YAAA,GAAe,IAAI,UAAA,CAAW,WAAW,CAAA,CAAA;IAE/C,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,CAAA;QACI,YAAA,CAAa,CAAC,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAEA,yBAAA,GAA4B,6BAA8B,CAAA,WAAW,CAAI,GAAA,qMAAI,eAAa,CAAA;QACtF,WAAW;YAAE,KAAA,EAAO;YAAc,IAAM,EAAA,CAAA,GAAA,CAAA;YAAO,MAAM,WAAY;QAAA,CAAA;IAAA,CAClE,EAAA;QAAE,QAAU,EAAA,IAAA;IAAA,CAAM,CAAA,CAAA;IAEd,OAAA,yBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4302, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4308, "column": 0}, "map": {"version":3,"file":"Shader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4495, "column": 0}, "map": {"version":3,"file":"DefaultShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts"],"sourcesContent":["import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @memberof rendering\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBO,MAAM,iNAAsB,SACnC,CAAA;IACI,YAAY,WACZ,CAAA;QACI,MAAM,gNAAY,6BAAA,AAA2B,EAAA;YACzC,IAAM,EAAA,OAAA;YACN,IAAM,EAAA;gNACF,aAAA;mOACA,4BAAA,EAA0B,WAAW,CAAA;sNACrC,mBAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAED,MAAM,cAAa,iOAAA,AAA4B,EAAA;YAC3C,IAAM,EAAA,OAAA;YACN,IAAM,EAAA;gNACF,WAAA;mOACA,0BAAA,EAAwB,WAAW,CAAA;sNACnC,iBAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,SAAA;YACA,UAAA;YACA,SAAW,EAAA;gBACP,aAAA,mNAAe,+BAAA,EAA6B,WAAW,CAAA;YAAA,CAC3D;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4540, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4546, "column": 0}, "map": {"version":3,"file":"checkMaxIfStatementsInShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n"],"names":[],"mappings":";;;;AAEA,MAAM,YAAe,GAAA;IACjB,0BAAA;IACA,kBAAA;IACA,mBAAA;IACA,WAAA;IACA,2BAAA;IACA,GAAA;CACJ,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;AAEX,SAAS,kBAAkB,MAC3B,EAAA;IACI,IAAI,GAAM,GAAA,EAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,EAAQ,EAAE,CAC9B,CAAA;QACI,IAAI,IAAI,CACR,EAAA;YACW,GAAA,IAAA,SAAA,CAAA;QAAA,CACX;QAEI,IAAA,CAAA,GAAI,SAAS,CACjB,EAAA;YACI,GAAA,IAAO,CAAA,WAAA,EAAc,CAAC,CAAA,KAAA,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX,CAAA;AAEgB,SAAA,4BAAA,CAA6B,MAAA,EAAgB,EAC7D,EAAA;IACI,IAAI,WAAW,CACf,EAAA;QACU,MAAA,IAAI,MAAM,+DAA+D,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,MAAS,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,eAAe,CAAA,CAAA;IAGjD,IAAA;QACI,MAAO,IACP,CAAA;YACI,MAAM,cAAc,YAAa,CAAA,OAAA,CAAQ,aAAe,EAAA,iBAAA,CAAkB,MAAM,CAAC,CAAA,CAAA;YAE9E,EAAA,CAAA,YAAA,CAAa,QAAQ,WAAW,CAAA,CAAA;YACnC,EAAA,CAAG,aAAA,CAAc,MAAM,CAAA,CAAA;YAEvB,IAAI,CAAC,EAAG,CAAA,kBAAA,CAAmB,MAAQ,EAAA,EAAA,CAAG,cAAc,CACpD,EAAA;gBACI,MAAA,GAAU,SAAS,CAAK,GAAA,CAAA,CAAA;YAAA,CAG5B,MAAA;gBAEI,MAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CAEJ,QAAA;QAEI,EAAA,CAAG,YAAA,CAAa,MAAM,CAAA,CAAA;IAAA,CAC1B;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4593, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4599, "column": 0}, "map": {"version":3,"file":"maxRecommendedTextures.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts"],"sourcesContent":["import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n"],"names":[],"mappings":";;;;;;;;AAGA,IAAI,wBAA0C,GAAA,IAAA,CAAA;AASvC,SAAS,sBAChB,GAAA;IACQ,IAAA,wBAAA,EAAiC,OAAA,wBAAA,CAAA;IAErC,MAAM,mNAAK,iBAAA,AAAe,EAAA,CAAA;IAGC,wBAAA,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,uBAAuB,CAAA,CAAA;IAG1C,wBAAA,iNAAA,+BAAA,EACvB,wBAAA,EAA0B,EAAA;IAE3B,EAAA,CAAA,YAAA,CAAa,oBAAoB,CAAA,EAAG,WAAY,EAAA,CAAA;IAE5C,OAAA,wBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4618, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4624, "column": 0}, "map": {"version":3,"file":"ViewableBuffer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/utils/data/ViewableBuffer.ts"],"sourcesContent":["type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4725, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts"],"sourcesContent":["/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n"],"names":["STENCIL_MODES"],"mappings":";;;;;AA2CO,MAAM,YAAe,GAAA;IACxB,MAAQ,EAAA,YAAA;IACR,GAAK,EAAA,SAAA;IACL,MAAQ,EAAA,YAAA;AACZ,EAAA;AAMY,IAAA,aAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,cAAL,KAAA;IAEHA,cAAAA,CAAAA,cAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,qBAAA,GAAqB,CAArB,CAAA,GAAA,oBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,cAAA,GAAc,CAAd,CAAA,GAAA,aAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,sBAAA,GAAsB,CAAtB,CAAA,GAAA,qBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,wBAAA,GAAwB,CAAxB,CAAA,GAAA,uBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,cAAAA,CAAAA;AAAA,CAAA,EAAA,aAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4746, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4752, "column": 0}, "map": {"version":3,"file":"getAdjustedBlendModeBlend.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts"],"sourcesContent":["import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n"],"names":[],"mappings":";;;;;;AAYgB,SAAA,yBAAA,CAA0B,SAAA,EAAwB,aAClE,EAAA;IACQ,IAAA,aAAA,CAAc,SAAA,KAAc,sBAChC,EAAA;QACY,gMAAA,eAAA,CAAa,SAAsC,CAAK,IAAA,SAAA,CAAA;IAAA,CACpE;IAEO,OAAA,SAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4766, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4772, "column": 0}, "map": {"version":3,"file":"fastCopy.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts"],"sourcesContent":["/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n"],"names":[],"mappings":";;;;AAQgB,SAAA,QAAA,CAAS,YAAA,EAA2B,iBACpD,EAAA;IACU,MAAA,YAAA,GAAgB,YAAa,CAAA,UAAA,GAAa,CAAK,GAAA,CAAA,CAAA;IAErD,MAAM,iBAAoB,GAAA,IAAI,YAAa,CAAA,YAAA,EAAc,GAAG,YAAY,CAAA,CAAA;IACxE,MAAM,sBAAyB,GAAA,IAAI,YAAa,CAAA,iBAAA,EAAmB,GAAG,YAAY,CAAA,CAAA;IAGlF,sBAAA,CAAuB,GAAA,CAAI,iBAAiB,CAAA,CAAA;IAGtC,MAAA,cAAA,GAAiB,YAAa,CAAA,UAAA,GAAc,YAAe,GAAA,CAAA,CAAA;IAEjE,IAAI,iBAAiB,CACrB,EAAA;QACI,MAAM,kBAAkB,IAAI,UAAA,CAAW,YAAc,EAAA,YAAA,GAAe,GAAG,cAAc,CAAA,CAAA;QACrF,MAAM,uBAAuB,IAAI,UAAA,CAAW,iBAAmB,EAAA,YAAA,GAAe,GAAG,cAAc,CAAA,CAAA;QAG/F,oBAAA,CAAqB,GAAA,CAAI,eAAe,CAAA,CAAA;IAAA,CAC5C;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4790, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4796, "column": 0}, "map": {"version":3,"file":"BatchTextureArray.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts"],"sourcesContent":["import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n"],"names":[],"mappings":";;;;AAMO,MAAM,iBACb,CAAA;IAUI,WACA,EAAA;QANA,uCAAA,GAAO,IAAA,CAAA,GAAA,GAAA,aAAA,GAAqC,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAOnD,IAAA,CAAK,QAAA,GAAW,EAAC,CAAA;QACjB,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;IAAA,4CAAA,GAGO,KACP,GAAA;QACI,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,KAAA,EAAO,CAChC,EAAA,CAAA;YACU,MAAA,CAAA,GAAI,IAAK,CAAA,QAAA,CAAS,CAAC,CAAA,CAAA;YAEpB,IAAA,CAAA,QAAA,CAAS,CAAC,CAAI,GAAA,IAAA,CAAA;YACd,IAAA,CAAA,GAAA,CAAI,CAAE,CAAA,GAAG,CAAI,GAAA,IAAA,CAAA;QAAA,CACtB;QAEA,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4817, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4823, "column": 0}, "map": {"version":3,"file":"Batcher.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5101, "column": 0}, "map": {"version":3,"file":"DefaultBatcher.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @memberof rendering\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @memberof rendering\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5219, "column": 0}, "map": {"version":3,"file":"BatcherPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @memberof rendering\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher();\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5322, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5328, "column": 0}, "map": {"version":3,"file":"BatchableSprite.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n"],"names":[],"mappings":";;;;AAYO,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAEH,IAAA,CAAO,WAAc,GAAA,SAAA,CAAA;QACrB,IAAA,CAAO,QAAqB,GAAA,eAAA,CAAA;QAG5B,mBAAA;QAAA,IAAA,CAAgB,aAAgB,GAAA,CAAA,CAAA;QAChC,IAAA,CAAgB,SAAY,GAAA,CAAA,CAAA;QAC5B,IAAA,CAAgB,UAAa,GAAA,IAAA,CAAA;QAQ7B,IAAA,CAAO,WAAqB,GAAA,CAAA,CAAA;QAI5B,IAAA,CAAO,eAAkB,GAAA,CAAA,CAAA;QACzB,yBAAA;QAAA,IAAA,CAAO,QAAoB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAO,MAAgB,GAAA,IAAA,CAAA;IAAA,CAAA;IAEvB,IAAI,SAAY,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,cAAA,CAAA;IAAA,CAAgB;IACzD,IAAI,KAAQ,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,eAAA,CAAA;IAAA,CAAiB;IAE/C,KACP,GAAA;QACI,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAClB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;QAChB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;QACd,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5362, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5368, "column": 0}, "map": {"version":3,"file":"SpritePipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/sprite/SpritePipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { Sprite } from './Sprite';\n\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuSpriteHash: Record<number, BatchableSprite> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    public destroyRenderable(sprite: Sprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = BigPool.get(BatchableSprite);\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            BigPool.return(this._gpuSpriteHash[i] as PoolItem);\n        }\n\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5447, "column": 0}, "map": {"version":3,"file":"RenderGroupPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"file":"mask.wgsl.mjs","sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 5549, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5555, "column": 0}, "map": {"version":3,"file":"mask.vert.mjs","sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 5561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5567, "column": 0}, "map": {"version":3,"file":"mask.frag.mjs","sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 5573, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5579, "column": 0}, "map": {"version":3,"file":"Filter.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/filters/Filter.ts"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAmJO,MAAM,OAAA,GAAN,MAAM,OAAA,oMAAe,SAC5B,CAAA;IAAA;;GAAA,GA4DI,YAAY,OACZ,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,OAAO,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEjD,KAAA,CAAM,OAA8B,CAAA,CAAA;QAnCxC,oEAAA,GAAA,IAAA,CAAO,OAAU,GAAA,IAAA,CAAA;QAOjB;;;;KAAA,GAAO,IAAA,CAAA,MAAA,GAAS,iMAAA,CAAM,KAAM,EAAA,CAAA;QA8BxB,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QACzB,IAAA,CAAK,OAAA,GAAU,OAAQ,CAAA,OAAA,CAAA;QAGnB,IAAA,OAAO,OAAQ,CAAA,SAAA,KAAc,SACjC,EAAA;YACS,IAAA,CAAA,SAAA,GAAY,OAAQ,CAAA,SAAA,GAAY,IAAO,GAAA,KAAA,CAAA;QAAA,CAGhD,MAAA;YACI,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QAAA,CAC7B;QAEA,IAAA,CAAK,UAAA,GAAa,OAAQ,CAAA,UAAA,CAAA;QAC1B,IAAA,CAAK,aAAA,GAAgB,OAAQ,CAAA,aAAA,CAAA;QAC7B,IAAA,CAAK,cAAA,GAAiB,OAAQ,CAAA,cAAA,CAAA;QAEzB,IAAA,CAAA,WAAA,CAAY,UAAY,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;IAAA,CACrC;IAAA;;;;;;GAAA,GASO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QACI,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;IAAA;;;GAAA,GAMA,IAAI,SACJ,GAAA;QACI,OAAO,IAAA,CAAK,MAAO,CAAA,SAAA,CAAA;IAAA,CACvB;IAAA,uCAAA,GAGA,IAAI,UAAU,KACd,EAAA;QACI,IAAA,CAAK,MAAA,CAAO,SAAY,GAAA,KAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOA,OAAc,KAAK,OACnB,EAAA;QACI,MAAM,EAAE,GAAA,EAAK,EAAI,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;QAEzB,IAAA,UAAA,CAAA;QACA,IAAA,SAAA,CAAA;QAEJ,IAAI,GACJ,EAAA;YACiB,UAAA,+LAAA,aAAA,CAAW,IAAA,CAAK,GAAG,CAAA,CAAA;QAAA,CACpC;QAEA,IAAI,EACJ,EAAA;YACgB,SAAA,6LAAA,YAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAA;QAAA,CACjC;QAEA,OAAO,IAAI,OAAO,CAAA;YACd,UAAA;YACA,SAAA;YACA,GAAG,IAAA;QAAA,CACN,CAAA,CAAA;IAAA,CACL;AACJ,CAAA,CAAA;AAAA;;;CAAA,GAnJa,OAAA,CAMc,cAAgC,GAAA;IACnD,SAAW,EAAA,QAAA;IACX,UAAY,EAAA,CAAA;IACZ,OAAS,EAAA,CAAA;IACT,SAAW,EAAA,KAAA;IACX,aAAe,EAAA,KAAA;IACf,cAAgB,EAAA,IAAA;AACpB,CAAA,CAAA;AAbG,IAAM,MAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 5671, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5677, "column": 0}, "map": {"version":3,"file":"MaskFilter.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/filters/mask/MaskFilter.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsBO,MAAM,2KAAmB,SAChC,CAAA;IAII,YAAY,OACZ,CAAA;QACI,MAAM,EAAE,MAAA,EAAQ,GAAG,IAAA,EAAS,GAAA,OAAA,CAAA;QAE5B,MAAM,aAAgB,GAAA,uMAAI,gBAAc,CAAA,MAAA,CAAO,OAAO,CAAA,CAAA;QAEhD,MAAA,cAAA,GAAiB,qMAAI,eAAa,CAAA;YACpC,eAAe;gBAAE,KAAA,EAAO,oKAAI,SAAO,EAAA;gBAAG,MAAM,aAAc;YAAA,CAAA;YAC1D,YAAY;gBAAE,KAAA,EAAO,aAAc,CAAA,WAAA;gBAAa,MAAM,WAAY;YAAA,CAAA;YAClE,MAAQ,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;YAChC,QAAA,EAAU;gBAAE,KAAO,EAAA,OAAA,CAAQ,OAAA,GAAU,CAAI,GAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;QAAA,CAC3D,CAAA,CAAA;QAEK,MAAA,UAAA,GAAa,yMAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;8LACJ,UAAA;gBACA,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;gBACN,wLAAA;gBACA,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,6LAAY,YAAA,CAAU,IAAK,CAAA;YAC7B,wLAAA;4LACA,UAAA;YACA,IAAM,EAAA,aAAA;QAAA,CACT,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,GAAG,IAAA;YACH,UAAA;YACA,SAAA;YACA,SAAW,EAAA;gBACP,cAAA;gBACA,YAAA,EAAc,OAAO,OAAQ,CAAA,MAAA;YAAA,CACjC;QAAA,CACH,CAAA,CAAA;QAED,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QAEd,IAAA,CAAK,cAAiB,GAAA,aAAA,CAAA;IAAA,CAC1B;IAEA,IAAI,QAAQ,KACZ,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,QAAA,GAAW,QAAQ,CAAI,GAAA,CAAA,CAAA;IAAA,CAClE;IAEA,IAAI,OACJ,GAAA;QACI,OAAO,IAAK,CAAA,SAAA,CAAU,cAAe,CAAA,QAAA,CAAS,QAAa,KAAA,CAAA,CAAA;IAAA,CAC/D;IAEO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QAES,IAAA,CAAA,cAAA,CAAe,OAAU,GAAA,IAAA,CAAK,MAAO,CAAA,OAAA,CAAA;QAE5B,aAAA,CAAA,qBAAA,CACV,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,aAAA,EACvC,IAAK,CAAA,MAAA,EACP,OAAA,CAAQ,IAAK,CAAA,cAAA,CAAe,QAAQ,CAAA,CAAA;QAEtC,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,IAAK,CAAA,MAAA,CAAO,OAAQ,CAAA,MAAA,CAAA;QAElD,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5763, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5769, "column": 0}, "map": {"version":3,"file":"AlphaMaskPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            collectAllRenderables(\n                maskContainer,\n                instructionSet,\n                renderer\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5939, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5945, "column": 0}, "map": {"version":3,"file":"StencilMaskPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        collectAllRenderables(\n            maskContainer,\n            instructionSet,\n            renderer,\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6075, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6081, "column": 0}, "map": {"version":3,"file":"ColorMaskPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        this._colorStack = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAgBO,MAAM,aACb,CAAA;IAgBI,YAAY,QACZ,CAAA;QALA,IAAA,CAAQ,WAAA,GAAwB,EAAC,CAAA;QACjC,IAAA,CAAQ,gBAAmB,GAAA,CAAA,CAAA;QAC3B,IAAA,CAAQ,aAAgB,GAAA,CAAA,CAAA;QAIpB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,UACP,GAAA;QACS,IAAA,CAAA,WAAA,CAAY,CAAC,CAAI,GAAA,EAAA,CAAA;QACtB,IAAA,CAAK,gBAAmB,GAAA,CAAA,CAAA;QACxB,IAAA,CAAK,aAAgB,GAAA,EAAA,CAAA;IAAA,CACzB;IAEO,IAAA,CAAK,IAAc,EAAA,UAAA,EAAuB,cACjD,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAE/C,MAAM,aAAa,IAAK,CAAA,WAAA,CAAA;QAEb,UAAA,CAAA,IAAA,CAAK,gBAAgB,CAAI,GAAA,UAAA,CAAW,IAAA,CAAK,gBAAmB,GAAA,CAAC,CAAA,GAAK,IAAmB,CAAA,IAAA,CAAA;QAEhG,MAAM,YAAe,GAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;QAEvD,IAAA,YAAA,KAAiB,IAAA,CAAK,aAC1B,EAAA;YACI,IAAA,CAAK,aAAgB,GAAA,YAAA,CAAA;YACrB,cAAA,CAAe,GAAI,CAAA;gBACf,YAAc,EAAA,WAAA;gBACd,SAAW,EAAA,YAAA;gBACX,SAAW,EAAA,KAAA;YAAA,CACU,CAAA,CAAA;QAAA,CAC7B;QAEK,IAAA,CAAA,gBAAA,EAAA,CAAA;IAAA,CACT;IAEO,GAAA,CAAI,KAAe,EAAA,UAAA,EAAuB,cACjD,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAE/C,MAAM,aAAa,IAAK,CAAA,WAAA,CAAA;QAEnB,IAAA,CAAA,gBAAA,EAAA,CAAA;QAEL,MAAM,YAAe,GAAA,UAAA,CAAW,IAAK,CAAA,gBAAA,GAAmB,CAAC,CAAA,CAAA;QAErD,IAAA,YAAA,KAAiB,IAAA,CAAK,aAC1B,EAAA;YACI,IAAA,CAAK,aAAgB,GAAA,YAAA,CAAA;YAErB,cAAA,CAAe,GAAI,CAAA;gBACf,YAAc,EAAA,WAAA;gBACd,SAAW,EAAA,YAAA;gBACX,SAAW,EAAA,KAAA;YAAA,CACU,CAAA,CAAA;QAAA,CAC7B;IAAA,CACJ;IAEO,QAAQ,WACf,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,SAAA,CAAU,OAAQ,CAAA,WAAA,CAAY,SAAS,CAAA,CAAA;IAAA,CACpD;IAEO,OACP,GAAA;QACI,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;IAAA,CACvB;AACJ,CAAA;AAAA,YAAA,GAzFa,aAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,UAAA;uKACd,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 6148, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6154, "column": 0}, "map": {"version":3,"file":"CustomRenderPipe.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @memberof rendering\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAoBO,MAAM,gBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,gBAAmB,GAAA,CAAA,CAAe;IAClC,iBAAoB,GAAA,CAAA,CAAe;IACnC,kBAAqB,GAAA;QAAS,OAAA,KAAA,CAAA;IAAA,CAAO;IAErC,aAAA,CAAc,SAAA,EAA4B,cACjD,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAErD,cAAA,CAAe,GAAA,CAAI,SAAS,CAAA,CAAA;IAAA,CAChC;IAEO,QAAQ,SACf,EAAA;QACI,IAAI,CAAC,SAAU,CAAA,YAAA,EAAc,OAAA;QAEnB,SAAA,CAAA,MAAA,CAAO,IAAA,CAAK,SAAS,CAAA,CAAA;IAAA,CACnC;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAxCa,gBAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,UAAA;uKACd,gBAAc,CAAA,WAAA;uKACd,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,cAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 6191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6197, "column": 0}, "map": {"version":3,"file":"SharedSystems.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts"],"sourcesContent":["import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,MAAM,aAAgB,GAAA;4MACzB,oBAAA;kNACA,sBAAA;qMACA,cAAA;iMACA,aAAA;kLACA,oBAAA;yMACA,kBAAA;+MACA,wBAAA;uMACA,gBAAA;IACA,wLAAA;4MACA,qBAAA;8LACA,kBAAA;CACJ,CAAA;AAEO,MAAM,iBAAoB,GAAA;0MAC7B,gBAAA;wLACA,cAAA;wKACA,aAAA;gLACA,kBAAA;sLACA,gBAAA;0LACA,kBAAA;sLACA,gBAAA;iLACA,mBAAA;CACJ","ignoreList":[0]}},
    {"offset": {"line": 6265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6271, "column": 0}, "map": {"version":3,"file":"createUboElementsSTD40.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts"],"sourcesContent":["import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    i32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'vec2<i32>': 8,\n    'vec3<i32>': 12,\n    'vec4<i32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    const chunkSize = 16;\n\n    let size = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, chunkSize) * uboElement.data.size;\n        }\n\n        const boundary = size === 12 ? 16 : size;\n\n        uboElement.size = size;\n\n        const curOffset = offset % chunkSize;\n\n        if (curOffset > 0 && chunkSize - curOffset < boundary)\n        {\n            offset += (chunkSize - curOffset) % 16;\n        }\n        else\n        {\n            offset += (size - (curOffset % size)) % size;\n        }\n\n        uboElement.offset = offset;\n        offset += size;\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n"],"names":[],"mappings":";;;;;AAEO,MAAM,kBAA6C,GAAA;IACtD,GAAK,EAAA,CAAA;IACL,GAAK,EAAA,CAAA;IACL,WAAa,EAAA,CAAA;IACb,WAAa,EAAA,EAAA;IACb,WAAa,EAAA,EAAA;IAEb,WAAa,EAAA,CAAA;IACb,WAAa,EAAA,EAAA;IACb,WAAa,EAAA,EAAA;IAEb,eAAe,EAAK,GAAA,CAAA;IACpB,eAAe,EAAK,GAAA,CAAA;IACpB,eAAe,EAAK,GAAA,CAAA;AAqBxB,EAAA;AAEO,SAAS,uBAAuB,WACvC,EAAA;IACI,MAAM,WAA4B,GAAA,WAAA,CAAY,GAAI,CAAA,CAAC,IAC9C,GAAA,CAAA;YACG,IAAA;YACA,MAAQ,EAAA,CAAA;YACR,IAAM,EAAA,CAAA;QAAA,CACR,CAAA,CAAA,CAAA;IAEN,MAAM,SAAY,GAAA,EAAA,CAAA;IAElB,IAAI,IAAO,GAAA,CAAA,CAAA;IACX,IAAI,MAAS,GAAA,CAAA,CAAA;IAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,CAAY,MAAA,EAAQ,CACxC,EAAA,CAAA;QACU,MAAA,UAAA,GAAa,WAAA,CAAY,CAAC,CAAA,CAAA;QAEzB,IAAA,GAAA,kBAAA,CAAmB,UAAW,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;QAE9C,IAAI,CAAC,IACL,EAAA;YACI,MAAM,IAAI,KAAM,CAAA,CAAA,aAAA,EAAgB,UAAW,CAAA,IAAA,CAAK,IAAI,CAAE,CAAA,CAAA,CAAA;QAAA,CAC1D;QAEI,IAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,CAC3B,EAAA;YACI,IAAA,GAAO,KAAK,GAAI,CAAA,IAAA,EAAM,SAAS,CAAA,GAAI,WAAW,IAAK,CAAA,IAAA,CAAA;QAAA,CACvD;QAEM,MAAA,QAAA,GAAW,IAAS,KAAA,EAAA,GAAK,EAAK,GAAA,IAAA,CAAA;QAEpC,UAAA,CAAW,IAAO,GAAA,IAAA,CAAA;QAElB,MAAM,YAAY,MAAS,GAAA,SAAA,CAAA;QAE3B,IAAI,SAAY,GAAA,CAAA,IAAK,SAAY,GAAA,SAAA,GAAY,QAC7C,EAAA;YACI,MAAA,IAAA,CAAW,YAAY,SAAa,IAAA,EAAA,CAAA;QAAA,CAGxC,MAAA;YACe,MAAA,IAAA,CAAA,IAAA,GAAQ,YAAY,IAAS,IAAA,IAAA,CAAA;QAAA,CAC5C;QAEA,UAAA,CAAW,MAAS,GAAA,MAAA,CAAA;QACV,MAAA,IAAA,IAAA,CAAA;IAAA,CACd;IAEA,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,MAAS,GAAA,EAAE,CAAI,GAAA,EAAA,CAAA;IAE3B,OAAA;QAAE,WAAa;QAAA,IAAA,EAAM,MAAO;IAAA,CAAA,CAAA;AACvC","ignoreList":[0]}},
    {"offset": {"line": 6326, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6332, "column": 0}, "map": {"version":3,"file":"uniformParsers.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts"],"sourcesContent":["// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\nexport interface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n"],"names":[],"mappings":";;;;AAiCO,MAAM,cAA4C,GAAA;IAAA,uCAAA;IAErD;QACI,IAAM,EAAA,aAAA;QACN,IAAA,EAAM,CAAC,IACP,KAAA;YACI,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;YAEnB,OAAO,MAAM,CAAM,KAAA,KAAA,CAAA,CAAA;QAAA,CACvB;QACA,GAAK,EAAA,CAAA;;;;;;;;;;;QAAA,CAAA;QAYL,OAAS,EAAA,CAAA;;QAAA,CAAA;IAAA,CAGb;IAAA,uCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,KAAU,KAAA,KAAA,CAAA;QACxF,GAAK,EAAA,CAAA;;;;;;QAAA,CAAA;QAOL,OAAS,EAAA,CAAA;;;;;;;;;;QAAA,CAAA;IAAA,CAWb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,CAAM,KAAA,KAAA,CAAA;QACpF,GAAM,EAAA,CAAA;;;;QAAA,CAAA;QAKN,OAAS,EAAA,CAAA;;;;;;;;QAAA,CAAA;IAAA,CASb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;QAClF,GAAK,EAAA,CAAA;;;;;;QAAA,CAAA;QAOL,OAAS,EAAA,CAAA;;;;;;;;;;QAAA,CAAA;IAAA,CAWb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;QAClF,GAAK,EAAA,CAAA;;;;;QAAA,CAAA;QAML,OAAS,EAAA,CAAA;;;;;;;;;QAAA,CAAA;IAAA,CAUb;CACJ","ignoreList":[0]}},
    {"offset": {"line": 6449, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6455, "column": 0}, "map": {"version":3,"file":"createUboSyncFunction.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts"],"sourcesContent":["import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n"],"names":[],"mappings":";;;;;;AAIO,SAAS,qBACZ,CAAA,WAAA,EACA,UACA,EAAA,uBAAA,EACA,gBAEJ,EAAA;IACI,MAAM,gBAAgB;QAAC,CAAA;;;;;;;IAOtB,CAAA;KAAA,CAAA;IAED,IAAI,IAAO,GAAA,CAAA,CAAA;IAEX,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,CAAY,MAAA,EAAQ,CACxC,EAAA,CAAA;QACU,MAAA,UAAA,GAAa,WAAA,CAAY,CAAC,CAAA,CAAA;QAE1B,MAAA,IAAA,GAAO,WAAW,IAAK,CAAA,IAAA,CAAA;QAE7B,IAAI,MAAS,GAAA,KAAA,CAAA;QACb,IAAI,MAAS,GAAA,CAAA,CAAA;QAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,+MAAA,iBAAA,CAAe,MAAA,EAAQ,CAC3C,EAAA,CAAA;YACU,MAAA,aAAA,+MAAgB,iBAAA,CAAe,CAAC,CAAA,CAAA;YAEtC,IAAI,aAAc,CAAA,IAAA,CAAK,UAAW,CAAA,IAAI,CACtC,EAAA;gBACI,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAEf,aAAA,CAAA,IAAA,CACV,CAAA,QAAA,EAAW,IAAI,CAAA,EAAA,CAAA,EACf,CAAA,UAAA,EAAa,SAAS,IAAI,CAAA,CAAA,CAAA,8MAC1B,iBAAA,CAAe,CAAC,CAAA,CAAE,UAAU,CAAK,gNAAA,iBAAA,CAAe,CAAC,CAAE,CAAA,GAAA;gBAC9C,MAAA,GAAA,IAAA,CAAA;gBAET,MAAA;YAAA,CACJ;QAAA,CACJ;QAEA,IAAI,CAAC,MACL,EAAA;YACQ,IAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,CAC3B,EAAA;gBACI,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAE7B,aAAA,CAAc,IAAK,CAAA,uBAAA,CAAwB,UAAY,EAAA,MAAA,GAAS,IAAI,CAAC,CAAA,CAAA;YAAA,CAGzE,MAAA;gBACI,MAAM,QAAW,GAAA,gBAAA,CAAiB,UAAW,CAAA,IAAA,CAAK,IAA4B,CAAA,CAAA;gBAE9E,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAEf,aAAA,CAAA,IAAA,CAAA,QAAA,GAAe,CAAA;2BAAA,EAChB,IAAI,CAAA;8BAAA,EACD,SAAS,IAAI,CAAA;oBAAA,EACvB,QAAQ,CAAA;gBAAA,CAAA;YACb,CACL;QAAA,CACJ;QAEO,IAAA,GAAA,MAAA,CAAA;IAAA,CACX;IAEM,MAAA,WAAA,GAAc,aAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IAG3C,OAAO,IAAI,QAAA,CACP,IAAA,EACA,MAAA,EACA,WAAA,EACA,QAAA,EACA,WAAA;AAER","ignoreList":[0]}},
    {"offset": {"line": 6508, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6514, "column": 0}, "map": {"version":3,"file":"generateArraySyncSTD40.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.ts"],"sourcesContent":["import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string\n{\n    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n\n    const remainder = (4 - (elementSize % 4)) % 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                ${data}[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n        }\n    `;\n}\n"],"names":[],"mappings":";;;;;;AAWgB,SAAA,sBAAA,CAAuB,UAAA,EAAwB,WAC/D,EAAA;IACU,MAAA,OAAA,GAAU,KAAK,GAAI,iNAAA,qBAAA,CAAmB,WAAW,IAAK,CAAA,IAAI,CAAI,GAAA,EAAA,EAAI,CAAC,CAAA,CAAA;IACzE,MAAM,cAAe,UAAW,CAAA,IAAA,CAAK,KAAwB,CAAA,MAAA,GAAS,WAAW,IAAK,CAAA,IAAA,CAAA;IAEhF,MAAA,SAAA,GAAA,CAAa,CAAK,GAAA,WAAA,GAAc,CAAM,IAAA,CAAA,CAAA;IACtC,MAAA,IAAA,GAAO,WAAW,IAAK,CAAA,IAAA,CAAK,OAAA,CAAQ,KAAK,CAAA,IAAK,IAAI,WAAc,GAAA,MAAA,CAAA;IAE/D,OAAA,CAAA;eACM,EAAA,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;kBAAA,EACjB,WAAW,CAAA;;;;;;yBAMJ,EAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,OAAO,CAAA;;+BAAA,EAExB,WAAW,CAAA;;gBAAA,EAE1B,IAAI,CAAA;;YAAA,EAER,SAAc,KAAA,CAAA,GAAI,CAAkB,eAAA,EAAA,SAAS,CAAA,CAAA,CAAA,GAAM,EAAE,CAAA;;IAAA,CAAA,CAAA;AAGnE","ignoreList":[0]}},
    {"offset": {"line": 6545, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6551, "column": 0}, "map": {"version":3,"file":"uboSyncFunctions.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts"],"sourcesContent":["import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n"],"names":[],"mappings":";;;;;AAEA,SAAS,UAAA,CAAW,GAAA,EAAa,GACjC,EAAA;IACI,MAAM,QAAQ,GAAM,GAAA,GAAA,CAAA;IAEb,OAAA,CAAA;4BAAA,EACmB,KAAK,CAAA;iCACA,EAAA,GAAG,CAAA,iBAAA,EAAoB,GAAG,CAAA;;IAAA,CAAA,CAAA;AAG7D,CAAA;AAEO,MAAM,qBAA8D,GAAA;IACvE,GAAK,EAAA,CAAA;yBAAA,CAAA;IAEL,GAAK,EAAA,CAAA;8BAAA,CAAA;IAEL,WAAa,EAAA,CAAA;;gCAAA,CAAA;IAGb,WAAa,EAAA,CAAA;;;gCAAA,CAAA;IAIb,WAAa,EAAA,CAAA;;;;gCAAA,CAAA;IAKb,WAAa,EAAA,CAAA;;qCAAA,CAAA;IAGb,WAAa,EAAA,CAAA;;;qCAAA,CAAA;IAIb,WAAa,EAAA,CAAA;;;;qCAAA,CAAA;IAKb,aAAe,EAAA,CAAA;;;;gCAAA,CAAA;IAKf,aAAe,EAAA,CAAA;;;;;;;;;iCAAA,CAAA;IAUf,aAAe,EAAA,CAAA;;;SAAA,CAAA;IAIf,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;AAClC,EAAA;AAEO,MAAM,oBAA6D,GAAA;IACtE,GAAG,qBAAA;IACH,aAAe,EAAA,CAAA;;;;;IAAA,CAAA;AAMnB","ignoreList":[0]}},
    {"offset": {"line": 6630, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6636, "column": 0}, "map": {"version":3,"file":"createUboSyncSTD40.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboSyncSTD40.ts"],"sourcesContent":["import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function createUboSyncFunctionSTD40(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboStd40',\n        generateArraySyncSTD40,\n        uboSyncFunctionsSTD40,\n    );\n}\n"],"names":[],"mappings":";;;;;;;;;;AAMO,SAAS,2BACZ,WAEJ,EAAA;IACW,8NAAA,wBAAA,EACH,WAAA,EACA,UAAA,kNACA,yBAAA,gNACA,wBAAA;AAER","ignoreList":[0]}},
    {"offset": {"line": 6651, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6657, "column": 0}, "map": {"version":3,"file":"UboSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts"],"sourcesContent":["import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @memberof rendering\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6743, "column": 0}, "map": {"version":3,"file":"GlUboSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @memberof rendering\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AASO,MAAM,kNAAoB,YACjC,CAAA;IAOI,WACA,EAAA;QACU,KAAA,CAAA;YACF,iBAAmB,kNAAA,yBAAA;YACnB,eAAiB,EAAA,yOAAA;QAAA,CACpB,CAAA,CAAA;IAAA,CACL;AACJ,CAAA;AAAA,YAAA,GAfa,WAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;uKAAC,gBAAA,CAAc,WAAW;KAAA;IAChC,IAAM,EAAA,KAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 6771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6777, "column": 0}, "map": {"version":3,"file":"GlBackBufferSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @memberof rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     * @memberof rendering.WebGLOptions\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @memberof rendering\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n"],"names":["renderTarget"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6920, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6926, "column": 0}, "map": {"version":3,"file":"GlContextSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @memberof rendering\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     * @memberof rendering.SharedRendererOptions\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @memberof rendering.SharedRendererOptions\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     * @memberof rendering.SharedRendererOptions\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     * @memberof rendering.SharedRendererOptions\n     */\n    preferWebGLVersion?: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     * @memberof rendering.SharedRendererOptions\n     */\n    multiView: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @memberof rendering\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n        /**\n         * {@link WebGLOptions.multiView}\n         * @default false\n         */\n        multiView: false\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    public multiView: boolean;\n\n    /**\n     * The canvas that the WebGL Context is rendering to.\n     * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n     * It will be rendered to and then copied to the target canvas.\n     * @readonly\n     */\n    public canvas: ICanvas;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        // TODO add to options\n        let multiView = this.multiView = options.multiView;\n\n        if (options.context && multiView)\n        {\n            // eslint-disable-next-line max-len\n            warn('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.');\n\n            multiView = false;\n        }\n\n        if (multiView)\n        {\n            this.canvas = DOMAdapter.get()\n                .createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n        }\n        else\n        {\n            this.canvas = this._renderer.view.canvas;\n        }\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    public ensureCanvasSize(targetCanvas: ICanvas): void\n    {\n        if (!this.multiView)\n        {\n            if (targetCanvas !== this.canvas)\n            {\n                warn('multiView is disabled, but targetCanvas is not the main canvas');\n            }\n\n            return;\n        }\n\n        const { canvas } = this;\n\n        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height)\n        {\n            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n\n        const canvas = this.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            // #endif\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7184, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7190, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/buffer/const.ts"],"sourcesContent":["/**\n * Constants for various buffer types in Pixi\n * @see BUFFER_TYPE\n * @name BUFFER_TYPE\n * @static\n * @enum {number}\n * @property {number} ELEMENT_ARRAY_BUFFER - buffer type for using as an index buffer\n * @property {number} ARRAY_BUFFER - buffer type for using attribute data\n * @property {number} UNIFORM_BUFFER - the buffer type is for uniform buffer objects\n */\nexport enum BUFFER_TYPE\n{\n    ELEMENT_ARRAY_BUFFER = 34963,\n    ARRAY_BUFFER = 34962,\n    UNIFORM_BUFFER = 35345,\n}\n\n"],"names":["BUFFER_TYPE"],"mappings":";;;;AAUY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,uBAAA,GAAuB,KAAvB,CAAA,GAAA,sBAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,eAAA,GAAe,KAAf,CAAA,GAAA,cAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,iBAAA,GAAiB,KAAjB,CAAA,GAAA,gBAAA,CAAA;IAJQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 7202, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7208, "column": 0}, "map": {"version":3,"file":"GlBuffer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBuffer.ts"],"sourcesContent":["import type { BUFFER_TYPE } from './const';\n\nexport class GlBuffer\n{\n    public buffer: WebGLBuffer;\n    public updateID: number;\n    public byteLength: number;\n    public type: number;\n\n    public _lastBindBaseLocation: number = -1;\n    public _lastBindCallId: number = -1;\n\n    constructor(buffer: WebGLBuffer, type: BUFFER_TYPE)\n    {\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n}\n"],"names":[],"mappings":";;;;AAEO,MAAM,QACb,CAAA;IASI,WAAA,CAAY,MAAA,EAAqB,IACjC,CAAA;QAJA,IAAA,CAAO,qBAAgC,GAAA,CAAA,CAAA,CAAA;QACvC,IAAA,CAAO,eAA0B,GAAA,CAAA,CAAA,CAAA;QAI7B,IAAA,CAAK,MAAA,GAAS,MAAU,IAAA,IAAA,CAAA;QACxB,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA,CAAA;QAChB,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA,CAAA;QAClB,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;IAAA,CAChB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7224, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7230, "column": 0}, "map": {"version":3,"file":"GlBufferSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @memberof rendering\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private readonly _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this._gl = this._renderer.gl;\n\n        this._gpuBuffers = Object.create(null);\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7424, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7430, "column": 0}, "map": {"version":3,"file":"glUploadImageResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts"],"sourcesContent":["import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth || glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;AAMO,MAAM,qBAAwB,GAAA;IAEjC,EAAI,EAAA,OAAA;IAEJ,MAAO,EAAA,MAAA,EAAoC,SAAsB,EAAA,EAAA,EAAwB,YACzF,EAAA;QACU,MAAA,kBAAA,GAAqB,OAAO,SAAc,KAAA,6BAAA,CAAA;QAE7C,EAAA,CAAA,WAAA,CAAY,EAAG,CAAA,8BAAA,EAAgC,kBAAkB,CAAA,CAAA;QAEpE,MAAM,UAAU,SAAU,CAAA,KAAA,CAAA;QAC1B,MAAM,WAAW,SAAU,CAAA,MAAA,CAAA;QAE3B,MAAM,eAAe,MAAO,CAAA,UAAA,CAAA;QAC5B,MAAM,gBAAgB,MAAO,CAAA,WAAA,CAAA;QAE7B,MAAM,gBAAgB,MAAO,CAAA,aAAA,CAAA;QAC7B,MAAM,iBAAiB,MAAO,CAAA,cAAA,CAAA;QAE1B,IAAA,aAAA,GAAgB,YAAgB,IAAA,cAAA,GAAiB,aACrD,EAAA;YACQ,IAAA,OAAA,KAAY,YAAgB,IAAA,QAAA,KAAa,aAC7C,EAAA;gBACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,YAAA,EACA,aAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,IAAA;YACJ,CACJ;YAEA,IAAI,iBAAiB,CACrB,EAAA;gBACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,aAAA,EACA,cAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;YACX,CAGJ,MAAA;gBACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;YACX,CACJ;QAAA,CAEK,MAAA,IAAA,OAAA,KAAY,YAAgB,IAAA,QAAA,KAAa,aAClD,EAAA;YACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ,MAAA,IACS,iBAAiB,CAC1B,EAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,YAAA,EACA,aAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CAGJ,MAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ;QAEA,SAAA,CAAU,KAAQ,GAAA,YAAA,CAAA;QAClB,SAAA,CAAU,MAAS,GAAA,aAAA,CAAA;IAAA,CACvB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7467, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7473, "column": 0}, "map": {"version":3,"file":"glUploadBufferImageResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts"],"sourcesContent":["import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadBufferImageResource = {\n\n    id: 'buffer',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                source.width,\n                source.height,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;AAKO,MAAM,2BAA8B,GAAA;IAEvC,EAAI,EAAA,QAAA;IAEJ,MAAA,EAAO,MAAuB,EAAA,SAAA,EAAsB,EACpD,EAAA;QACI,IAAI,UAAU,KAAU,KAAA,MAAA,CAAO,KAAA,IAAS,SAAU,CAAA,MAAA,KAAW,OAAO,MACpE,EAAA;YACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,MAAO,CAAA,KAAA,EACP,MAAO,CAAA,MAAA,EACP,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CAGJ,MAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,MAAO,CAAA,KAAA,EACP,MAAO,CAAA,MAAA,EACP,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ;QAEA,SAAA,CAAU,KAAA,GAAQ,MAAO,CAAA,KAAA,CAAA;QACzB,SAAA,CAAU,MAAA,GAAS,MAAO,CAAA,MAAA,CAAA;IAAA,CAC9B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7497, "column": 0}, "map": {"version":3,"file":"glUploadVideoResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts"],"sourcesContent":["import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,qBAAwB,GAAA;IAEjC,EAAI,EAAA,OAAA;IAEJ,MAAO,EAAA,MAAA,EAAqB,SAAsB,EAAA,EAAA,EAAwB,YAC1E,EAAA;QACQ,IAAA,CAAC,OAAO,OACZ,EAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,IAAA;YAGJ,OAAA;QAAA,CACJ;4NAEA,wBAAA,CAAsB,MAAO,CAAA,MAAA,EAAQ,SAAW,EAAA,EAAA,EAAI,YAAY,CAAA,CAAA;IAAA,CACpE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7521, "column": 0}, "map": {"version":3,"file":"glUploadCompressedTextureResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts"],"sourcesContent":["import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7610, "column": 0}, "map": {"version":3,"file":"mapFormatToGlInternalFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7748, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7754, "column": 0}, "map": {"version":3,"file":"mapFormatToGlType.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n"],"names":[],"mappings":";;;;AASO,SAAS,kBAAkB,EAClC,EAAA;IACW,OAAA;QAAA,gBAAA;QAEH,SAAS,EAAG,CAAA,aAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QACZ,QAAQ,EAAG,CAAA,aAAA;QACX,QAAQ,EAAG,CAAA,IAAA;QAAA,iBAAA;QAGX,SAAS,EAAG,CAAA,cAAA;QACZ,SAAS,EAAG,CAAA,KAAA;QACZ,UAAU,EAAG,CAAA,UAAA;QACb,UAAU,EAAG,CAAA,aAAA;QACb,UAAU,EAAG,CAAA,IAAA;QACb,SAAS,EAAG,CAAA,aAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QAAA,iBAAA;QAGZ,SAAS,EAAG,CAAA,YAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,UAAU,EAAG,CAAA,KAAA;QACb,UAAU,EAAG,CAAA,cAAA;QACb,UAAU,EAAG,CAAA,KAAA;QACb,WAAW,EAAG,CAAA,UAAA;QACd,YAAY,EAAG,CAAA,aAAA;QACf,mBAAmB,EAAG,CAAA,aAAA;QAAA,wBAAA;QAGtB,YAAY,EAAG,CAAA,IAAA;QACf,WAAW,EAAG,CAAA,aAAA;QACd,WAAW,EAAG,CAAA,IAAA;QACd,YAAY,EAAG,CAAA,aAAA;QACf,mBAAmB,EAAG,CAAA,aAAA;QACtB,cAAc,EAAG,CAAA,wBAAA;QACjB,cAAc,EAAG,CAAA,2BAAA;QACjB,eAAe,EAAG,CAAA,4BAAA;QAAA,iBAAA;QAGlB,UAAU,EAAG,CAAA,YAAA;QACb,UAAU,EAAG,CAAA,GAAA;QACb,WAAW,EAAG,CAAA,KAAA;QACd,YAAY,EAAG,CAAA,cAAA;QACf,YAAY,EAAG,CAAA,KAAA;QACf,aAAa,EAAG,CAAA,UAAA;QAAA,kBAAA;QAGhB,YAAY,EAAG,CAAA,YAAA;QACf,YAAY,EAAG,CAAA,GAAA;QACf,aAAa,EAAG,CAAA,KAAA;QAAA,wBAAA;QAGhB,UAAU,EAAG,CAAA,aAAA;QACb,cAAc,EAAG,CAAA,cAAA;QACjB,aAAa,EAAG,CAAA,YAAA;QAChB,wBAAwB,EAAG,CAAA,iBAAA;QAC3B,cAAc,EAAG,CAAA,KAAA;QACjB,yBAAyB,EAAG,CAAA,8BAAA;IAAA,CAEhC,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7819, "column": 0}, "map": {"version":3,"file":"mapFormatToGlFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n"],"names":[],"mappings":";;;;AASO,SAAS,oBAAoB,EACpC,EAAA;IACW,OAAA;QAAA,gBAAA;QAEH,SAAS,EAAG,CAAA,GAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,QAAQ,EAAG,CAAA,GAAA;QACX,QAAQ,EAAG,CAAA,GAAA;QAAA,iBAAA;QAGX,SAAS,EAAG,CAAA,GAAA;QACZ,SAAY,EAAG,CAAA,GAAA;QACf,UAAU,EAAG,CAAA,GAAA;QACb,UAAW,EAAG,CAAA,EAAA;QACd,UAAY,EAAG,CAAA,EAAA;QACf,SAAU,EAAG,CAAA,EAAA;QACb,SAAU,EAAG,CAAA,EAAA;QAAA,iBAAA;QAGb,SAAS,EAAG,CAAA,GAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,UAAU,EAAG,CAAA,GAAA;QACb,UAAY,EAAG,CAAA,EAAA;QACf,UAAW,EAAG,CAAA,EAAA;QACd,WAAY,EAAG,CAAA,EAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,mBAAmB,EAAG,CAAA,IAAA;QAAA,wBAAA;QAGtB,YAAY,EAAG,CAAA,IAAA;QACf,WAAW,EAAG,CAAA,IAAA;QACd,WAAW,EAAG,CAAA,IAAA;QACd,YAAY,EAAG,CAAA,IAAA;QACf,mBAAmB,EAAG,CAAA,IAAA;QACtB,cAAc,EAAG,CAAA,GAAA;QACjB,cAAc,EAAG,CAAA,IAAA;QACjB,eAAe,EAAG,CAAA,GAAA;QAAA,iBAAA;QAGlB,UAAU,EAAG,CAAA,EAAA;QACb,UAAU,EAAG,CAAA,EAAA;QACb,WAAY,EAAG,CAAA,EAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,aAAa,EAAG,CAAA,IAAA;QAAA,kBAAA;QAGhB,YAAY,EAAG,CAAA,IAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,aAAa,EAAG,CAAA,IAAA;QAAA,wBAAA;QAGhB,UAAU,EAAG,CAAA,cAAA;QACb,cAAc,EAAG,CAAA,eAAA;QACjB,aAAa,EAAG,CAAA,eAAA;QAChB,wBAAwB,EAAG,CAAA,aAAA;QAC3B,cAAc,EAAG,CAAA,eAAA;QACjB,yBAAyB,EAAG,CAAA,aAAA;IAAA,CAEhC,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7878, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7884, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/const.ts"],"sourcesContent":["/**\n * Various GL texture/resources formats.\n * @static\n * @name FORMATS\n * @enum {number}\n * @property {number} [RGBA=6408] -\n * @property {number} [RGB=6407] -\n * @property {number} [RG=33319] -\n * @property {number} [RED=6403] -\n * @property {number} [RGBA_INTEGER=36249] -\n * @property {number} [RGB_INTEGER=36248] -\n * @property {number} [RG_INTEGER=33320] -\n * @property {number} [RED_INTEGER=36244] -\n * @property {number} [ALPHA=6406] -\n * @property {number} [LUMINANCE=6409] -\n * @property {number} [LUMINANCE_ALPHA=6410] -\n * @property {number} [DEPTH_COMPONENT=6402] -\n * @property {number} [DEPTH_STENCIL=34041] -\n */\nexport enum GL_FORMATS\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\n/**\n * Various GL target types.\n * @static\n * @name TARGETS\n * @enum {number}\n * @property {number} [TEXTURE_2D=3553] -\n * @property {number} [TEXTURE_CUBE_MAP=34067] -\n * @property {number} [TEXTURE_2D_ARRAY=35866] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_X=34069] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_X=34070] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_Y=34071] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_Y=34072] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_Z=34073] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_Z=34074] -\n */\nexport enum GL_TARGETS\n{\n    TEXTURE_2D = 3553,\n    TEXTURE_CUBE_MAP = 34067,\n    TEXTURE_2D_ARRAY = 35866,\n    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,\n}\n\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @name WRAP_MODES\n * @static\n * @enum {number}\n * @property {number} CLAMP - The textures uvs are clamped\n * @property {number} REPEAT - The texture uvs tile and repeat\n * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring\n */\nexport enum GL_WRAP_MODES\n{\n    CLAMP = 33071,\n    REPEAT = 10497,\n    MIRRORED_REPEAT = 33648,\n}\n\nexport enum GL_TYPES\n{\n    /**\n     * 8 bits per channel for gl.RGBA\n     * @default 5121\n     */\n    UNSIGNED_BYTE = 5121,\n    /**\n     * @default 5123\n     */\n    UNSIGNED_SHORT = 5123,\n    /**\n     * 5 red bits, 6 green bits, 5 blue bits.\n     * @default 33635\n     */\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    /**\n     * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n     * @default 32819\n     */\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    /**\n     * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n     * @default 32820\n     */\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    /**\n     * @default 5125\n     */\n    UNSIGNED_INT = 5125,\n    /**\n     * @default 35899\n     */\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    /**\n     * @default 33640\n     */\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    /**\n     * @default 34042\n     */\n    UNSIGNED_INT_24_8 = 34042,\n    /**\n     * @default 35902\n     */\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    /**\n     * @default 5120\n     */\n    BYTE = 5120,\n    /**\n     * @default 5122\n     */\n    SHORT = 5122,\n    /**\n     * @default 5124\n     */\n    INT = 5124,\n    /**\n     * @default 5126\n     */\n    FLOAT = 5126,\n    /**\n     * @default 36269\n     */\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    /**\n     * @default 36193\n     */\n    HALF_FLOAT = 36193,\n}\n\n"],"names":["GL_FORMATS","GL_TARGETS","GL_WRAP_MODES","GL_TYPES"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7946, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7952, "column": 0}, "map": {"version":3,"file":"GlTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts"],"sourcesContent":["import { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @memberof rendering\n * @ignore\n */\nexport class GlTexture\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,SACb,CAAA;IA0BI,YAAY,OACZ,CAAA;QA1BA,IAAA,CAAO,MAAA,0LAAqB,aAAW,CAAA,UAAA,CAAA;QA2BnC,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;QACf,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA,CAAA;QACb,IAAA,CAAK,MAAS,GAAA,CAAA,CAAA,CAAA;QACd,IAAA,CAAK,IAAA,0LAAO,WAAS,CAAA,aAAA,CAAA;QACrB,IAAA,CAAK,cAAA,0LAAiB,aAAW,CAAA,IAAA,CAAA;QACjC,IAAA,CAAK,MAAA,0LAAS,aAAW,CAAA,IAAA,CAAA;QACzB,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA;IAAA,CACvB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7978, "column": 0}, "map": {"version":3,"file":"pixiToGlMaps.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/pixiToGlMaps.ts"],"sourcesContent":["export const scaleModeToGlFilter = {\n    linear: 9729,\n    nearest: 9728,\n};\n\nexport const mipmapScaleModeToGlFilter = {\n    linear: {\n        linear: 9987,\n        nearest: 9985,\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984,\n    }\n};\n\nexport const wrapModeToGlAddress = {\n    'clamp-to-edge': 33071,\n    repeat: 10497,\n    'mirror-repeat': 33648,\n};\n\nexport const compareModeToGlCompare = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519,\n};\n\n"],"names":[],"mappings":";;;;;;;AAAO,MAAM,mBAAsB,GAAA;IAC/B,MAAQ,EAAA,IAAA;IACR,OAAS,EAAA,IAAA;AACb,EAAA;AAEO,MAAM,yBAA4B,GAAA;IACrC,MAAQ,EAAA;QACJ,MAAQ,EAAA,IAAA;QACR,OAAS,EAAA,IAAA;IAAA,CACb;IACA,OAAS,EAAA;QACL,MAAQ,EAAA,IAAA;QACR,OAAS,EAAA,IAAA;IAAA,CACb;AACJ,EAAA;AAEO,MAAM,mBAAsB,GAAA;IAC/B,eAAiB,EAAA,KAAA;IACjB,MAAQ,EAAA,KAAA;IACR,eAAiB,EAAA,KAAA;AACrB,EAAA;AAEO,MAAM,sBAAyB,GAAA;IAClC,KAAO,EAAA,GAAA;IACP,IAAM,EAAA,GAAA;IACN,KAAO,EAAA,GAAA;IACP,YAAc,EAAA,GAAA;IACd,OAAS,EAAA,GAAA;IACT,WAAa,EAAA,GAAA;IACb,eAAiB,EAAA,GAAA;IACjB,MAAQ,EAAA,GAAA;AACZ","ignoreList":[0]}},
    {"offset": {"line": 8016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8022, "column": 0}, "map": {"version":3,"file":"applyStyleParams.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts"],"sourcesContent":["import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n"],"names":[],"mappings":";;;;;;AASgB,SAAA,gBAAA,CACZ,KAAA,EACA,EACA,EAAA,OAAA,EAEA,cAAA,EACA,cACA,EAAA,UAAA,EACA,UAAA,EAEA,aAEJ,EAAA;IACI,MAAM,SAAY,GAAA,UAAA,CAAA;IAEd,IAAA,CAAC,aACE,IAAA,KAAA,CAAM,YAAiB,KAAA,QAAA,IACvB,MAAM,YAAiB,KAAA,QAAA,IACvB,KAAM,CAAA,YAAA,KAAiB,QAE9B,EAAA;QAEI,MAAM,SAAY,0MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QACvF,MAAM,SAAY,0MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QACvF,MAAM,SAAY,0MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QAEvF,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;QAC1D,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;QAG1D,IAAI,EAAG,CAAA,cAAA,EAAgB,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;IAAA,CACrF;IAEA,IAAI,CAAC,aAAA,IAAiB,KAAM,CAAA,SAAA,KAAc,QAC1C,EAAA;QAEO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,yMAAoB,sBAAoB,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA,CAAA;IAAA,CAC7F;IAIA,IAAI,OACJ,EAAA;QACI,IAAI,CAAC,aAAA,IAAiB,KAAM,CAAA,YAAA,KAAiB,QAC7C,EAAA;YACI,MAAM,sNAAe,4BAA0B,CAAA,KAAA,CAAM,SAAS,CAAA,CAAE,MAAM,YAAY,CAAA,CAAA;YAElF,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,EAAoB,YAAY,CAAA,CAAA;QAAA,CACrE;IAAA,CAIJ,MAAA;QACO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,yMAAoB,sBAAoB,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA,CAAA;IAAA,CAC7F;IAGI,IAAA,cAAA,IAAkB,KAAM,CAAA,aAAA,GAAgB,CAC5C,EAAA;QACU,MAAA,KAAA,GAAQ,KAAK,GAAI,CAAA,KAAA,CAAM,aAAA,EAAe,EAAG,CAAA,YAAA,CAAa,cAAe,CAAA,8BAA8B,CAAC,CAAA,CAAA;QAE1G,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,cAAA,CAAe,0BAAA,EAA4B,KAAK,CAAA,CAAA;IAAA,CAClF;IAGA,IAAI,MAAM,OACV,EAAA;QACO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,oBAAA,yMAAsB,yBAAuB,CAAA,KAAA,CAAM,OAAO,CAAC,CAAA,CAAA;IAAA,CAChG;AACJ","ignoreList":[0]}},
    {"offset": {"line": 8059, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8065, "column": 0}, "map": {"version":3,"file":"GlTextureSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @memberof rendering\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_glTextures');\n        this._renderer.renderableGC.addManagedHash(this, '_glSamplers');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source ||= Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        (this._renderer as null) = null;\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8321, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8327, "column": 0}, "map": {"version":3,"file":"GlRenderTarget.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlRenderTarget.ts"],"sourcesContent":["/**\n * Represents a render target.\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTarget\n{\n    public width = -1;\n    public height = -1;\n    public msaa = false;\n    public framebuffer: WebGLFramebuffer;\n    public resolveTargetFramebuffer: WebGLFramebuffer;\n    public msaaRenderBuffer: WebGLRenderbuffer[] = [];\n    public depthStencilRenderBuffer: WebGLRenderbuffer;\n}\n"],"names":[],"mappings":";;;;AAKO,MAAM,cACb,CAAA;IADO,WAAA,EAAA;QAEH,IAAA,CAAO,KAAQ,GAAA,CAAA,CAAA,CAAA;QACf,IAAA,CAAO,MAAS,GAAA,CAAA,CAAA,CAAA;QAChB,IAAA,CAAO,IAAO,GAAA,KAAA,CAAA;QAGd,IAAA,CAAO,gBAAA,GAAwC,EAAC,CAAA;IAAA,CAAA;AAEpD","ignoreList":[0]}},
    {"offset": {"line": 8341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8347, "column": 0}, "map": {"version":3,"file":"GlRenderTargetAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts"],"sourcesContent":["import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        const colorTexture = renderTarget.colorTexture;\n\n        if (colorTexture.resource === renderer.canvas)\n        {\n            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil || renderTarget.depth)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n\n    public prerender(renderTarget: RenderTarget)\n    {\n        const resource = renderTarget.colorTexture.resource;\n\n        // if the render target is a canvas, ensure its size matches the source\n        if (this._renderer.context.multiView && CanvasSource.test(resource))\n        {\n            this._renderer.context.ensureCanvasSize(resource);\n        }\n    }\n\n    public postrender(renderTarget: RenderTarget)\n    {\n        // if multiView is not enabled, we don't need to do anything\n        if (!this._renderer.context.multiView) return;\n\n        // if the render target is a canvas, we need to copy the pixels from the gl canvas\n        // to the canvas target\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            const contextCanvas = this._renderer.context.canvas;\n            const canvasSource = renderTarget.colorTexture as unknown as CanvasSource;\n\n            canvasSource.context2D.drawImage(\n                contextCanvas as CanvasImageSource,\n                0, canvasSource.pixelHeight - contextCanvas.height\n            );\n        }\n    }\n}\n"],"names":["source"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8591, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8597, "column": 0}, "map": {"version":3,"file":"isRenderingToScreen.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts"],"sourcesContent":["import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n"],"names":[],"mappings":";;;;AAQO,SAAS,oBAAoB,YACpC,EAAA;IACU,MAAA,QAAA,GAAW,YAAa,CAAA,YAAA,CAAa,MAAO,CAAA,QAAA,CAAA;IAElD,OAAS,WAAW,iBAAqB,IAAA,QAAA,YAAoB,qBAAsB,QAAS,CAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,CAAA,CAAA;AACtH","ignoreList":[0]}},
    {"offset": {"line": 8607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8613, "column": 0}, "map": {"version":3,"file":"calculateProjection.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts"],"sourcesContent":["import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n"],"names":[],"mappings":";;;;AAEO,SAAS,oBACZ,EACA,EAAA,CAAA,EACA,CACA,EAAA,KAAA,EACA,MAAA,EACA,KAEJ,EAAA;IACU,MAAA,IAAA,GAAO,QAAQ,CAAI,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAG,QAAS,EAAA,CAAA;IAET,EAAA,CAAA,CAAA,GAAK,IAAI,KAAQ,GAAA,CAAA,CAAA;IACjB,EAAA,CAAA,CAAA,GAAI,IAAQ,GAAA,CAAA,CAAA,GAAI,MAAS,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAA,EAAA,GAAK,CAAM,CAAA,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IACrB,EAAA,CAAG,EAAK,GAAA,CAAC,IAAQ,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IAEjB,OAAA,EAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 8628, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8634, "column": 0}, "map": {"version":3,"file":"RenderTargetSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8881, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8887, "column": 0}, "map": {"version":3,"file":"GlRenderTargetSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAWO,MAAM,0OAA6B,qBAC1C,CAAA;IASI,YAAY,QACZ,CAAA;QACI,KAAA,CAAM,QAAQ,CAAA,CAAA;QAJX,IAAA,CAAA,OAAA,GAAU,gNAAI,wBAAsB,EAAA,CAAA;QAMlC,IAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,QAAA,EAAU,IAAI,CAAA,CAAA;IAAA,CACpC;AACJ,CAAA;AAAA,YAAA,GAhBa,oBAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;uKAAC,gBAAA,CAAc,WAAW;KAAA;IAChC,IAAM,EAAA,cAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 8912, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8918, "column": 0}, "map": {"version":3,"file":"ensureAttributes.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAiBgB,SAAA,gBAAA,CACZ,QAAA,EACA,aAEJ,EAAA;IACe,IAAA,MAAA,CAAA,IAAK,SAAS,UACzB,CAAA;QACU,MAAA,SAAA,GAAY,QAAS,CAAA,UAAA,CAAW,CAAC,CAAA,CAAA;QACjC,MAAA,aAAA,GAAgB,aAAA,CAAc,CAAC,CAAA,CAAA;QAErC,IAAI,aACJ,EAAA;YACc,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,QAAA,IAAA,CAAV,SAAU,CAAA,QAAA,GAAa,aAAc,CAAA,QAAA,CAAA,CAAA;QAAA,CAGzC,MAAA;aAES,yKAAA,EAAA,CAAA,UAAA,EAAa,CAAC,CAAmG,iGAAA,CAAA,CAAA,CAAA;QAAA,CAC1H;IAAA,CACJ;IAEA,oBAAA,CAAqB,QAAQ,CAAA,CAAA;AACjC,CAAA;AAEA,SAAS,qBAAqB,QAC9B,EAAA;IACU,MAAA,EAAE,OAAS,EAAA,UAAA,EAAe,GAAA,QAAA,CAAA;IAEhC,MAAM,aAAqC,CAAA,CAAC,CAAA;IAC5C,MAAM,YAAoC,CAAA,CAAC,CAAA;IAE3C,IAAA,MAAW,KAAK,OAChB,CAAA;QACU,MAAA,MAAA,GAAS,OAAA,CAAQ,CAAC,CAAA,CAAA;QAEb,UAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;QACf,SAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;IAAA,CAC5B;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,UAAA,CAAW,UAAU,MAAO,CAAA,GAAG,CAAA,KAAK,0PAAA,AAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACrF;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,SAAA,CAAU,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,UAAW,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAEpD,SAAA,CAAU,KAAA,IAAA,CAAV,SAAU,CAAA,KAAA,GAAU,SAAU,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAElD,SAAA,CAAU,UAAU,MAAO,CAAA,GAAG,CAAA,kOAAK,6BAAA,AAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACpF;AACJ","ignoreList":[0]}},
    {"offset": {"line": 8962, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8968, "column": 0}, "map": {"version":3,"file":"getGlTypeFromFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts"],"sourcesContent":["import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n"],"names":[],"mappings":";;;;;;AAIA,MAAM,OAAU,GAAA;IACZ,gMAAS,WAAS,CAAA,aAAA;IAClB,gMAAS,WAAS,CAAA,aAAA;IAClB,gMAAS,WAAS,CAAA,IAAA;IAClB,gMAAS,WAAS,CAAA,IAAA;IAClB,iMAAU,WAAS,CAAA,aAAA;IACnB,iMAAU,WAAS,CAAA,aAAA;IACnB,iMAAU,WAAS,CAAA,IAAA;IACnB,iMAAU,WAAS,CAAA,IAAA;IACnB,iMAAU,WAAS,CAAA,cAAA;IACnB,iMAAU,WAAS,CAAA,cAAA;IACnB,iMAAU,WAAS,CAAA,KAAA;IACnB,iMAAU,WAAS,CAAA,KAAA;IACnB,kMAAW,WAAS,CAAA,cAAA;IACpB,kMAAW,WAAS,CAAA,cAAA;IACpB,kMAAW,WAAS,CAAA,KAAA;IACpB,kMAAW,WAAS,CAAA,KAAA;IACpB,kMAAW,WAAS,CAAA,UAAA;IACpB,kMAAW,WAAS,CAAA,UAAA;IACpB,gMAAS,WAAS,CAAA,KAAA;IAClB,kMAAW,WAAS,CAAA,KAAA;IACpB,kMAAW,WAAS,CAAA,KAAA;IACpB,kMAAW,WAAS,CAAA,KAAA;IACpB,+LAAQ,WAAS,CAAA,YAAA;IACjB,iMAAU,WAAS,CAAA,YAAA;IACnB,iMAAU,WAAS,CAAA,YAAA;IACnB,iMAAU,WAAS,CAAA,YAAA;IACnB,+LAAQ,WAAS,CAAA,GAAA;IACjB,iMAAU,WAAS,CAAA,GAAA;IACnB,iMAAU,WAAS,CAAA,GAAA;IACnB,iMAAU,WAAS,CAAA,GAAA;AACvB,CAAA,CAAA;AAEO,SAAS,oBAAoB,MACpC,EAAA;IACW,OAAA,OAAA,CAAQ,MAAM,CAAA,IAAK,OAAQ,CAAA,OAAA,CAAA;AACtC","ignoreList":[0]}},
    {"offset": {"line": 9011, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9017, "column": 0}, "map": {"version":3,"file":"GlGeometrySystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof rendering\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n\n        this._renderer.renderableGC.addManagedHash(this, '_geometryVaoHash');\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader ||= this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = programAttrib.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        // Can't use truthiness check to determine if divisor is set,\n                        // since 0 is a valid value for divisor\n                        const divisor = attribute.divisor ?? 1;\n\n                        gl.vertexAttribDivisor(location, divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[topology || geometry.topology];\n\n        instanceCount ??= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9296, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9302, "column": 0}, "map": {"version":3,"file":"BufferResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AA0BO,MAAM,6MAAuB,UAGpC,CAAA;IAAA;;;;;;;;GAAA,GA2DI,WAAY,CAAA,EAAE,MAAQ,EAAA,MAAA,EAAQ,IAAA,EAC9B,CAAA;QACU,KAAA,EAAA,CAAA;QArDV;;;;KAAA,GAAA,iEAAA,GAAgB,IAAA,CAAA,GAAA,kKAAc,MAAA,EAAI,QAAQ,CAAA,CAAA;QAO1C;;;;KAAA,GAAA,IAAA,CAAgB,aAAgB,GAAA,gBAAA,CAAA;QAOhC;;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAOlB;;;;KAAA,GAAO,IAAA,CAAA,WAAA,kKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAanC;;;;KAAA,GAAA,IAAA,CAAgB,eAAkB,GAAA,IAAA,CAAA;QAMlC;;;KAAA,GAAA,IAAA,CAAO,SAAY,GAAA,KAAA,CAAA;QAef,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QACd,IAAA,CAAK,MAAA,GAAS,MAAS,GAAA,CAAA,CAAA;QACvB,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QAEZ,IAAA,CAAK,MAAO,CAAA,EAAA,CAAG,QAAU,EAAA,IAAA,CAAK,cAAA,EAAgB,IAAI,CAAA,CAAA;IAAA,CACtD;IAEU,cACV,GAAA;QACS,IAAA,CAAA,WAAA,kKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAE5B,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOO,OAAA,CAAQ,gBAAgB,KAC/B,EAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QAEjB,IAAI,aACJ,EAAA;YACI,IAAA,CAAK,MAAA,CAAO,OAAQ,EAAA,CAAA;QAAA,CACxB;QAEK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;QAExB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 9375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9381, "column": 0}, "map": {"version":3,"file":"generateUniformsSyncTypes.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.ts"],"sourcesContent":["// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport type { UNIFORM_TYPES } from '../../../shared/shader/types';\n\nexport type ArraySetterFunction = (v: any, location: WebGLUniformLocation, gl: any) => void;\n\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n};\n\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `gl.uniform1fv(location, v);`,\n    'vec2<f32>': `gl.uniform2fv(location, v);`,\n    'vec3<f32>': `gl.uniform3fv(location, v);`,\n    'vec4<f32>': `gl.uniform4fv(location, v);`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    'vec2<i32>': `gl.uniform2iv(location, v);`,\n    'vec3<i32>': `gl.uniform3iv(location, v);`,\n    'vec4<i32>': `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    'vec2<u32>': `gl.uniform2iv(location, v);`,\n    'vec3<u32>': `gl.uniform3iv(location, v);`,\n    'vec4<u32>': `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    'vec2<bool>': `gl.uniform2iv(location, v);`,\n    'vec3<bool>': `gl.uniform3iv(location, v);`,\n    'vec4<bool>': `gl.uniform4iv(location, v);`,\n};\n"],"names":[],"mappings":";;;;;AAUO,MAAM,yBAAoE,GAAA;IAC7E,GAAK,EAAA,CAAA;;;SAAA,CAAA;IAIL,WAAa,EAAA,CAAA;;;;SAAA,CAAA;IAKb,WAAa,EAAA,CAAA;;;;;SAAA,CAAA;IAMb,WAAa,EAAA,CAAA;;;;;;SAAA,CAAA;IAOb,GAAK,EAAA,CAAA;;;SAAA,CAAA;IAIL,WAAa,EAAA,CAAA;;;;SAAA,CAAA;IAKb,WAAa,EAAA,CAAA;;;;;SAAA,CAAA;IAMb,WAAa,EAAA,CAAA;;;;;;SAAA,CAAA;IAOb,GAAK,EAAA,CAAA;;;SAAA,CAAA;IAIL,WAAa,EAAA,CAAA;;;;SAAA,CAAA;IAKb,WAAa,EAAA,CAAA;;;;;SAAA,CAAA;IAMb,WAAa,EAAA,CAAA;;;;;;SAAA,CAAA;IAOb,IAAM,EAAA,CAAA;;;SAAA,CAAA;IAIN,YAAc,EAAA,CAAA;;;;SAAA,CAAA;IAKd,YAAc,EAAA,CAAA;;;;;SAAA,CAAA;IAMd,YAAc,EAAA,CAAA;;;;;;SAAA,CAAA;IAOd,aAAe,EAAA,CAAA,wCAAA,CAAA;IACf,aAAe,EAAA,CAAA,wCAAA,CAAA;IACf,aAAe,EAAA,CAAA,wCAAA,CAAA;AACnB,EAAA;AAEO,MAAM,wBAAmE,GAAA;IAC5E,GAAK,EAAA,CAAA,2BAAA,CAAA;IACL,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,aAAe,EAAA,CAAA,wCAAA,CAAA;IACf,aAAe,EAAA,CAAA,wCAAA,CAAA;IACf,aAAe,EAAA,CAAA,wCAAA,CAAA;IACf,GAAK,EAAA,CAAA,2BAAA,CAAA;IACL,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,GAAK,EAAA,CAAA,2BAAA,CAAA;IACL,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,WAAa,EAAA,CAAA,2BAAA,CAAA;IACb,IAAM,EAAA,CAAA,2BAAA,CAAA;IACN,YAAc,EAAA,CAAA,2BAAA,CAAA;IACd,YAAc,EAAA,CAAA,2BAAA,CAAA;IACd,YAAc,EAAA,CAAA,2BAAA,CAAA;AAClB","ignoreList":[0]}},
    {"offset": {"line": 9502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9508, "column": 0}, "map": {"version":3,"file":"generateUniformsSync.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts"],"sourcesContent":["// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAagB,SAAA,oBAAA,CAAqB,KAAA,EAAqB,WAC1D,EAAA;IACI,MAAM,gBAAgB;QAAC,CAAA;;;;;;;IAOtB,CAAA;KAAA,CAAA;IAEU,IAAA,MAAA,CAAA,IAAK,MAAM,QACtB,CAAA;QACQ,IAAA,CAAC,WAAY,CAAA,CAAC,CAClB,EAAA;YACI,IAAI,KAAM,CAAA,QAAA,CAAS,CAAC,CAAA,6MAAa,eACjC,EAAA;gBACI,IAAK,KAAM,CAAA,QAAA,CAAS,CAAC,CAAA,CAAmB,GACxC,EAAA;oBACI,aAAA,CAAc,IAAK,CAAA,CAAA;4DACuB,EAAA,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA;oBACjD,CAAA,CAAA,CAAA;gBAAA,CAGL,MAAA;oBACI,aAAA,CAAc,IAAK,CAAA,CAAA;8DAAA,EACyB,CAAC,CAAA;oBAC5C,CAAA,CAAA,CAAA;gBAAA,CACL;YAAA,CAEK,MAAA,IAAA,KAAA,CAAM,QAAS,CAAA,CAAC,CAAA,+MAAa,iBACtC,EAAA;gBACI,aAAA,CAAc,IAAK,CAAA,CAAA;8DAC6B,EAAA,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA;oBACnD,CAAA,CAAA,CAAA;YAAA,CACT;YAEA,SAAA;QAAA,CACJ;QAEM,MAAA,OAAA,GAAU,KAAM,CAAA,iBAAA,CAAkB,CAAC,CAAA,CAAA;QAEzC,IAAI,MAAS,GAAA,KAAA,CAAA;QAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,+MAAA,iBAAA,CAAe,MAAA,EAAQ,CAC3C,EAAA,CAAA;YACU,MAAA,MAAA,8MAAS,kBAAA,CAAe,CAAC,CAAA,CAAA;YAE/B,IAAI,QAAQ,IAAS,KAAA,MAAA,CAAO,IAAA,IAAQ,MAAO,CAAA,IAAA,CAAK,OAAO,CACvD,EAAA;gBACI,aAAA,CAAc,IAAA,CAAK,CAAW,QAAA,EAAA,CAAC,CAAA,EAAA,CAAA,8MAAM,iBAAe,CAAA,CAAC,CAAA,CAAE,OAAO,CAAA,CAAA;gBACrD,MAAA,GAAA,IAAA,CAAA;gBAET,MAAA;YAAA,CACJ;QAAA,CACJ;QAEA,IAAI,CAAC,MACL,EAAA;YACI,MAAM,YAAe,GAAA,OAAA,CAAQ,IAAS,KAAA,CAAA,sNAAI,4BAA4B,qNAAA,4BAAA,CAAA;YAEhE,MAAA,QAAA,GAAW,YAAA,CAAa,OAAQ,CAAA,IAAI,CAAA,CAAE,OAAQ,CAAA,UAAA,EAAY,CAAO,IAAA,EAAA,CAAC,CAAa,WAAA,CAAA,CAAA,CAAA;YAErF,aAAA,CAAc,IAAK,CAAA,CAAA;qBAAA,EACR,CAAC,CAAA;;oBAAA,EAEF,CAAC,CAAA;YAAA,EACT,QAAQ,CAAG,CAAA,CAAA,CAAA,CAAA;QAAA,CACjB;IAAA,CACJ;IASO,OAAA,IAAI,SAAS,IAAM,EAAA,IAAA,EAAM,YAAY,UAAY,EAAA,aAAA,CAAc,IAAK,CAAA,IAAI,CAAC,CAAA,CAAA;AACpF","ignoreList":[0]}},
    {"offset": {"line": 9574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9580, "column": 0}, "map": {"version":3,"file":"GlUniformGroupSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @memberof rendering\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @member {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9671, "column": 0}, "map": {"version":3,"file":"compileShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/compileShader.ts"],"sourcesContent":["/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    return shader;\n}\n"],"names":[],"mappings":";;;;AAOgB,SAAA,aAAA,CAAc,EAA+B,EAAA,IAAA,EAAc,GAC3E,EAAA;IACU,MAAA,MAAA,GAAS,EAAG,CAAA,YAAA,CAAa,IAAI,CAAA,CAAA;IAEhC,EAAA,CAAA,YAAA,CAAa,QAAQ,GAAG,CAAA,CAAA;IAC3B,EAAA,CAAG,aAAA,CAAc,MAAM,CAAA,CAAA;IAEhB,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 9683, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9689, "column": 0}, "map": {"version":3,"file":"logProgramError.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/logProgramError.ts"],"sourcesContent":["/**\n * will log a shader error highlighting the lines with the error\n * also will add numbers along the side.\n * @param gl - the WebGLContext\n * @param shader - the shader to log errors for\n */\nfunction logPrettyShaderError(gl: WebGLRenderingContext, shader: WebGLShader): void\n{\n    const shaderSrc = gl.getShaderSource(shader)\n        .split('\\n')\n        .map((line, index) => `${index}: ${line}`);\n\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split('\\n');\n\n    const dedupe: Record<number, boolean> = {};\n\n    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, '$1')))\n        .filter((n) =>\n        {\n            if (n && !dedupe[n])\n            {\n                dedupe[n] = true;\n\n                return true;\n            }\n\n            return false;\n        });\n\n    const logArgs = [''];\n\n    lineNumbers.forEach((number) =>\n    {\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');\n    });\n\n    const fragmentSourceToLog = shaderSrc\n        .join('\\n');\n\n    logArgs[0] = fragmentSourceToLog;\n\n    console.error(shaderLog);\n\n    // eslint-disable-next-line no-console\n    console.groupCollapsed('click to view full shader code');\n    console.warn(...logArgs);\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n}\n\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram,\n    vertexShader: WebGLShader,\n    fragmentShader: WebGLShader\n): void\n{\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, vertexShader);\n        }\n\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, fragmentShader);\n        }\n\n        console.error('PixiJS Error: Could not initialize shader.');\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('PixiJS Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAMA,SAAS,oBAAA,CAAqB,EAAA,EAA2B,MACzD,EAAA;IACI,MAAM,YAAY,EAAG,CAAA,eAAA,CAAgB,MAAM,CAAA,CACtC,KAAA,CAAM,IAAI,CAAA,CACV,GAAI,CAAA,CAAC,MAAM,KAAU,GAAA,CAAA,EAAG,KAAK,CAAA,EAAA,EAAK,IAAI,CAAE,CAAA,CAAA,CAAA;IAEvC,MAAA,SAAA,GAAY,EAAG,CAAA,gBAAA,CAAiB,MAAM,CAAA,CAAA;IACtC,MAAA,WAAA,GAAc,SAAU,CAAA,KAAA,CAAM,IAAI,CAAA,CAAA;IAExC,MAAM,SAAkC,CAAA,CAAC,CAAA;IAEzC,MAAM,WAAc,GAAA,WAAA,CAAY,GAAI,CAAA,CAAC,OAAS,UAAW,CAAA,IAAA,CAAK,OAAQ,CAAA,0BAAA,EAA4B,IAAI,CAAC,CAAC,CACnG,CAAA,MAAA,CAAO,CAAC,CACT,KAAA;QACI,IAAI,CAAK,IAAA,CAAC,MAAO,CAAA,CAAC,CAClB,EAAA;YACI,MAAA,CAAO,CAAC,CAAI,GAAA,IAAA,CAAA;YAEL,OAAA,IAAA,CAAA;QAAA,CACX;QAEO,OAAA,KAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEC,MAAA,OAAA,GAAU;QAAC,EAAE;KAAA,CAAA;IAEP,WAAA,CAAA,OAAA,CAAQ,CAAC,MACrB,KAAA;QACI,SAAA,CAAU,SAAS,CAAC,CAAA,GAAI,CAAA,EAAA,EAAK,SAAU,CAAA,MAAA,GAAS,CAAC,CAAC,CAAA,EAAA,CAAA,CAAA;QAC1C,OAAA,CAAA,IAAA,CAAK,uDAAuD,iBAAiB,CAAA,CAAA;IAAA,CACxF,CAAA,CAAA;IAEK,MAAA,mBAAA,GAAsB,SACvB,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IAEd,OAAA,CAAQ,CAAC,CAAI,GAAA,mBAAA,CAAA;IAEb,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA,CAAA;IAGvB,OAAA,CAAQ,cAAA,CAAe,gCAAgC,CAAA,CAAA;IAC/C,OAAA,CAAA,IAAA,CAAK,GAAG,OAAO,CAAA,CAAA;IAEvB,OAAA,CAAQ,QAAS,EAAA,CAAA;AACrB,CAAA;AAWO,SAAS,eACZ,CAAA,EAAA,EACA,OACA,EAAA,YAAA,EACA,cAEJ,EAAA;IAEI,IAAI,CAAC,EAAG,CAAA,mBAAA,CAAoB,OAAS,EAAA,EAAA,CAAG,WAAW,CACnD,EAAA;QACI,IAAI,CAAC,EAAG,CAAA,kBAAA,CAAmB,YAAc,EAAA,EAAA,CAAG,cAAc,CAC1D,EAAA;YACI,oBAAA,CAAqB,IAAI,YAAY,CAAA,CAAA;QAAA,CACzC;QAEA,IAAI,CAAC,EAAG,CAAA,kBAAA,CAAmB,cAAgB,EAAA,EAAA,CAAG,cAAc,CAC5D,EAAA;YACI,oBAAA,CAAqB,IAAI,cAAc,CAAA,CAAA;QAAA,CAC3C;QAEA,OAAA,CAAQ,KAAA,CAAM,4CAA4C,CAAA,CAAA;QAG1D,IAAI,EAAG,CAAA,iBAAA,CAAkB,OAAO,CAAA,KAAM,EACtC,EAAA;YACI,OAAA,CAAQ,IAAK,CAAA,wCAAA,EAA0C,EAAG,CAAA,iBAAA,CAAkB,OAAO,CAAC,CAAA,CAAA;QAAA,CACxF;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 9735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9741, "column": 0}, "map": {"version":3,"file":"mapType.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/mapType.ts"],"sourcesContent":["import type { Dict } from '../../../../../utils/types';\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nlet GL_TABLE: Dict<string> = null;\n\nconst GL_TO_GLSL_TYPES: Dict<string> = {\n    FLOAT:       'float',\n    FLOAT_VEC2:  'vec2',\n    FLOAT_VEC3:  'vec3',\n    FLOAT_VEC4:  'vec4',\n\n    INT:         'int',\n    INT_VEC2:    'ivec2',\n    INT_VEC3:    'ivec3',\n    INT_VEC4:    'ivec4',\n\n    UNSIGNED_INT:         'uint',\n    UNSIGNED_INT_VEC2:    'uvec2',\n    UNSIGNED_INT_VEC3:    'uvec3',\n    UNSIGNED_INT_VEC4:    'uvec4',\n\n    BOOL:        'bool',\n    BOOL_VEC2:   'bvec2',\n    BOOL_VEC3:   'bvec3',\n    BOOL_VEC4:   'bvec4',\n\n    FLOAT_MAT2:  'mat2',\n    FLOAT_MAT3:  'mat3',\n    FLOAT_MAT4:  'mat4',\n\n    SAMPLER_2D:              'sampler2D',\n    INT_SAMPLER_2D:          'sampler2D',\n    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',\n    SAMPLER_CUBE:              'samplerCube',\n    INT_SAMPLER_CUBE:          'samplerCube',\n    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',\n    SAMPLER_2D_ARRAY:              'sampler2DArray',\n    INT_SAMPLER_2D_ARRAY:          'sampler2DArray',\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',\n};\n\nconst GLSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    float: 'float32',\n    vec2: 'float32x2',\n    vec3: 'float32x3',\n    vec4: 'float32x4',\n\n    int: 'sint32',\n    ivec2: 'sint32x2',\n    ivec3: 'sint32x3',\n    ivec4: 'sint32x4',\n\n    uint: 'uint32',\n    uvec2: 'uint32x2',\n    uvec3: 'uint32x3',\n    uvec4: 'uint32x4',\n\n    bool: 'uint32',\n    bvec2: 'uint32x2',\n    bvec3: 'uint32x3',\n    bvec4: 'uint32x4',\n};\n\nexport function mapType(gl: any, type: number): string\n{\n    if (!GL_TABLE)\n    {\n        const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n\n        GL_TABLE = {};\n\n        for (let i = 0; i < typeNames.length; ++i)\n        {\n            const tn = typeNames[i];\n\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n        }\n    }\n\n    return GL_TABLE[type];\n}\n\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat\n{\n    const typeValue = mapType(gl, type);\n\n    return GLSL_TO_VERTEX_TYPES[typeValue] || 'float32';\n}\n"],"names":[],"mappings":";;;;;AAGA,IAAI,QAAyB,GAAA,IAAA,CAAA;AAE7B,MAAM,gBAAiC,GAAA;IACnC,KAAa,EAAA,OAAA;IACb,UAAa,EAAA,MAAA;IACb,UAAa,EAAA,MAAA;IACb,UAAa,EAAA,MAAA;IAEb,GAAa,EAAA,KAAA;IACb,QAAa,EAAA,OAAA;IACb,QAAa,EAAA,OAAA;IACb,QAAa,EAAA,OAAA;IAEb,YAAsB,EAAA,MAAA;IACtB,iBAAsB,EAAA,OAAA;IACtB,iBAAsB,EAAA,OAAA;IACtB,iBAAsB,EAAA,OAAA;IAEtB,IAAa,EAAA,MAAA;IACb,SAAa,EAAA,OAAA;IACb,SAAa,EAAA,OAAA;IACb,SAAa,EAAA,OAAA;IAEb,UAAa,EAAA,MAAA;IACb,UAAa,EAAA,MAAA;IACb,UAAa,EAAA,MAAA;IAEb,UAAyB,EAAA,WAAA;IACzB,cAAyB,EAAA,WAAA;IACzB,uBAAyB,EAAA,WAAA;IACzB,YAA2B,EAAA,aAAA;IAC3B,gBAA2B,EAAA,aAAA;IAC3B,yBAA2B,EAAA,aAAA;IAC3B,gBAA+B,EAAA,gBAAA;IAC/B,oBAA+B,EAAA,gBAAA;IAC/B,6BAA+B,EAAA,gBAAA;AACnC,CAAA,CAAA;AAEA,MAAM,oBAAqD,GAAA;IAEvD,KAAO,EAAA,SAAA;IACP,IAAM,EAAA,WAAA;IACN,IAAM,EAAA,WAAA;IACN,IAAM,EAAA,WAAA;IAEN,GAAK,EAAA,QAAA;IACL,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;IAEP,IAAM,EAAA,QAAA;IACN,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;IAEP,IAAM,EAAA,QAAA;IACN,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;IACP,KAAO,EAAA,UAAA;AACX,CAAA,CAAA;AAEgB,SAAA,OAAA,CAAQ,EAAA,EAAS,IACjC,EAAA;IACI,IAAI,CAAC,QACL,EAAA;QACU,MAAA,SAAA,GAAY,MAAO,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;QAE9C,QAAA,GAAW,CAAA,CAAC,CAAA;QAEZ,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,SAAU,CAAA,MAAA,EAAQ,EAAE,CACxC,CAAA;YACU,MAAA,EAAA,GAAK,SAAA,CAAU,CAAC,CAAA,CAAA;YAEtB,QAAA,CAAS,EAAG,CAAA,EAAE,CAAC,CAAA,GAAI,gBAAA,CAAiB,EAAE,CAAA,CAAA;QAAA,CAC1C;IAAA,CACJ;IAEA,OAAO,QAAA,CAAS,IAAI,CAAA,CAAA;AACxB,CAAA;AAEgB,SAAA,mBAAA,CAAoB,EAAA,EAAS,IAC7C,EAAA;IACU,MAAA,SAAA,GAAY,OAAQ,CAAA,EAAA,EAAI,IAAI,CAAA,CAAA;IAE3B,OAAA,oBAAA,CAAqB,SAAS,CAAK,IAAA,SAAA,CAAA;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 9812, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9818, "column": 0}, "map": {"version":3,"file":"extractAttributesFromGlProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { mapGlToVertexFormat } from './mapType';\n\nimport type { Attribute } from '../../../shared/geometry/Geometry';\n\nexport interface ExtractedAttributeData extends Omit<Attribute, 'buffer'>\n{\n    /** set where the shader location is for this attribute */\n    location?: number;\n}\n\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @returns {object} the attribute data for this program\n */\n\nexport function extractAttributesFromGlProgram(\n    program: WebGLProgram,\n    gl: WebGLRenderingContextBase,\n    sortAttributes = false\n): Record<string, ExtractedAttributeData>\n{\n    const attributes: {[key: string]: ExtractedAttributeData} = {};\n\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let i = 0; i < totalAttributes; i++)\n    {\n        const attribData = gl.getActiveAttrib(program, i);\n\n        // ignore the default ones!\n        if (attribData.name.startsWith('gl_'))\n        {\n            continue;\n        }\n\n        const format = mapGlToVertexFormat(gl, attribData.type);\n\n        attributes[attribData.name] = {\n            location: 0, // set further down..\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    const keys = Object.keys(attributes);\n\n    if (sortAttributes)\n    {\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = i;\n\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n\n        gl.linkProgram(program);\n    }\n    else\n    {\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n        }\n    }\n\n    return attributes;\n}\n"],"names":[],"mappings":";;;;;;;;AAmBO,SAAS,8BACZ,CAAA,OAAA,EACA,EACA,EAAA,cAAA,GAAiB,KAErB,EAAA;IACI,MAAM,aAAsD,CAAA,CAAC,CAAA;IAE7D,MAAM,eAAkB,GAAA,EAAA,CAAG,mBAAoB,CAAA,OAAA,EAAS,GAAG,iBAAiB,CAAA,CAAA;IAE5E,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,eAAA,EAAiB,CACrC,EAAA,CAAA;QACI,MAAM,UAAa,GAAA,EAAA,CAAG,eAAgB,CAAA,OAAA,EAAS,CAAC,CAAA,CAAA;QAGhD,IAAI,UAAW,CAAA,IAAA,CAAK,UAAW,CAAA,KAAK,CACpC,EAAA;YACI,SAAA;QAAA,CACJ;QAEA,MAAM,MAAS,IAAA,4NAAA,EAAoB,EAAI,EAAA,UAAA,CAAW,IAAI,CAAA,CAAA;QAE3C,UAAA,CAAA,UAAA,CAAW,IAAI,CAAI,GAAA;YAC1B,QAAU,EAAA,CAAA;YAAA,qBAAA;YACV,MAAA;YACA,MAAA,gOAAQ,6BAAA,AAA2B,EAAA,MAAM,CAAE,CAAA,MAAA;YAC3C,MAAQ,EAAA,CAAA;YACR,QAAU,EAAA,KAAA;YACV,KAAO,EAAA,CAAA;QAAA,CACX,CAAA;IAAA,CACJ;IAEM,MAAA,IAAA,GAAO,MAAO,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA;IAEnC,IAAI,cACJ,EAAA;QACI,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA,EAAG,IAAO,CAAI,GAAA,CAAA,GAAK,IAAI,CAAE,CAAA,CAAA,CAAA;QAEpC,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,MAAA,EAAQ,CACjC,EAAA,CAAA;YACI,UAAA,CAAW,IAAK,CAAA,CAAC,CAAC,CAAA,CAAE,QAAW,GAAA,CAAA,CAAA;YAE/B,EAAA,CAAG,kBAAmB,CAAA,OAAA,EAAS,CAAG,EAAA,IAAA,CAAK,CAAC,CAAC,CAAA,CAAA;QAAA,CAC7C;QAEA,EAAA,CAAG,WAAA,CAAY,OAAO,CAAA,CAAA;IAAA,CAG1B,MAAA;QACI,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,MAAA,EAAQ,CACjC,EAAA,CAAA;YACe,UAAA,CAAA,IAAA,CAAK,CAAC,CAAC,CAAE,CAAA,QAAA,GAAW,GAAG,iBAAkB,CAAA,OAAA,EAAS,IAAK,CAAA,CAAC,CAAC,CAAA,CAAA;QAAA,CACxE;IAAA,CACJ;IAEO,OAAA,UAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 9862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9868, "column": 0}, "map": {"version":3,"file":"defaultValue.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/defaultValue.ts"],"sourcesContent":["function booleanArray(size: number): Array<boolean>\n{\n    const array = new Array(size);\n\n    for (let i = 0; i < array.length; i++)\n    {\n        array[i] = false;\n    }\n\n    return array;\n}\n\n/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'float':\n            return 0;\n\n        case 'vec2':\n            return new Float32Array(2 * size);\n\n        case 'vec3':\n            return new Float32Array(3 * size);\n\n        case 'vec4':\n            return new Float32Array(4 * size);\n\n        case 'int':\n        case 'uint':\n        case 'sampler2D':\n        case 'sampler2DArray':\n            return 0;\n\n        case 'ivec2':\n            return new Int32Array(2 * size);\n\n        case 'ivec3':\n            return new Int32Array(3 * size);\n\n        case 'ivec4':\n            return new Int32Array(4 * size);\n\n        case 'uvec2':\n            return new Uint32Array(2 * size);\n\n        case 'uvec3':\n            return new Uint32Array(3 * size);\n\n        case 'uvec4':\n            return new Uint32Array(4 * size);\n\n        case 'bool':\n            return false;\n\n        case 'bvec2':\n\n            return booleanArray(2 * size);\n\n        case 'bvec3':\n            return booleanArray(3 * size);\n\n        case 'bvec4':\n            return booleanArray(4 * size);\n\n        case 'mat2':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa,IACtB,EAAA;IACU,MAAA,KAAA,GAAQ,IAAI,KAAA,CAAM,IAAI,CAAA,CAAA;IAE5B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,MAAA,EAAQ,CAClC,EAAA,CAAA;QACI,KAAA,CAAM,CAAC,CAAI,GAAA,KAAA,CAAA;IAAA,CACf;IAEO,OAAA,KAAA,CAAA;AACX,CAAA;AAQgB,SAAA,YAAA,CACZ,IAAA,EACA,IAEJ,EAAA;IACI,OAAQ,IACR;QACI,KAAK,OAAA;YACM,OAAA,CAAA,CAAA;QAEX,KAAK,MAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,MAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,MAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,KAAA,CAAA;QACL,KAAK,MAAA,CAAA;QACL,KAAK,WAAA,CAAA;QACL,KAAK,gBAAA;YACM,OAAA,CAAA,CAAA;QAEX,KAAK,OAAA;YACM,OAAA,IAAI,UAAW,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAElC,KAAK,OAAA;YACM,OAAA,IAAI,UAAW,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAElC,KAAK,OAAA;YACM,OAAA,IAAI,UAAW,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAElC,KAAK,OAAA;YACM,OAAA,IAAI,WAAY,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEnC,KAAK,OAAA;YACM,OAAA,IAAI,WAAY,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEnC,KAAK,OAAA;YACM,OAAA,IAAI,WAAY,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEnC,KAAK,MAAA;YACM,OAAA,KAAA,CAAA;QAEX,KAAK,OAAA;YAEM,OAAA,YAAA,CAAa,IAAI,IAAI,CAAA,CAAA;QAEhC,KAAK,OAAA;YACM,OAAA,YAAA,CAAa,IAAI,IAAI,CAAA,CAAA;QAEhC,KAAK,OAAA;YACM,OAAA,YAAA,CAAa,IAAI,IAAI,CAAA,CAAA;QAEhC,KAAK,MAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBACxB,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEb,KAAK,MAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC3B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACN,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEhB,KAAK,MAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC9B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;IAAA,CACvB;IAEO,OAAA,IAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 9957, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9963, "column": 0}, "map": {"version":3,"file":"getUniformData.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUniformData.ts"],"sourcesContent":["import { defaultValue } from './defaultValue';\nimport { mapType } from './mapType';\n\nimport type { GlUniformData } from '../GlProgram';\n\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {[key: string]: GlUniformData}\n{\n    const uniforms: {[key: string]: GlUniformData} = {};\n\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < totalUniforms; i++)\n    {\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, '');\n\n        const isArray = !!(uniformData.name.match(/\\[.*?\\]$/));\n\n        const type = mapType(gl, uniformData.type);\n\n        uniforms[name] = {\n            name,\n            index: i,\n            type,\n            size: uniformData.size,\n            isArray,\n            value: defaultValue(type, uniformData.size),\n        };\n    }\n\n    return uniforms;\n}\n"],"names":[],"mappings":";;;;;;;;AAYgB,SAAA,cAAA,CAAe,OAAA,EAAuB,EACtD,EAAA;IACI,MAAM,WAA2C,CAAA,CAAC,CAAA;IAElD,MAAM,aAAgB,GAAA,EAAA,CAAG,mBAAoB,CAAA,OAAA,EAAS,GAAG,eAAe,CAAA,CAAA;IAExE,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,aAAA,EAAe,CACnC,EAAA,CAAA;QACI,MAAM,WAAc,GAAA,EAAA,CAAG,gBAAiB,CAAA,OAAA,EAAS,CAAC,CAAA,CAAA;QAClD,MAAM,IAAO,GAAA,WAAA,CAAY,IAAK,CAAA,OAAA,CAAQ,YAAY,EAAE,CAAA,CAAA;QAEpD,MAAM,UAAU,CAAC,CAAE,WAAY,CAAA,IAAA,CAAK,KAAA,CAAM,UAAU,CAAA,CAAA;QAEpD,MAAM,IAAO,0MAAA,UAAA,EAAQ,EAAI,EAAA,WAAA,CAAY,IAAI,CAAA,CAAA;QAEzC,QAAA,CAAS,IAAI,CAAI,GAAA;YACb,IAAA;YACA,KAAO,EAAA,CAAA;YACP,IAAA;YACA,MAAM,WAAY,CAAA,IAAA;YAClB,OAAA;YACA,KAAO,8MAAA,eAAA,EAAa,IAAM,EAAA,WAAA,CAAY,IAAI,CAAA;QAAA,CAC9C,CAAA;IAAA,CACJ;IAEO,OAAA,QAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 9992, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9998, "column": 0}, "map": {"version":3,"file":"getUboData.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUboData.ts"],"sourcesContent":["import type { GlUniformBlockData } from '../GlProgram';\n\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>\n{\n    // if uniform buffer data is not supported, early out\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n\n    const uniformBlocks: Record<string, GlUniformBlockData> = {};\n\n    // const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\n    for (let i = 0; i < totalUniformsBlocks; i++)\n    {\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n\n        uniformBlocks[name] = {\n            name,\n            index: uniformBlockIndex,\n            size,\n        };\n    }\n\n    return uniformBlocks;\n}\n"],"names":[],"mappings":";;;;AASgB,SAAA,UAAA,CAAW,OAAA,EAAuB,EAClD,EAAA;IAEI,IAAI,CAAC,EAAG,CAAA,qBAAA,EAAuB,OAAO,CAAA,CAAC,CAAA;IAEvC,MAAM,gBAAoD,CAAA,CAAC,CAAA;IAI3D,MAAM,mBAAsB,GAAA,EAAA,CAAG,mBAAoB,CAAA,OAAA,EAAS,GAAG,qBAAqB,CAAA,CAAA;IAEpF,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,mBAAA,EAAqB,CACzC,EAAA,CAAA;QACI,MAAM,IAAO,GAAA,EAAA,CAAG,yBAA0B,CAAA,OAAA,EAAS,CAAC,CAAA,CAAA;QACpD,MAAM,iBAAoB,GAAA,EAAA,CAAG,oBAAqB,CAAA,OAAA,EAAS,IAAI,CAAA,CAAA;QAE/D,MAAM,OAAO,EAAG,CAAA,8BAAA,CAA+B,OAAS,EAAA,CAAA,EAAG,GAAG,uBAAuB,CAAA,CAAA;QAErF,aAAA,CAAc,IAAI,CAAI,GAAA;YAClB,IAAA;YACA,KAAO,EAAA,iBAAA;YACP,IAAA;QAAA,CACJ,CAAA;IAAA,CACJ;IAEO,OAAA,aAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 10020, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10026, "column": 0}, "map": {"version":3,"file":"GlProgramData.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgramData.ts"],"sourcesContent":["/**\n * @private\n */\nexport class IGLUniformData\n{\n    public location: WebGLUniformLocation;\n    public value: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData\n{\n    /** The shader program. */\n    public program: WebGLProgram;\n\n    /**\n     * Holds the uniform data which contains uniform locations\n     * and current uniform values used for caching and preventing unneeded GPU commands.\n     */\n    public uniformData: Record<string, any>;\n\n    /**\n     * UniformGroups holds the various upload functions for the shader. Each uniform group\n     * and program have a unique upload function generated.\n     */\n    public uniformGroups: Record<string, any>;\n\n    /** A hash that stores where UBOs are bound to on the program. */\n    public uniformBlockBindings: Record<string, any>;\n\n    /** A hash for lazily-generated uniform uploading functions. */\n    public uniformSync: Record<string, any>;\n\n    /**\n     * A place where dirty ticks are stored for groups\n     * If a tick here does not match with the Higher level Programs tick, it means\n     * we should re upload the data.\n     */\n    public uniformDirtyGroups: Record<string, any>;\n\n    /**\n     * Makes a new Pixi program.\n     * @param program - webgl program\n     * @param uniformData - uniforms\n     */\n    constructor(program: WebGLProgram, uniformData: {[key: string]: IGLUniformData})\n    {\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n\n    /** Destroys this program. */\n    public destroy(): void\n    {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n"],"names":[],"mappings":";;;;;AAGO,MAAM,cACb,CAAA;AAGA,CAAA;AAMO,MAAM,aACb,CAAA;IAAA;;;;GAAA,GAkCI,WAAA,CAAY,OAAA,EAAuB,WACnC,CAAA;QACI,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;QACf,IAAA,CAAK,WAAc,GAAA,WAAA,CAAA;QACnB,IAAA,CAAK,aAAA,GAAgB,CAAA,CAAC,CAAA;QACtB,IAAA,CAAK,kBAAA,GAAqB,CAAA,CAAC,CAAA;QAC3B,IAAA,CAAK,oBAAA,GAAuB,CAAA,CAAC,CAAA;IAAA,CACjC;IAAA,2BAAA,GAGO,OACP,GAAA;QACI,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;QACnB,IAAA,CAAK,aAAgB,GAAA,IAAA,CAAA;QACrB,IAAA,CAAK,kBAAqB,GAAA,IAAA,CAAA;QAC1B,IAAA,CAAK,oBAAuB,GAAA,IAAA,CAAA;QAC5B,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;IAAA,CACnB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 10055, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10061, "column": 0}, "map": {"version":3,"file":"generateProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAmBgB,SAAA,eAAA,CAAgB,EAAA,EAAwB,OACxD,EAAA;IACI,MAAM,4NAAe,gBAAA,AAAc,EAAA,EAAA,EAAI,EAAG,CAAA,aAAA,EAAe,QAAQ,MAAM,CAAA,CAAA;IACvE,MAAM,4NAAe,gBAAA,AAAc,EAAA,EAAA,EAAI,EAAG,CAAA,eAAA,EAAiB,QAAQ,QAAQ,CAAA,CAAA;IAErE,MAAA,YAAA,GAAe,GAAG,aAAc,EAAA,CAAA;IAEnC,EAAA,CAAA,YAAA,CAAa,cAAc,YAAY,CAAA,CAAA;IACvC,EAAA,CAAA,YAAA,CAAa,cAAc,YAAY,CAAA,CAAA;IAE1C,MAAM,4BAA4B,OAAQ,CAAA,yBAAA,CAAA;IAE1C,IAAI,yBACJ,EAAA;QACQ,IAAA,OAAO,EAAG,CAAA,yBAAA,KAA8B,UAC5C,EAAA;+KAEI,OAAA,EAAK,CAA6E,2EAAA,CAAA,CAAA,CAAA;QAAA,CAItF,MAAA;YACO,EAAA,CAAA,yBAAA,CACC,YAAA,EACA,yBAA0B,CAAA,KAAA,EAC1B,yBAA0B,CAAA,UAAA,KAAe,UACnC,GAAA,EAAA,CAAG,gBAAA,GACH,EAAG,CAAA,mBAAA;QACb,CACJ;IAAA,CACJ;IAEA,EAAA,CAAG,WAAA,CAAY,YAAY,CAAA,CAAA;IAE3B,IAAI,CAAC,EAAG,CAAA,mBAAA,CAAoB,YAAc,EAAA,EAAA,CAAG,WAAW,CACxD,EAAA;uNACoB,kBAAA,EAAA,EAAA,EAAI,YAAc,EAAA,YAAA,EAAc,YAAY,CAAA,CAAA;IAAA,CAChE;IAKA,OAAA,CAAQ,cAAiB,iOAAA,iCAAA,EACrB,YAAA,EACA,EAAA,EACA,CAAE,gDAAA,CAAkD,IAAK,CAAA,OAAA,CAAQ,MAAM,CAAA;IAGnE,OAAA,CAAA,YAAA,iNAAe,iBAAA,AAAe,EAAA,YAAA,EAAc,EAAE,CAAA,CAAA;IAC9C,OAAA,CAAA,iBAAA,6MAAoB,aAAA,AAAW,EAAA,YAAA,EAAc,EAAE,CAAA,CAAA;IAEvD,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA,CAAA;IAC5B,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA,CAAA;IAE5B,MAAM,cAA+C,CAAA,CAAC,CAAA;IAE3C,IAAA,MAAA,CAAA,IAAK,QAAQ,YACxB,CAAA;QACU,MAAA,IAAA,GAAO,OAAQ,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;QAEnC,WAAA,CAAY,CAAC,CAAI,GAAA;YACb,QAAU,EAAA,EAAA,CAAG,kBAAmB,CAAA,YAAA,EAAc,CAAC,CAAA;YAC/C,KAAO,8MAAA,eAAA,EAAa,IAAK,CAAA,IAAA,EAAM,KAAK,IAAI,CAAA;QAAA,CAC5C,CAAA;IAAA,CACJ;IAEA,MAAM,SAAY,GAAA,kMAAI,gBAAc,CAAA,YAAA,EAAc,WAAW,CAAA,CAAA;IAEtD,OAAA,SAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 10117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10123, "column": 0}, "map": {"version":3,"file":"GenerateShaderSyncCode.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts"],"sourcesContent":["import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    const resName = shader._uniformBindMap[i][Number(j)];\n\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                const resName = shader._uniformBindMap[i][Number(j)];\n\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAYgB,SAAA,sBAAA,CAAuB,MAAA,EAAgB,YACvD,EAAA;IACI,MAAM,gBAA0B,EAAC,CAAA;IAWjC,MAAM,kBAA4B;QAAC,CAAA;;;;;;IAMlC,CAAA;KAAA,CAAA;IAED,IAAI,iBAAoB,GAAA,KAAA,CAAA;IACxB,IAAI,YAAe,GAAA,CAAA,CAAA;IAEnB,MAAM,WAAc,GAAA,YAAA,CAAa,eAAgB,CAAA,MAAA,CAAO,SAAS,CAAA,CAAA;IAEtD,IAAA,MAAA,CAAA,IAAK,OAAO,MACvB,CAAA;QACU,MAAA,KAAA,GAAQ,MAAO,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;QAE7B,aAAA,CAAc,IAAK,CAAA,CAAA;0BAAA,EACC,CAAC,CAAA;QACpB,CAAA,CAAA,CAAA;QAEU,IAAA,MAAA,CAAA,IAAK,MAAM,SACtB,CAAA;YACU,MAAA,QAAA,GAAW,KAAM,CAAA,SAAA,CAAU,CAAC,CAAA,CAAA;YAElC,IAAI,qNAAoB,eACxB,EAAA;gBACI,IAAI,SAAS,GACb,EAAA;oBACI,MAAM,UAAU,MAAO,CAAA,eAAA,CAAgB,CAAC,CAAE,CAAA,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA;oBAEnD,aAAA,CAAc,IAAK,CAAA,CAAA;;sCAAA,EAEC,CAAC,CAAA;6BAAA,EACV,OAAO,CAAA;4BAAA,EACR,MAAO,CAAA,SAAA,CAAU,iBAAkB,CAAA,OAAO,CAAA,CAAE,KAAK,CAAA;;oBAE1D,CAAA,CAAA,CAAA;gBAAA,CAGL,MAAA;oBACI,aAAA,CAAc,IAAK,CAAA,CAAA;yDAAA,EACoB,CAAC,CAAA;oBACvC,CAAA,CAAA,CAAA;gBAAA,CACL;YAAA,CACJ,MAAA,IACS,uNAAoB,iBAC7B,EAAA;gBACI,MAAM,UAAU,MAAO,CAAA,eAAA,CAAgB,CAAC,CAAE,CAAA,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA;gBAEnD,aAAA,CAAc,IAAK,CAAA,CAAA;;kCAAA,EAEC,CAAC,CAAA;yBAAA,EACV,OAAO,CAAA;wBAAA,EACR,MAAO,CAAA,SAAA,CAAU,iBAAkB,CAAA,OAAO,CAAA,CAAE,KAAK,CAAA;;gBAE1D,CAAA,CAAA,CAAA;YAAA,CACL,MAAA,IACS,kOAAoB,gBAC7B,EAAA;gBACI,MAAM,WAAc,GAAA,MAAA,CAAO,eAAgB,CAAA,CAAsB,CAAA,CAAE,CAAsB,CAAA,CAAA;gBAEnF,MAAA,WAAA,GAAc,WAAY,CAAA,WAAA,CAAY,WAAW,CAAA,CAAA;gBAEvD,IAAI,WACJ,EAAA;oBACI,IAAI,CAAC,iBACL,EAAA;wBACwB,iBAAA,GAAA,IAAA,CAAA;wBACpB,eAAA,CAAgB,IAAK,CAAA,CAAA;;wBAEpB,CAAA,CAAA,CAAA;oBAAA,CACL;oBAEA,YAAA,CAAa,GAAI,CAAA,SAAA,CAAU,WAAY,CAAA,QAAA,EAAU,YAAY,CAAA,CAAA;oBAE7D,aAAA,CAAc,IAAK,CAAA,CAAA;0CACK,EAAA,CAAC,CAAA,GAAA,EAAM,YAAY,CAAA;oBAC1C,CAAA,CAAA,CAAA;oBAED,YAAA,EAAA,CAAA;gBAAA,CACJ;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAEM,MAAA,cAAA,GAAiB,CAAC;WAAG,eAAA,EAAiB;WAAG,aAAa;KAAA,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;IAGvE,OAAO,IAAI,QAAA,CAAS,GAAK,EAAA,GAAA,EAAK,MAAM,cAAc,CAAA,CAAA;AACtD","ignoreList":[0]}},
    {"offset": {"line": 10205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10211, "column": 0}, "map": {"version":3,"file":"GlShaderSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getMaxTexturesPerBatch } from '../../../batcher/gl/utils/maxRecommendedTextures';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { ShaderSystem } from '../../shared/shader/ShaderSystem';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @memberof rendering\n */\nexport class GlShaderSystem implements ShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    public maxTextures: number;\n\n    /**\n     * @internal\n     * @private\n     */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_programDataHash');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n        this.maxTextures = getMaxTexturesPerBatch();\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     * @private\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10349, "column": 0}, "map": {"version":3,"file":"GlEncoderSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @memberof rendering\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAaO,MAAM,eACb,CAAA;IAYI,YAAY,QACZ,CAAA;QAJgB,IAAA,CAAA,eAAA,GAAkB,QAAQ,OAAQ,EAAA,CAAA;QAK9C,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,WAAA,CAAY,QAAA,EAAoB,MACvC,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,QAAA,CAAS,IAAK,CAAA,QAAA,EAAU,OAAO,SAAS,CAAA,CAAA;IAAA,CAC3D;IAEO,gBACP,GAAA,CAAA,CAEA;IAEO,KAAK,OAUZ,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAChB,MAAA,EAAE,QAAU,EAAA,MAAA,EAAQ,KAAO,EAAA,QAAA,EAAU,UAAU,IAAM,EAAA,IAAA,EAAM,KAAO,EAAA,aAAA,EAAkB,GAAA,OAAA,CAAA;QAEjF,QAAA,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,EAAQ,QAAQ,CAAA,CAAA;QAErC,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,QAAU,EAAA,QAAA,CAAS,MAAA,CAAO,cAAc,CAAA,CAAA;QAE/D,IAAI,KACJ,EAAA;YACa,QAAA,CAAA,KAAA,CAAM,GAAA,CAAI,KAAK,CAAA,CAAA;QAAA,CAC5B;QAEA,QAAA,CAAS,QAAA,CAAS,IAAK,CAAA,IAAA,EAAM,MAAM,KAAO,EAAA,aAAA,IAAiB,SAAS,aAAa,CAAA,CAAA;IAAA,CACrF;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ,CAAA;AAAA,YAAA,GA1Da,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,SAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 10386, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10392, "column": 0}, "map": {"version":3,"file":"mapWebGLBlendModesToPixi.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n\n    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());\n\n    if (isWebGl2)\n    {\n        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n    }\n    else\n    {\n        const ext = gl.getExtension('EXT_blend_minmax');\n\n        if (ext)\n        {\n            blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n            blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n        }\n    }\n\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n"],"names":[],"mappings":";;;;;;AAUO,SAAS,yBAAyB,EACzC,EAAA;IACI,MAAM,WAAmD,CAAA,CAAC,CAAA;IAI1D,QAAA,CAAS,MAAS,GAAA;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,mBAAmB;KAAA,CAAA;IACjD,QAAA,CAAS,GAAM,GAAA;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,GAAG;KAAA,CAAA;IACrB,QAAA,CAAA,QAAA,GAAW;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IAChF,QAAA,CAAA,MAAA,GAAS;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IACxE,QAAA,CAAA,IAAA,GAAO;QAAC,CAAA;QAAG,CAAC;KAAA,CAAA;IAGZ,QAAA,CAAA,YAAY,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IACrF,QAAA,CAAA,SAAS,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,GAAK;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,GAAG;KAAA,CAAA;IAClD,QAAA,CAAA,YAAY,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IAE9F,QAAA,CAAS,KAAQ,GAAA;QAAC,EAAG,CAAA,IAAA;QAAM,GAAG,mBAAmB;KAAA,CAAA;IAEjD,MAAM,WAAW,CAAA,CAAE,EAAA,yKAAc,aAAW,CAAA,GAAA,GAAM,wBAAyB,EAAA,CAAA,CAAA;IAE3E,IAAI,QACJ,EAAA;QACI,QAAA,CAAS,GAAM,GAAA;YAAC,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,GAAG,GAAG;SAAA,CAAA;QAC9D,QAAA,CAAS,GAAM,GAAA;YAAC,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,GAAG,GAAG;SAAA,CAAA;IAAA,CAGlE,MAAA;QACU,MAAA,GAAA,GAAM,EAAG,CAAA,YAAA,CAAa,kBAAkB,CAAA,CAAA;QAE9C,IAAI,GACJ,EAAA;YACI,QAAA,CAAS,GAAM,GAAA;gBAAC,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,GAAI,CAAA,OAAA;gBAAS,IAAI,OAAO;aAAA,CAAA;YACxE,QAAA,CAAS,GAAM,GAAA;gBAAC,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,GAAI,CAAA,OAAA;gBAAS,IAAI,OAAO;aAAA,CAAA;QAAA,CAC5E;IAAA,CACJ;IAeO,OAAA,QAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 10489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10495, "column": 0}, "map": {"version":3,"file":"GlStateSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @memberof rendering\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @member {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @member {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        this.reset();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state ||= this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff >>= 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state ||= this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    // used\n    /** Resets all the logic and disables the VAOs. */\n    public reset(): void\n    {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10692, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10698, "column": 0}, "map": {"version":3,"file":"GpuStencilModesToPixi.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts"],"sourcesContent":["import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n};\n"],"names":[],"mappings":";;;;;;AAgBO,MAAM,wBAAwC,EAAA,CAAC;AAEtD,qBAAsB,0LAAA,gBAAA,CAAc,IAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAE5C,qBAAsB,0LAAA,gBAAA,CAAc,QAAQ,CAAI,GAAA;IAC5C,gBAAkB,EAAA,CAAA;IAClB,eAAiB,EAAA,CAAA;AACrB,CAAA,CAAA;AAEA,qBAAsB,0LAAA,gBAAA,CAAc,kBAAkB,CAAI,GAAA;IACtD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,0LAAA,gBAAA,CAAc,qBAAqB,CAAI,GAAA;IACzD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,0LAAA,gBAAA,CAAc,WAAW,CAAI,GAAA;IAC/C,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,0LAAA,gBAAA,CAAc,mBAAmB,CAAI,GAAA;IACvD,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,SAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,SAAA;IAAA,CACZ;AACJ,CAAA","ignoreList":[0]}},
    {"offset": {"line": 10754, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10760, "column": 0}, "map": {"version":3,"file":"GlStencilSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10852, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10858, "column": 0}, "map": {"version":3,"file":"GlColorMaskSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @memberof rendering\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n"],"names":[],"mappings":";;;;;;AASO,MAAM,iBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QAHA,IAAA,CAAQ,eAAkB,GAAA,EAAA,CAAA;QAItB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,QAAQ,SACf,EAAA;QACI,IAAI,IAAA,CAAK,eAAoB,KAAA,SAAA,EAAW,OAAA;QACxC,IAAA,CAAK,eAAkB,GAAA,SAAA,CAAA;QAEvB,IAAA,CAAK,SAAA,CAAU,EAAG,CAAA,SAAA,CACd,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA;IACnB,CACJ;AAGJ,CAAA;AAAA,YAAA,GAhCa,iBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 10883, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10889, "column": 0}, "map": {"version":3,"file":"GlBatchAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _didUpload = false;\n    private readonly _tempState = State.for2d();\n\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUpload = false;\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, this._didUpload);\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._didUpload = true;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAcO,MAAM,cACb,CAAA;IADO,WAAA,EAAA;QAUH,IAAA,CAAQ,UAAa,GAAA,KAAA,CAAA;QACJ,IAAA,CAAA,UAAA,4LAAa,QAAA,CAAM,KAAM,EAAA,CAAA;IAAA,CAAA;IAEnC,KAAK,WACZ,EAAA;QACI,WAAA,CAAY,QAAS,CAAA,OAAA,CAAQ,aAAc,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CACvD;IAEO,aACP,GAAA;QACI,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;IAAA,CACtB;IAEO,KAAA,CAAM,SAAwB,EAAA,QAAA,EAAoB,MACzD,EAAA;QACI,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAG3B,QAAA,CAAS,MAAO,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAE5C,QAAA,CAAS,MAAO,CAAA,kBAAA,CAAmB,QAAS,CAAA,cAAA,CAAe,YAAY,CAAA,CAAA;QAEvE,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,QAAU,EAAA,MAAA,CAAO,SAAS,CAAA,CAAA;IAAA,CACrD;IAEO,OAAA,CAAQ,SAAA,EAAwB,KACvC,EAAA;QACI,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAE3B,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAEb,IAAA,CAAA,UAAA,CAAW,SAAA,GAAY,KAAM,CAAA,SAAA,CAAA;QAEzB,QAAA,CAAA,KAAA,CAAM,GAAI,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAE5B,MAAA,QAAA,GAAW,MAAM,QAAS,CAAA,QAAA,CAAA;QAEhC,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,QAAA,CAAS,KAAA,EAAO,CAC1C,EAAA,CAAA;YACI,QAAA,CAAS,OAAQ,CAAA,IAAA,CAAK,QAAS,CAAA,CAAC,CAAA,EAAG,CAAC,CAAA,CAAA;QAAA,CACxC;QAEA,QAAA,CAAS,QAAA,CAAS,IAAK,CAAA,KAAA,CAAM,QAAA,EAAU,KAAM,CAAA,IAAA,EAAM,MAAM,KAAK,CAAA,CAAA;IAAA,CAClE;AACJ,CAAA;AAAA,YAAA,GAtDa,cAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,iBAAA;KAClB;IACA,IAAM,EAAA,OAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 10934, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10940, "column": 0}, "map": {"version":3,"file":"localUniformBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,eAAkB,GAAA;IAC3B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;QAUlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ,EAAA;AAGO,MAAM,qBAAwB,GAAA;IACjC,GAAG,eAAA;IACH,MAAQ,EAAA;QACJ,GAAG,eAAgB,CAAA,MAAA;QAAA,qBAAA;QAEnB,QAAQ,eAAgB,CAAA,MAAA,CAAO,MAAO,CAAA,OAAA,CAAQ,YAAY,UAAU,CAAA;IAAA,CACxE;AACJ,EAAA;AAEO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 11002, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11008, "column": 0}, "map": {"version":3,"file":"textureBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts"],"sourcesContent":["export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;AAAO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;QAAA,CAAA;QAQlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ,EAAA;AAEO,MAAM,YAAe,GAAA;IACxB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;QAAA,CAAA;QAKlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 11063, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11069, "column": 0}, "map": {"version":3,"file":"GlMeshAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @memberof rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAkBO,MAAM,aACb,CAAA;IAUW,IACP,GAAA;QACI,MAAM,gNAAY,6BAAA,AAA2B,EAAA;YACzC,IAAM,EAAA,MAAA;YACN,IAAM,EAAA;uNACF,oBAAA;kNACA,eAAA;sNACA,mBAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEI,IAAA,CAAA,OAAA,GAAU,+LAAI,SAAO,CAAA;YACtB,SAAA;YACA,SAAW,EAAA;gBACP,QAAA,+LAAU,UAAA,CAAQ,KAAM,CAAA,MAAA;gBACxB,eAAiB,EAAA;oBACb,gBAAgB;wBAAE,IAAA,EAAM;wBAAe,KAAO,EAAA,IAAI,yKAAA,EAAS;oBAAA,CAAA;gBAAA,CAC/D;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,CAAQ,QAAA,EAAoB,IACnC,EAAA;QACI,MAAM,WAAW,QAAS,CAAA,QAAA,CAAA;QAE1B,IAAI,SAAiB,IAAK,CAAA,OAAA,CAAA;QAE1B,IAAI,CAAC,MACL,EAAA;YACI,MAAA,GAAS,IAAK,CAAA,OAAA,CAAA;YAEd,MAAM,UAAU,IAAK,CAAA,OAAA,CAAA;YACrB,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAA;YAEvB,MAAA,CAAO,SAAA,CAAU,QAAW,GAAA,MAAA,CAAA;YACrB,MAAA,CAAA,SAAA,CAAU,QAAA,GAAW,MAAO,CAAA,KAAA,CAAA;YACnC,MAAA,CAAO,SAAU,CAAA,eAAA,CAAgB,QAAS,CAAA,cAAA,GAAiB,QAAQ,aAAc,CAAA,QAAA,CAAA;QAAA,CACrF,MAAA,IACS,CAAC,MAAA,CAAO,SACjB,EAAA;+KAES,OAAA,EAAA,8BAAA,EAAgC,KAAK,MAAM,CAAA,CAAA;YAGhD,OAAA;QAAA,CACJ;QAIA,MAAA,CAAO,MAAO,CAAA,GAAG,CAAI,GAAA,QAAA,CAAS,cAAe,CAAA,SAAA,CAAA;QACtC,MAAA,CAAA,MAAA,CAAO,GAAG,CAAA,GAAI,QAAS,CAAA,sBAAA,CAAA;QAE9B,QAAA,CAAS,OAAA,CAAQ,IAAK,CAAA;YAClB,UAAU,IAAK,CAAA,SAAA;YACf,MAAA;YACA,OAAO,IAAK,CAAA,KAAA;QAAA,CACf,CAAA,CAAA;IAAA,CACL;IAEO,OACP,GAAA;QACS,IAAA,CAAA,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA,CAAA;QACzB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;IAAA,CACnB;AACJ,CAAA;AA5Ea,aAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;uKACF,gBAAc,CAAA,iBAAA;KAClB;IACA,IAAM,EAAA,MAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 11149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11155, "column": 0}, "map": {"version":3,"file":"GlGraphicsAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.state.set(graphicsPipe.state);\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(batcher.geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.count; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw(batch.topology, batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11254, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11260, "column": 0}, "map": {"version":3,"file":"WebGLRenderer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\ntype WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems> & PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @memberof rendering\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @memberof rendering\n */\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link rendering.GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link rendering.GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link rendering.GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link rendering.GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link rendering.GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link rendering.GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GlUboSystem} ubo - UboSystem instance.\n * @property {rendering.GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {rendering.GlContextSystem} context - ContextSystem instance.\n * @property {rendering.GlBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GlTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {rendering.GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {rendering.GlShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GlStateSystem} state - StateSystem instance.\n * @property {rendering.GlStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends rendering.AbstractRenderer\n */\n/* eslint-enable max-len */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,MAAM,mBAAsB,GAAA;yMACrB,gBAAA;IACH,gMAAA;6LACA,qBAAA;qMACA,kBAAA;mMACA,iBAAA;qMACA,kBAAA;+MACA,uBAAA;uMACA,mBAAA;IACA,4NAAA;mMACA,iBAAA;0LACA,kBAAA;iMACA,gBAAA;0LACA,kBAAA;4LACA,oBAAA;CACJ,CAAA;AACA,MAAM,iBAAA,GAAoB,CAAC;yMAAG,oBAAiB;CAAA,CAAA;AAC/C,MAAM,oBAAuB,GAAA;uLAAC,iBAAgB;+KAAA,gBAAA;uLAAe,oBAAiB;CAAA,CAAA;AAG9E,MAAM,UAAwD,EAAC,CAAA;AAC/D,MAAM,cAA0D,EAAC,CAAA;AACjE,MAAM,qBAAqD,EAAC,CAAA;+JAE5D,aAAW,CAAA,iBAAA,gKAAkB,gBAAc,CAAA,WAAA,EAAa,OAAO,CAAA,CAAA;8JAC/D,cAAW,CAAA,iBAAA,gKAAkB,gBAAc,CAAA,UAAA,EAAY,WAAW,CAAA,CAAA;+JAClE,aAAW,CAAA,iBAAA,gKAAkB,gBAAc,CAAA,iBAAA,EAAmB,kBAAkB,CAAA,CAAA;+JAGhF,aAAA,CAAW,GAAA,CAAI,GAAG,mBAAA,EAAqB,GAAG,iBAAA,EAAmB,GAAG,oBAAoB,CAAA,CAAA;AA6F7E,MAAM,2NACD,mBAEZ,CAAA;IAGI,WACA,EAAA;QACI,MAAM,YAAe,GAAA;YACjB,IAAM,EAAA,OAAA;YACN,4KAAM,eAAa,CAAA,KAAA;YACnB,OAAA;YACA,WAAA;YACA,kBAAA;QAAA,CACJ,CAAA;QAEA,KAAA,CAAM,YAAY,CAAA,CAAA;IAAA,CACtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 11349, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}