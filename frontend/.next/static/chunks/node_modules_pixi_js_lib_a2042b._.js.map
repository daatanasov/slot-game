{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"SharedSystems.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts"],"sourcesContent":["import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,MAAM,aAAgB,GAAA;+MACzB,oBAAA;qNACA,sBAAA;wMACA,cAAA;oMACA,aAAA;qLACA,oBAAA;4MACA,kBAAA;kNACA,wBAAA;0MACA,gBAAA;IACA,2LAAA;+MACA,qBAAA;iMACA,kBAAA;CACJ,CAAA;AAEO,MAAM,iBAAoB,GAAA;6MAC7B,gBAAA;2LACA,cAAA;2KACA,aAAA;mLACA,kBAAA;yLACA,gBAAA;6LACA,kBAAA;yLACA,gBAAA;oLACA,mBAAA;CACJ","ignoreList":[0]}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"file":"GlUboSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @memberof rendering\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AASO,MAAM,qNAAoB,YACjC,CAAA;IAOI,WACA,EAAA;QACU,KAAA,CAAA;YACF,iBAAmB,qNAAA,yBAAA;YACnB,eAAiB,EAAA,4OAAA;QAAA,CACpB,CAAA,CAAA;IAAA,CACL;AACJ,CAAA;AAAA,YAAA,GAfa,WAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;0KAAC,gBAAA,CAAc,WAAW;KAAA;IAChC,IAAM,EAAA,KAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"file":"GlBackBufferSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @memberof rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     * @memberof rendering.WebGLOptions\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @memberof rendering\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n"],"names":["renderTarget"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"file":"GlContextSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @memberof rendering\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     * @memberof rendering.SharedRendererOptions\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @memberof rendering.SharedRendererOptions\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     * @memberof rendering.SharedRendererOptions\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     * @memberof rendering.SharedRendererOptions\n     */\n    preferWebGLVersion?: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     * @memberof rendering.SharedRendererOptions\n     */\n    multiView: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @memberof rendering\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n        /**\n         * {@link WebGLOptions.multiView}\n         * @default false\n         */\n        multiView: false\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    public multiView: boolean;\n\n    /**\n     * The canvas that the WebGL Context is rendering to.\n     * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n     * It will be rendered to and then copied to the target canvas.\n     * @readonly\n     */\n    public canvas: ICanvas;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        // TODO add to options\n        let multiView = this.multiView = options.multiView;\n\n        if (options.context && multiView)\n        {\n            // eslint-disable-next-line max-len\n            warn('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.');\n\n            multiView = false;\n        }\n\n        if (multiView)\n        {\n            this.canvas = DOMAdapter.get()\n                .createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n        }\n        else\n        {\n            this.canvas = this._renderer.view.canvas;\n        }\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    public ensureCanvasSize(targetCanvas: ICanvas): void\n    {\n        if (!this.multiView)\n        {\n            if (targetCanvas !== this.canvas)\n            {\n                warn('multiView is disabled, but targetCanvas is not the main canvas');\n            }\n\n            return;\n        }\n\n        const { canvas } = this;\n\n        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height)\n        {\n            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n\n        const canvas = this.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            // #endif\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 522, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"file":"GlBufferSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @memberof rendering\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private readonly _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this._gl = this._renderer.gl;\n\n        this._gpuBuffers = Object.create(null);\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 722, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"file":"glUploadImageResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts"],"sourcesContent":["import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth || glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;AAMO,MAAM,qBAAwB,GAAA;IAEjC,EAAI,EAAA,OAAA;IAEJ,MAAO,EAAA,MAAA,EAAoC,SAAsB,EAAA,EAAA,EAAwB,YACzF,EAAA;QACU,MAAA,kBAAA,GAAqB,OAAO,SAAc,KAAA,6BAAA,CAAA;QAE7C,EAAA,CAAA,WAAA,CAAY,EAAG,CAAA,8BAAA,EAAgC,kBAAkB,CAAA,CAAA;QAEpE,MAAM,UAAU,SAAU,CAAA,KAAA,CAAA;QAC1B,MAAM,WAAW,SAAU,CAAA,MAAA,CAAA;QAE3B,MAAM,eAAe,MAAO,CAAA,UAAA,CAAA;QAC5B,MAAM,gBAAgB,MAAO,CAAA,WAAA,CAAA;QAE7B,MAAM,gBAAgB,MAAO,CAAA,aAAA,CAAA;QAC7B,MAAM,iBAAiB,MAAO,CAAA,cAAA,CAAA;QAE1B,IAAA,aAAA,GAAgB,YAAgB,IAAA,cAAA,GAAiB,aACrD,EAAA;YACQ,IAAA,OAAA,KAAY,YAAgB,IAAA,QAAA,KAAa,aAC7C,EAAA;gBACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,YAAA,EACA,aAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,IAAA;YACJ,CACJ;YAEA,IAAI,iBAAiB,CACrB,EAAA;gBACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,aAAA,EACA,cAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;YACX,CAGJ,MAAA;gBACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;YACX,CACJ;QAAA,CAEK,MAAA,IAAA,OAAA,KAAY,YAAgB,IAAA,QAAA,KAAa,aAClD,EAAA;YACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ,MAAA,IACS,iBAAiB,CAC1B,EAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,YAAA,EACA,aAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CAGJ,MAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ;QAEA,SAAA,CAAU,KAAQ,GAAA,YAAA,CAAA;QAClB,SAAA,CAAU,MAAS,GAAA,aAAA,CAAA;IAAA,CACvB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"file":"glUploadBufferImageResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts"],"sourcesContent":["import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadBufferImageResource = {\n\n    id: 'buffer',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                source.width,\n                source.height,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;AAKO,MAAM,2BAA8B,GAAA;IAEvC,EAAI,EAAA,QAAA;IAEJ,MAAA,EAAO,MAAuB,EAAA,SAAA,EAAsB,EACpD,EAAA;QACI,IAAI,UAAU,KAAU,KAAA,MAAA,CAAO,KAAA,IAAS,SAAU,CAAA,MAAA,KAAW,OAAO,MACpE,EAAA;YACO,EAAA,CAAA,aAAA,CACC,EAAG,CAAA,UAAA,EACH,CAAA,EACA,CAAA,EACA,CAAA,EACA,MAAO,CAAA,KAAA,EACP,MAAO,CAAA,MAAA,EACP,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CAGJ,MAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,MAAO,CAAA,KAAA,EACP,MAAO,CAAA,MAAA,EACP,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,MAAO,CAAA,QAAA;QACX,CACJ;QAEA,SAAA,CAAU,KAAA,GAAQ,MAAO,CAAA,KAAA,CAAA;QACzB,SAAA,CAAU,MAAA,GAAS,MAAO,CAAA,MAAA,CAAA;IAAA,CAC9B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"file":"glUploadVideoResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts"],"sourcesContent":["import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,qBAAwB,GAAA;IAEjC,EAAI,EAAA,OAAA;IAEJ,MAAO,EAAA,MAAA,EAAqB,SAAsB,EAAA,EAAA,EAAwB,YAC1E,EAAA;QACQ,IAAA,CAAC,OAAO,OACZ,EAAA;YACO,EAAA,CAAA,UAAA,CACC,SAAU,CAAA,MAAA,EACV,CAAA,EACA,SAAU,CAAA,cAAA,EACV,CAAA,EACA,CAAA,EACA,CAAA,EACA,SAAU,CAAA,MAAA,EACV,SAAU,CAAA,IAAA,EACV,IAAA;YAGJ,OAAA;QAAA,CACJ;+NAEA,wBAAA,CAAsB,MAAO,CAAA,MAAA,EAAQ,SAAW,EAAA,EAAA,EAAI,YAAY,CAAA,CAAA;IAAA,CACpE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"file":"glUploadCompressedTextureResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts"],"sourcesContent":["import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 902, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 908, "column": 0}, "map": {"version":3,"file":"mapFormatToGlInternalFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n"],"names":[],"mappings":";;;;;;AAagB,SAAA,2BAAA,CACZ,EAAA,EACA,UAEJ,EAAA;IACI,IAAI,OAAO,CAAA,CAAC,CAAA;IACZ,IAAI,aAAqB,EAAG,CAAA,IAAA,CAAA;IAE5B,IAAI,CAAA,CAAE,EAAc,4KAAA,aAAA,CAAW,GAAI,EAAA,CAAE,wBAAA,EACrC,CAAA,EAAA;QACW,IAAA,GAAA;YACH,mBAAmB,EAAG,CAAA,YAAA;YACtB,mBAAmB,EAAG,CAAA,YAAA;QAAA,CAC1B,CAAA;QAEA,UAAA,GAAa,EAAG,CAAA,KAAA,CAAA;IAAA,CACpB,MAAA,IACS,WAAW,IACpB,EAAA;QACW,IAAA,GAAA;YACH,iBAAA,EAAmB,WAAW,IAAK,CAAA,gBAAA;YACnC,iBAAA,EAAmB,WAAW,IAAK,CAAA,gBAAA;QAAA,CACvC,CAAA;IAAA,CACJ;IAEO,OAAA;QAAA,gBAAA;QAEH,SAAS,EAAG,CAAA,EAAA;QACZ,SAAS,EAAG,CAAA,QAAA;QACZ,QAAQ,EAAG,CAAA,IAAA;QACX,QAAQ,EAAG,CAAA,GAAA;QAAA,iBAAA;QAGX,SAAS,EAAG,CAAA,KAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QACZ,UAAU,EAAG,CAAA,IAAA;QACb,UAAU,EAAG,CAAA,GAAA;QACb,UAAU,EAAG,CAAA,SAAA;QACb,SAAS,EAAG,CAAA,KAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QAAA,iBAAA;QAGZ,SAAS,EAAG,CAAA,KAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QACZ,UAAU,EAAG,CAAA,IAAA;QACb,UAAU,EAAG,CAAA,MAAA;QACb,UAAU,EAAG,CAAA,KAAA;QACb,WAAW,EAAG,CAAA,KAAA;QACd,YAAY,EAAG,CAAA,IAAA;QAEf,GAAG,IAAA;QAAA,wBAAA;QAGH,YAAY,EAAG,CAAA,WAAA;QACf,WAAW,EAAG,CAAA,OAAA;QACd,WAAW,EAAG,CAAA,MAAA;QACd,UAAA;QACA,cAAc,EAAG,CAAA,OAAA;QACjB,cAAc,EAAG,CAAA,QAAA;QACjB,eAAe,EAAG,CAAA,cAAA;QAAA,iBAAA;QAGlB,UAAU,EAAG,CAAA,MAAA;QACb,UAAU,EAAG,CAAA,KAAA;QACb,WAAW,EAAG,CAAA,KAAA;QACd,YAAY,EAAG,CAAA,QAAA;QACf,YAAY,EAAG,CAAA,OAAA;QACf,aAAa,EAAG,CAAA,OAAA;QAAA,kBAAA;QAGhB,YAAY,EAAG,CAAA,QAAA;QACf,YAAY,EAAG,CAAA,OAAA;QACf,aAAa,EAAG,CAAA,OAAA;QAAA,wBAAA;QAGhB,UAAU,EAAG,CAAA,cAAA;QACb,cAAc,EAAG,CAAA,iBAAA;QACjB,aAAa,EAAG,CAAA,iBAAA;QAChB,wBAAwB,EAAG,CAAA,gBAAA;QAC3B,cAAc,EAAG,CAAA,kBAAA;QACjB,yBAAyB,EAAG,CAAA,iBAAA;QAAA,qBAAA;QAG5B,GAAG,WAAW,IAAO,GAAA;YACjB,gBAAA,EAAkB,WAAW,IAAK,CAAA,6BAAA;YAClC,gBAAA,EAAkB,WAAW,IAAK,CAAA,6BAAA;YAClC,gBAAA,EAAkB,WAAW,IAAK,CAAA,6BAAA;QAAA,IAClC,CAAA,CAAC;QACL,GAAG,WAAW,SAAY,GAAA;YACtB,qBAAA,EAAuB,WAAW,SAAU,CAAA,mCAAA;YAC5C,qBAAA,EAAuB,WAAW,SAAU,CAAA,mCAAA;YAC5C,qBAAA,EAAuB,WAAW,SAAU,CAAA,mCAAA;QAAA,IAC5C,CAAA,CAAC;QACL,GAAG,WAAW,IAAO,GAAA;YACjB,aAAA,EAAe,WAAW,IAAK,CAAA,wBAAA;YAC/B,aAAA,EAAe,WAAW,IAAK,CAAA,+BAAA;YAC/B,cAAA,EAAgB,WAAW,IAAK,CAAA,8BAAA;YAChC,cAAA,EAAgB,WAAW,IAAK,CAAA,qCAAA;QAAA,IAChC,CAAA,CAAC;QACL,GAAG,WAAW,IAAO,GAAA;YACjB,gBAAA,EAAkB,WAAW,IAAK,CAAA,oCAAA;YAClC,iBAAA,EAAmB,WAAW,IAAK,CAAA,sCAAA;YACnC,gBAAA,EAAkB,WAAW,IAAK,CAAA,8BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;QAAA,IACvC,CAAA,CAAC;QACL,GAAG,WAAW,GAAM,GAAA;YAChB,gBAAA,EAAkB,WAAW,GAAI,CAAA,oBAAA;YACjC,qBAAA,EAAuB,WAAW,GAAI,CAAA,qBAAA;YACtC,kBAAA,EAAoB,WAAW,GAAI,CAAA,wCAAA;YACnC,uBAAA,EAAyB,WAAW,GAAI,CAAA,yCAAA;YACxC,iBAAA,EAAmB,WAAW,GAAI,CAAA,yBAAA;YAClC,sBAAA,EAAwB,WAAW,GAAI,CAAA,gCAAA;YACvC,cAAA,EAAgB,WAAW,GAAI,CAAA,kBAAA;YAAA,iBAAA;YAE/B,eAAA,EAAiB,WAAW,GAAI,CAAA,0BAAA;QAAA,IAEhC,CAAA,CAAC;QACL,GAAG,WAAW,IAAO,GAAA;YACjB,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAoB,WAAW,IAAK,CAAA,4BAAA;YACpC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,gBAAA,EAAkB,WAAW,IAAK,CAAA,4BAAA;YAClC,qBAAA,EAAuB,WAAW,IAAK,CAAA,oCAAA;YACvC,iBAAA,EAAmB,WAAW,IAAK,CAAA,6BAAA;YACnC,sBAAA,EAAwB,WAAW,IAAK,CAAA,qCAAA;YACxC,iBAAA,EAAmB,WAAW,IAAK,CAAA,6BAAA;YACnC,sBAAA,EAAwB,WAAW,IAAK,CAAA,qCAAA;YACxC,iBAAA,EAAmB,WAAW,IAAK,CAAA,6BAAA;YACnC,sBAAA,EAAwB,WAAW,IAAK,CAAA,qCAAA;YACxC,kBAAA,EAAoB,WAAW,IAAK,CAAA,8BAAA;YACpC,uBAAA,EAAyB,WAAW,IAAK,CAAA,sCAAA;YACzC,kBAAA,EAAoB,WAAW,IAAK,CAAA,8BAAA;YACpC,uBAAA,EAAyB,WAAW,IAAK,CAAA,sCAAA;YACzC,kBAAA,EAAoB,WAAW,IAAK,CAAA,8BAAA;YACpC,uBAAA,EAAyB,WAAW,IAAK,CAAA,sCAAA;QAAA,IACzC,CAAA,CAAC;IAAA,CACT,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"file":"mapFormatToGlType.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n"],"names":[],"mappings":";;;;AASO,SAAS,kBAAkB,EAClC,EAAA;IACW,OAAA;QAAA,gBAAA;QAEH,SAAS,EAAG,CAAA,aAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QACZ,QAAQ,EAAG,CAAA,aAAA;QACX,QAAQ,EAAG,CAAA,IAAA;QAAA,iBAAA;QAGX,SAAS,EAAG,CAAA,cAAA;QACZ,SAAS,EAAG,CAAA,KAAA;QACZ,UAAU,EAAG,CAAA,UAAA;QACb,UAAU,EAAG,CAAA,aAAA;QACb,UAAU,EAAG,CAAA,IAAA;QACb,SAAS,EAAG,CAAA,aAAA;QACZ,SAAS,EAAG,CAAA,IAAA;QAAA,iBAAA;QAGZ,SAAS,EAAG,CAAA,YAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,UAAU,EAAG,CAAA,KAAA;QACb,UAAU,EAAG,CAAA,cAAA;QACb,UAAU,EAAG,CAAA,KAAA;QACb,WAAW,EAAG,CAAA,UAAA;QACd,YAAY,EAAG,CAAA,aAAA;QACf,mBAAmB,EAAG,CAAA,aAAA;QAAA,wBAAA;QAGtB,YAAY,EAAG,CAAA,IAAA;QACf,WAAW,EAAG,CAAA,aAAA;QACd,WAAW,EAAG,CAAA,IAAA;QACd,YAAY,EAAG,CAAA,aAAA;QACf,mBAAmB,EAAG,CAAA,aAAA;QACtB,cAAc,EAAG,CAAA,wBAAA;QACjB,cAAc,EAAG,CAAA,2BAAA;QACjB,eAAe,EAAG,CAAA,4BAAA;QAAA,iBAAA;QAGlB,UAAU,EAAG,CAAA,YAAA;QACb,UAAU,EAAG,CAAA,GAAA;QACb,WAAW,EAAG,CAAA,KAAA;QACd,YAAY,EAAG,CAAA,cAAA;QACf,YAAY,EAAG,CAAA,KAAA;QACf,aAAa,EAAG,CAAA,UAAA;QAAA,kBAAA;QAGhB,YAAY,EAAG,CAAA,YAAA;QACf,YAAY,EAAG,CAAA,GAAA;QACf,aAAa,EAAG,CAAA,KAAA;QAAA,wBAAA;QAGhB,UAAU,EAAG,CAAA,aAAA;QACb,cAAc,EAAG,CAAA,cAAA;QACjB,aAAa,EAAG,CAAA,YAAA;QAChB,wBAAwB,EAAG,CAAA,iBAAA;QAC3B,cAAc,EAAG,CAAA,KAAA;QACjB,yBAAyB,EAAG,CAAA,8BAAA;IAAA,CAEhC,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1117, "column": 0}, "map": {"version":3,"file":"mapFormatToGlFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n"],"names":[],"mappings":";;;;AASO,SAAS,oBAAoB,EACpC,EAAA;IACW,OAAA;QAAA,gBAAA;QAEH,SAAS,EAAG,CAAA,GAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,QAAQ,EAAG,CAAA,GAAA;QACX,QAAQ,EAAG,CAAA,GAAA;QAAA,iBAAA;QAGX,SAAS,EAAG,CAAA,GAAA;QACZ,SAAY,EAAG,CAAA,GAAA;QACf,UAAU,EAAG,CAAA,GAAA;QACb,UAAW,EAAG,CAAA,EAAA;QACd,UAAY,EAAG,CAAA,EAAA;QACf,SAAU,EAAG,CAAA,EAAA;QACb,SAAU,EAAG,CAAA,EAAA;QAAA,iBAAA;QAGb,SAAS,EAAG,CAAA,GAAA;QACZ,SAAS,EAAG,CAAA,GAAA;QACZ,UAAU,EAAG,CAAA,GAAA;QACb,UAAY,EAAG,CAAA,EAAA;QACf,UAAW,EAAG,CAAA,EAAA;QACd,WAAY,EAAG,CAAA,EAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,mBAAmB,EAAG,CAAA,IAAA;QAAA,wBAAA;QAGtB,YAAY,EAAG,CAAA,IAAA;QACf,WAAW,EAAG,CAAA,IAAA;QACd,WAAW,EAAG,CAAA,IAAA;QACd,YAAY,EAAG,CAAA,IAAA;QACf,mBAAmB,EAAG,CAAA,IAAA;QACtB,cAAc,EAAG,CAAA,GAAA;QACjB,cAAc,EAAG,CAAA,IAAA;QACjB,eAAe,EAAG,CAAA,GAAA;QAAA,iBAAA;QAGlB,UAAU,EAAG,CAAA,EAAA;QACb,UAAU,EAAG,CAAA,EAAA;QACb,WAAY,EAAG,CAAA,EAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,aAAa,EAAG,CAAA,IAAA;QAAA,kBAAA;QAGhB,YAAY,EAAG,CAAA,IAAA;QACf,YAAY,EAAG,CAAA,IAAA;QACf,aAAa,EAAG,CAAA,IAAA;QAAA,wBAAA;QAGhB,UAAU,EAAG,CAAA,cAAA;QACb,cAAc,EAAG,CAAA,eAAA;QACjB,aAAa,EAAG,CAAA,eAAA;QAChB,wBAAwB,EAAG,CAAA,aAAA;QAC3B,cAAc,EAAG,CAAA,eAAA;QACjB,yBAAyB,EAAG,CAAA,aAAA;IAAA,CAEhC,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1176, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1182, "column": 0}, "map": {"version":3,"file":"GlTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts"],"sourcesContent":["import { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @memberof rendering\n * @ignore\n */\nexport class GlTexture\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,SACb,CAAA;IA0BI,YAAY,OACZ,CAAA;QA1BA,IAAA,CAAO,MAAA,6LAAqB,aAAW,CAAA,UAAA,CAAA;QA2BnC,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;QACf,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA,CAAA;QACb,IAAA,CAAK,MAAS,GAAA,CAAA,CAAA,CAAA;QACd,IAAA,CAAK,IAAA,6LAAO,WAAS,CAAA,aAAA,CAAA;QACrB,IAAA,CAAK,cAAA,6LAAiB,aAAW,CAAA,IAAA,CAAA;QACjC,IAAA,CAAK,MAAA,6LAAS,aAAW,CAAA,IAAA,CAAA;QACzB,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA;IAAA,CACvB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1202, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"file":"applyStyleParams.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts"],"sourcesContent":["import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n"],"names":[],"mappings":";;;;;;AASgB,SAAA,gBAAA,CACZ,KAAA,EACA,EACA,EAAA,OAAA,EAEA,cAAA,EACA,cACA,EAAA,UAAA,EACA,UAAA,EAEA,aAEJ,EAAA;IACI,MAAM,SAAY,GAAA,UAAA,CAAA;IAEd,IAAA,CAAC,aACE,IAAA,KAAA,CAAM,YAAiB,KAAA,QAAA,IACvB,MAAM,YAAiB,KAAA,QAAA,IACvB,KAAM,CAAA,YAAA,KAAiB,QAE9B,EAAA;QAEI,MAAM,SAAY,6MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QACvF,MAAM,SAAY,6MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QACvF,MAAM,SAAY,6MAAA,sBAAA,CAAoB,UAAa,GAAA,eAAA,GAAkB,MAAM,YAAY,CAAA,CAAA;QAEvF,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;QAC1D,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;QAG1D,IAAI,EAAG,CAAA,cAAA,EAAgB,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,cAAA,EAAgB,SAAS,CAAA,CAAA;IAAA,CACrF;IAEA,IAAI,CAAC,aAAA,IAAiB,KAAM,CAAA,SAAA,KAAc,QAC1C,EAAA;QAEO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,4MAAoB,sBAAoB,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA,CAAA;IAAA,CAC7F;IAIA,IAAI,OACJ,EAAA;QACI,IAAI,CAAC,aAAA,IAAiB,KAAM,CAAA,YAAA,KAAiB,QAC7C,EAAA;YACI,MAAM,yNAAe,4BAA0B,CAAA,KAAA,CAAM,SAAS,CAAA,CAAE,MAAM,YAAY,CAAA,CAAA;YAElF,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,EAAoB,YAAY,CAAA,CAAA;QAAA,CACrE;IAAA,CAIJ,MAAA;QACO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,kBAAA,4MAAoB,sBAAoB,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA,CAAA;IAAA,CAC7F;IAGI,IAAA,cAAA,IAAkB,KAAM,CAAA,aAAA,GAAgB,CAC5C,EAAA;QACU,MAAA,KAAA,GAAQ,KAAK,GAAI,CAAA,KAAA,CAAM,aAAA,EAAe,EAAG,CAAA,YAAA,CAAa,cAAe,CAAA,8BAA8B,CAAC,CAAA,CAAA;QAE1G,EAAA,CAAG,cAAc,CAAA,CAAE,SAAW,EAAA,cAAA,CAAe,0BAAA,EAA4B,KAAK,CAAA,CAAA;IAAA,CAClF;IAGA,IAAI,MAAM,OACV,EAAA;QACO,EAAA,CAAA,cAAc,CAAA,CAAE,SAAW,EAAA,EAAA,CAAG,oBAAA,4MAAsB,yBAAuB,CAAA,KAAA,CAAM,OAAO,CAAC,CAAA,CAAA;IAAA,CAChG;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1245, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1251, "column": 0}, "map": {"version":3,"file":"GlTextureSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @memberof rendering\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_glTextures');\n        this._renderer.renderableGC.addManagedHash(this, '_glSamplers');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source ||= Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        (this._renderer as null) = null;\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1513, "column": 0}, "map": {"version":3,"file":"GlRenderTargetAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts"],"sourcesContent":["import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        const colorTexture = renderTarget.colorTexture;\n\n        if (colorTexture.resource === renderer.canvas)\n        {\n            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil || renderTarget.depth)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n\n    public prerender(renderTarget: RenderTarget)\n    {\n        const resource = renderTarget.colorTexture.resource;\n\n        // if the render target is a canvas, ensure its size matches the source\n        if (this._renderer.context.multiView && CanvasSource.test(resource))\n        {\n            this._renderer.context.ensureCanvasSize(resource);\n        }\n    }\n\n    public postrender(renderTarget: RenderTarget)\n    {\n        // if multiView is not enabled, we don't need to do anything\n        if (!this._renderer.context.multiView) return;\n\n        // if the render target is a canvas, we need to copy the pixels from the gl canvas\n        // to the canvas target\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            const contextCanvas = this._renderer.context.canvas;\n            const canvasSource = renderTarget.colorTexture as unknown as CanvasSource;\n\n            canvasSource.context2D.drawImage(\n                contextCanvas as CanvasImageSource,\n                0, canvasSource.pixelHeight - contextCanvas.height\n            );\n        }\n    }\n}\n"],"names":["source"],"mappings":";;;;;;;;;;;;;;AAkBO,MAAM,qBACb,CAAA;IADO,WAAA,EAAA;QAIH,IAAA,CAAQ,gBAA8B,GAAA;YAAC,CAAG;YAAA,CAAA;YAAG;YAAG,CAAC;SAAA,CAAA;QACzC,IAAA,CAAA,cAAA,GAA4B,0KAAI,YAAU,EAAA,CAAA;IAAA,CAAA;IAE3C,IAAA,CAAK,QAAA,EAAyB,kBACrC,EAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QACjB,IAAA,CAAK,mBAAsB,GAAA,kBAAA,CAAA;QAElB,QAAA,CAAA,OAAA,CAAQ,aAAc,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CAC3C;IAEO,aACP,GAAA;QACI,IAAA,CAAK,gBAAmB,GAAA;YAAC,CAAG;YAAA,CAAA;YAAG;YAAG,CAAC;SAAA,CAAA;QAC9B,IAAA,CAAA,cAAA,GAAiB,0KAAI,YAAU,EAAA,CAAA;IAAA,CACxC;IAEO,aACH,CAAA,0BAAA,EACA,kBACA,EAAA,SAAA,EACA,IAAA,EACA,UAEJ,EAAA;QACI,MAAM,qBAAqB,IAAK,CAAA,mBAAA,CAAA;QAEhC,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAChB,MAAA,cAAA,GAAiB,kBAAmB,CAAA,kBAAA,CAAmB,0BAA0B,CAAA,CAAA;QACvF,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;QAEpB,IAAA,CAAK,gBAAA,CAAiB,0BAA0B,CAAA,CAAA;QAEhD,EAAA,CAAG,eAAgB,CAAA,EAAA,CAAG,WAAa,EAAA,cAAA,CAAe,wBAAwB,CAAA,CAAA;QAEjE,QAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,kBAAA,EAAoB,CAAC,CAAA,CAAA;QAExC,EAAA,CAAA,iBAAA,CAAkB,EAAG,CAAA,UAAA,EAAY,CAAA,EAChC,UAAW,CAAA,CAAA,EAAG,UAAW,CAAA,CAAA,EACzB,SAAU,CAAA,CAAA,EACV,SAAU,CAAA,CAAA,EACV,IAAK,CAAA,KAAA,EACL,IAAK,CAAA,MAAA;QAGF,OAAA,kBAAA,CAAA;IAAA,CACX;IAEO,eACH,CAAA,YAAA,EACA,KAAuB,GAAA,IAAA,EACvB,UAAA,EACA,QAEJ,EAAA;QACI,MAAM,qBAAqB,IAAK,CAAA,mBAAA,CAAA;QAEhC,MAAM,SAAS,YAAa,CAAA,YAAA,CAAA;QACtB,MAAA,eAAA,GAAkB,kBAAmB,CAAA,kBAAA,CAAmB,YAAY,CAAA,CAAA;QAE1E,IAAI,YAAY,QAAS,CAAA,CAAA,CAAA;QAEzB,IAAI,aAAa,MACjB,EAAA;YAEgB,SAAA,GAAA,MAAA,CAAO,WAAA,GAAc,QAAS,CAAA,MAAA,CAAA;QAAA,CAC9C;QAGa,YAAA,CAAA,aAAA,CAAc,OAAQ,CAAA,CAAC,OACpC,KAAA;YACS,IAAA,CAAA,SAAA,CAAU,OAAQ,CAAA,MAAA,CAAO,OAAO,CAAA,CAAA;QAAA,CACxC,CAAA,CAAA;QAEK,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAE1B,EAAA,CAAG,eAAgB,CAAA,EAAA,CAAG,WAAa,EAAA,eAAA,CAAgB,WAAW,CAAA,CAAA;QAE9D,MAAM,gBAAgB,IAAK,CAAA,cAAA,CAAA;QAE3B,IAAI,aAAc,CAAA,CAAA,KAAM,QAAS,CAAA,CAAA,IAC1B,cAAc,CAAM,KAAA,SAAA,IACpB,aAAc,CAAA,KAAA,KAAU,QAAS,CAAA,KAAA,IACjC,aAAc,CAAA,MAAA,KAAW,SAAS,MACzC,EAAA;YACI,aAAA,CAAc,CAAA,GAAI,QAAS,CAAA,CAAA,CAAA;YAC3B,aAAA,CAAc,CAAI,GAAA,SAAA,CAAA;YAClB,aAAA,CAAc,KAAA,GAAQ,QAAS,CAAA,KAAA,CAAA;YAC/B,aAAA,CAAc,MAAA,GAAS,QAAS,CAAA,MAAA,CAAA;YAE7B,EAAA,CAAA,QAAA,CACC,QAAS,CAAA,CAAA,EACT,SAAA,EACA,QAAS,CAAA,KAAA,EACT,QAAS,CAAA,MAAA;QACb,CACJ;QAGA,IAAI,CAAC,eAAgB,CAAA,wBAAA,IAAA,CAA6B,YAAa,CAAA,OAAA,IAAW,aAAa,KACvF,CAAA,EAAA;YACI,IAAA,CAAK,YAAA,CAAa,eAAe,CAAA,CAAA;QAAA,CACrC;QAEK,IAAA,CAAA,KAAA,CAAM,YAAc,EAAA,KAAA,EAAO,UAAU,CAAA,CAAA;IAAA,CAC9C;IAEO,iBAAiB,YACxB,EAAA;QACI,MAAM,qBAAqB,IAAK,CAAA,mBAAA,CAAA;QAE1B,MAAA,cAAA,GAAiB,kBAAmB,CAAA,kBAAA,CAAmB,YAAY,CAAA,CAAA;QAEzE,IAAI,CAAC,cAAe,CAAA,IAAA,EAAM,OAAA;QAEpB,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAE1B,EAAA,CAAG,eAAgB,CAAA,EAAA,CAAG,WAAa,EAAA,cAAA,CAAe,wBAAwB,CAAA,CAAA;QAC1E,EAAA,CAAG,eAAgB,CAAA,EAAA,CAAG,gBAAkB,EAAA,cAAA,CAAe,WAAW,CAAA,CAAA;QAE/D,EAAA,CAAA,eAAA,CACC,CAAA,EAAG,CAAA,EAAG,cAAe,CAAA,KAAA,EAAO,cAAe,CAAA,MAAA,EAC3C,CAAA,EAAG,CAAA,EAAG,cAAe,CAAA,KAAA,EAAO,cAAe,CAAA,MAAA,EAC3C,EAAG,CAAA,gBAAA,EAAkB,EAAG,CAAA,OAAA;QAG5B,EAAA,CAAG,eAAgB,CAAA,EAAA,CAAG,WAAa,EAAA,cAAA,CAAe,WAAW,CAAA,CAAA;IAAA,CAIjE;IAEO,oBAAoB,YAC3B,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEtB,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;QAId,MAAA,cAAA,GAAiB,4LAAI,iBAAe,EAAA,CAAA;QAG1C,MAAM,eAAe,YAAa,CAAA,YAAA,CAAA;QAE9B,IAAA,YAAA,CAAa,QAAa,KAAA,QAAA,CAAS,MACvC,EAAA;YACI,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,gBAAiB,CAAA,YAAA,CAAa,YAAA,CAAa,QAAQ,CAAA,CAAA;YAE1E,cAAA,CAAe,WAAc,GAAA,IAAA,CAAA;YAEtB,OAAA,cAAA,CAAA;QAAA,CACX;QAEK,IAAA,CAAA,UAAA,CAAW,cAAc,cAAc,CAAA,CAAA;QAIzC,EAAA,CAAA,eAAA,CAAgB,EAAG,CAAA,WAAA,EAAa,IAAI,CAAA,CAAA;QAEhC,OAAA,cAAA,CAAA;IAAA,CACX;IAEO,uBAAuB,eAC9B,EAAA;QACU,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAE1B,IAAI,gBAAgB,WACpB,EAAA;YACO,EAAA,CAAA,iBAAA,CAAkB,gBAAgB,WAAW,CAAA,CAAA;YAChD,eAAA,CAAgB,WAAc,GAAA,IAAA,CAAA;QAAA,CAClC;QAEA,IAAI,gBAAgB,wBACpB,EAAA;YACO,EAAA,CAAA,iBAAA,CAAkB,gBAAgB,wBAAwB,CAAA,CAAA;YAC7D,eAAA,CAAgB,wBAA2B,GAAA,IAAA,CAAA;QAAA,CAC/C;QAEA,IAAI,gBAAgB,wBACpB,EAAA;YACO,EAAA,CAAA,kBAAA,CAAmB,gBAAgB,wBAAwB,CAAA,CAAA;YAC9D,eAAA,CAAgB,wBAA2B,GAAA,IAAA,CAAA;QAAA,CAC/C;QAEgB,eAAA,CAAA,gBAAA,CAAiB,OAAQ,CAAA,CAAC,YAC1C,KAAA;YACI,EAAA,CAAG,kBAAA,CAAmB,YAAY,CAAA,CAAA;QAAA,CACrC,CAAA,CAAA;QAED,eAAA,CAAgB,gBAAmB,GAAA,IAAA,CAAA;IAAA,CACvC;IAEO,KAAA,CAAM,aAA6B,EAAA,KAAA,EAAsB,UAChE,EAAA;QACI,IAAI,CAAC,KAAA,EAAO,OAAA;QAEZ,MAAM,qBAAqB,IAAK,CAAA,mBAAA,CAAA;QAG5B,IAAA,OAAO,UAAU,SACrB,EAAA;YACY,KAAA,GAAA,KAAA,kLAAQ,QAAM,CAAA,GAAA,kLAAM,QAAM,CAAA,IAAA,CAAA;QAAA,CACtC;QAEM,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAEtB,IAAA,KAAA,GAAQ,uLAAA,CAAM,KAClB,EAAA;YACI,UAAA,IAAA,CAAA,UAAA,GAAe,kBAAmB,CAAA,iBAAA,CAAA,CAAA;YAElC,MAAM,kBAAkB,IAAK,CAAA,gBAAA,CAAA;YAC7B,MAAM,eAAkB,GAAA,UAAA,CAAA;YAEpB,IAAA,eAAA,CAAgB,CAAC,CAAM,KAAA,eAAA,CAAgB,CAAC,CACrC,IAAA,eAAA,CAAgB,CAAC,CAAA,KAAM,eAAgB,CAAA,CAAC,CAAA,IACxC,eAAgB,CAAA,CAAC,CAAM,KAAA,eAAA,CAAgB,CAAC,CAAA,IACxC,eAAA,CAAgB,CAAC,CAAA,KAAM,eAAgB,CAAA,CAAC,CAC/C,EAAA;gBACoB,eAAA,CAAA,CAAC,CAAI,GAAA,eAAA,CAAgB,CAAC,CAAA,CAAA;gBACtB,eAAA,CAAA,CAAC,CAAI,GAAA,eAAA,CAAgB,CAAC,CAAA,CAAA;gBACtB,eAAA,CAAA,CAAC,CAAI,GAAA,eAAA,CAAgB,CAAC,CAAA,CAAA;gBACtB,eAAA,CAAA,CAAC,CAAI,GAAA,eAAA,CAAgB,CAAC,CAAA,CAAA;gBAEtC,EAAA,CAAG,UAAW,CAAA,eAAA,CAAgB,CAAC,CAAA,EAAG,eAAgB,CAAA,CAAC,CAAG,EAAA,eAAA,CAAgB,CAAC,CAAA,EAAG,eAAgB,CAAA,CAAC,CAAC,CAAA,CAAA;YAAA,CAChG;QAAA,CACJ;QAEA,EAAA,CAAG,KAAA,CAAM,KAAK,CAAA,CAAA;IAAA,CAClB;IAEO,sBAAsB,YAC7B,EAAA;QACI,IAAI,YAAa,CAAA,MAAA,EAAQ,OAAA;QAEzB,MAAM,qBAAqB,IAAK,CAAA,mBAAA,CAAA;QAE1B,MAAA,cAAA,GAAiB,kBAAmB,CAAA,kBAAA,CAAmB,YAAY,CAAA,CAAA;QAEpE,IAAA,CAAA,YAAA,CAAa,cAAc,cAAc,CAAA,CAAA;QAE1C,IAAA,YAAA,CAAa,OAAW,IAAA,YAAA,CAAa,KACzC,EAAA;YACI,IAAA,CAAK,cAAA,CAAe,cAAc,CAAA,CAAA;QAAA,CACtC;IAAA,CACJ;IAEQ,UAAA,CAAW,YAAA,EAA4B,cAC/C,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEtB,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;QAEd,MAAA,wBAAA,GAA2B,GAAG,iBAAkB,EAAA,CAAA;QAEtD,cAAA,CAAe,wBAA2B,GAAA,wBAAA,CAAA;QAGvC,EAAA,CAAA,eAAA,CAAgB,EAAG,CAAA,WAAA,EAAa,wBAAwB,CAAA,CAAA;QAE5C,cAAA,CAAA,KAAA,GAAQ,YAAa,CAAA,YAAA,CAAa,MAAO,CAAA,UAAA,CAAA;QACzC,cAAA,CAAA,MAAA,GAAS,YAAa,CAAA,YAAA,CAAa,MAAO,CAAA,WAAA,CAAA;QAEzD,YAAA,CAAa,aAAc,CAAA,OAAA,CAAQ,CAAC,YAAA,EAAc,CAClD,KAAA;YACI,MAAM,SAAS,YAAa,CAAA,MAAA,CAAA;YAE5B,IAAI,OAAO,SACX,EAAA;gBACQ,IAAA,QAAA,CAAS,OAAQ,CAAA,QAAA,CAAS,IAC9B,EAAA;oBACI,cAAA,CAAe,IAAO,GAAA,IAAA,CAAA;gBAAA,CAG1B,MAAA;wBACI,yKAAA,EAAK,qEAAqE,CAAA,CAAA;gBAAA,CAC9E;YAAA,CACJ;YAGS,QAAA,CAAA,OAAA,CAAQ,UAAW,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;YACrC,MAAM,QAAW,GAAA,QAAA,CAAS,OAAQ,CAAA,WAAA,CAAY,MAAM,CAAA,CAAA;YAEpD,MAAM,YAAY,QAAS,CAAA,OAAA,CAAA;YAExB,EAAA,CAAA,oBAAA,CAAqB,EAAG,CAAA,WAAA,EACvB,GAAG,iBAAoB,GAAA,CAAA,EACvB,IAAA,EAAA,kBAAA;YACA,SAAA,EACA,CAAA;QAAC,CACR,CAAA,CAAA;QAED,IAAI,eAAe,IACnB,EAAA;YACU,MAAA,eAAA,GAAkB,GAAG,iBAAkB,EAAA,CAAA;YAE7C,cAAA,CAAe,WAAc,GAAA,eAAA,CAAA;YAE1B,EAAA,CAAA,eAAA,CAAgB,EAAG,CAAA,WAAA,EAAa,eAAe,CAAA,CAAA;YAElD,YAAA,CAAa,aAAc,CAAA,OAAA,CAAQ,CAAC,CAAA,EAAG,CACvC,KAAA;gBACU,MAAA,gBAAA,GAAmB,GAAG,kBAAmB,EAAA,CAAA;gBAEhC,cAAA,CAAA,gBAAA,CAAiB,CAAC,CAAI,GAAA,gBAAA,CAAA;YAAA,CACxC,CAAA,CAAA;QAAA,CAGL,MAAA;YACI,cAAA,CAAe,WAAc,GAAA,wBAAA,CAAA;QAAA,CACjC;QAEK,IAAA,CAAA,YAAA,CAAa,cAAc,cAAc,CAAA,CAAA;IAAA,CAClD;IAEQ,YAAA,CAAa,YAAA,EAA4B,cACjD,EAAA;QACU,MAAA,MAAA,GAAS,aAAa,YAAa,CAAA,MAAA,CAAA;QAEzC,cAAA,CAAe,KAAA,GAAQ,MAAO,CAAA,UAAA,CAAA;QAC9B,cAAA,CAAe,MAAA,GAAS,MAAO,CAAA,WAAA,CAAA;QAE/B,YAAA,CAAa,aAAc,CAAA,OAAA,CAAQ,CAAC,YAAA,EAAc,CAClD,KAAA;YAEI,IAAI,CAAM,KAAA,CAAA,EAAG,OAAA;YAEb,YAAA,CAAa,MAAA,CAAO,MAAO,CAAA,MAAA,CAAO,KAAA,EAAO,MAAO,CAAA,MAAA,EAAQ,OAAO,WAAW,CAAA,CAAA;QAAA,CAC7E,CAAA,CAAA;QAED,IAAI,eAAe,IACnB,EAAA;YACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;YACtB,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;YAEpB,MAAM,kBAAkB,cAAe,CAAA,WAAA,CAAA;YAEpC,EAAA,CAAA,eAAA,CAAgB,EAAG,CAAA,WAAA,EAAa,eAAe,CAAA,CAAA;YAElD,YAAA,CAAa,aAAc,CAAA,OAAA,CAAQ,CAAC,YAAA,EAAc,CAClD,KAAA;gBACI,MAAMA,UAAS,YAAa,CAAA,MAAA,CAAA;gBAEnB,QAAA,CAAA,OAAA,CAAQ,UAAWA,CAAAA,OAAAA,EAAQ,CAAC,CAAA,CAAA;gBACrC,MAAM,QAAW,GAAA,QAAA,CAAS,OAAQ,CAAA,WAAA,CAAYA,OAAM,CAAA,CAAA;gBAEpD,MAAM,mBAAmB,QAAS,CAAA,cAAA,CAAA;gBAE5B,MAAA,gBAAA,GAAmB,cAAe,CAAA,gBAAA,CAAiB,CAAC,CAAA,CAAA;gBAEvD,EAAA,CAAA,gBAAA,CACC,EAAG,CAAA,YAAA,EACH,gBAAA;gBAGD,EAAA,CAAA,8BAAA,CACC,EAAG,CAAA,YAAA,EACH,CAAA,EACA,gBAAA,EACAA,OAAO,CAAA,UAAA,EACPA,OAAO,CAAA,WAAA;gBAGR,EAAA,CAAA,uBAAA,CACC,EAAG,CAAA,WAAA,EACH,GAAG,iBAAoB,GAAA,CAAA,EACvB,EAAG,CAAA,YAAA,EACH,gBAAA;YACJ,CACH,CAAA,CAAA;QAAA,CACL;IAAA,CACJ;IAEQ,aAAa,cACrB,EAAA;QAEI,IAAI,eAAe,WAAgB,KAAA,IAAA,EAAM,OAAA;QAEnC,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAEpB,MAAA,wBAAA,GAA2B,GAAG,kBAAmB,EAAA,CAAA;QAEvD,cAAA,CAAe,wBAA2B,GAAA,wBAAA,CAAA;QAEvC,EAAA,CAAA,gBAAA,CACC,EAAG,CAAA,YAAA,EACH,wBAAA;QAGD,EAAA,CAAA,uBAAA,CACC,EAAG,CAAA,WAAA,EACH,EAAG,CAAA,wBAAA,EACH,EAAG,CAAA,YAAA,EACH,wBAAA;QAIJ,IAAA,CAAK,cAAA,CAAe,cAAc,CAAA,CAAA;IAAA,CACtC;IAEQ,eAAe,cACvB,EAAA;QACU,MAAA,EAAA,GAAK,IAAA,CAAK,SAAU,CAAA,EAAA,CAAA;QAEvB,EAAA,CAAA,gBAAA,CACC,EAAG,CAAA,YAAA,EACH,cAAe,CAAA,wBAAA;QAGnB,IAAI,eAAe,IACnB,EAAA;YACO,EAAA,CAAA,8BAAA,CACC,EAAG,CAAA,YAAA,EACH,CAAA,EACA,EAAG,CAAA,gBAAA,EACH,cAAe,CAAA,KAAA,EACf,cAAe,CAAA,MAAA;QACnB,CAGJ,MAAA;YACO,EAAA,CAAA,mBAAA,CACC,EAAG,CAAA,YAAA,EACH,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,YAAA,KAAiB,CAClC,GAAA,EAAA,CAAG,gBAAA,GACH,EAAG,CAAA,aAAA,EACT,cAAe,CAAA,KAAA,EACf,cAAe,CAAA,MAAA;QACnB,CACJ;IAAA,CACJ;IAEO,UAAU,YACjB,EAAA;QACU,MAAA,QAAA,GAAW,aAAa,YAAa,CAAA,QAAA,CAAA;QAG3C,IAAI,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,SAAA,oNAAa,eAAa,CAAA,IAAA,CAAK,QAAQ,CAClE,EAAA;YACS,IAAA,CAAA,SAAA,CAAU,OAAQ,CAAA,gBAAA,CAAiB,QAAQ,CAAA,CAAA;QAAA,CACpD;IAAA,CACJ;IAEO,WAAW,YAClB,EAAA;QAEQ,IAAA,CAAC,IAAK,CAAA,SAAA,CAAU,OAAQ,CAAA,SAAA,EAAW,OAAA;QAIvC,oNAAI,eAAa,CAAA,IAAA,CAAK,YAAa,CAAA,YAAA,CAAa,QAAQ,CACxD,EAAA;YACU,MAAA,aAAA,GAAgB,IAAK,CAAA,SAAA,CAAU,OAAQ,CAAA,MAAA,CAAA;YAC7C,MAAM,eAAe,YAAa,CAAA,YAAA,CAAA;YAElC,YAAA,CAAa,SAAU,CAAA,SAAA,CACnB,aAAA,EACA,CAAA,EAAG,YAAA,CAAa,WAAA,GAAc,aAAc,CAAA,MAAA;QAChD,CACJ;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1763, "column": 0}, "map": {"version":3,"file":"isRenderingToScreen.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts"],"sourcesContent":["import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n"],"names":[],"mappings":";;;;AAQO,SAAS,oBAAoB,YACpC,EAAA;IACU,MAAA,QAAA,GAAW,YAAa,CAAA,YAAA,CAAa,MAAO,CAAA,QAAA,CAAA;IAElD,OAAS,WAAW,iBAAqB,IAAA,QAAA,YAAoB,qBAAsB,QAAS,CAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,CAAA,CAAA;AACtH","ignoreList":[0]}},
    {"offset": {"line": 1773, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"file":"calculateProjection.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts"],"sourcesContent":["import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n"],"names":[],"mappings":";;;;AAEO,SAAS,oBACZ,EACA,EAAA,CAAA,EACA,CACA,EAAA,KAAA,EACA,MAAA,EACA,KAEJ,EAAA;IACU,MAAA,IAAA,GAAO,QAAQ,CAAI,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAG,QAAS,EAAA,CAAA;IAET,EAAA,CAAA,CAAA,GAAK,IAAI,KAAQ,GAAA,CAAA,CAAA;IACjB,EAAA,CAAA,CAAA,GAAI,IAAQ,GAAA,CAAA,CAAA,GAAI,MAAS,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAA,EAAA,GAAK,CAAM,CAAA,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IACrB,EAAA,CAAG,EAAK,GAAA,CAAC,IAAQ,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IAEjB,OAAA,EAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1800, "column": 0}, "map": {"version":3,"file":"getCanvasTexture.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts"],"sourcesContent":["import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n"],"names":[],"mappings":";;;;;;;;;AAMA,MAAM,WAAA,GAAA,aAAA,GAAA,IAAuD,GAAI,EAAA,CAAA;AAEjD,SAAA,gBAAA,CAAiB,MAAA,EAAiB,OAClD,EAAA;IACI,IAAI,CAAC,WAAA,CAAY,GAAI,CAAA,MAAM,CAC3B,EAAA;QACU,MAAA,OAAA,GAAU,mMAAI,WAAQ,CAAA;YACxB,MAAA,EAAQ,oNAAI,eAAa,CAAA;gBACrB,QAAU,EAAA,MAAA;gBACV,GAAG,OAAA;YAAA,CACN,CAAA;QAAA,CACJ,CAAA,CAAA;QAED,MAAM,YAAY,MAClB;YACI,IAAI,WAAY,CAAA,GAAA,CAAI,MAAM,CAAA,KAAM,OAChC,EAAA;gBACI,WAAA,CAAY,MAAA,CAAO,MAAM,CAAA,CAAA;YAAA,CAC7B;QAAA,CACJ,CAAA;QAEQ,OAAA,CAAA,IAAA,CAAK,WAAW,SAAS,CAAA,CAAA;QACzB,OAAA,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,SAAS,CAAA,CAAA;QAE5B,WAAA,CAAA,GAAA,CAAI,QAAQ,OAAO,CAAA,CAAA;IAAA,CACnC;IAEO,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC,CAAA;AAEO,SAAS,uBAAuB,MACvC,EAAA;IACW,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC","ignoreList":[0]}},
    {"offset": {"line": 1834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1840, "column": 0}, "map": {"version":3,"file":"RenderTarget.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AA2CO,MAAM,aAAA,GAAN,MAAM,aACb,CAAA;IAAA;;GAAA,GA8CI,WAAA,CAAY,UAAkC,GAAA,CAAA,CAC9C,CAAA;QAzBA,qCAAA,GAAgB,IAAA,CAAA,GAAA,qKAAc,MAAA,EAAI,cAAc,CAAA,CAAA;QAMhD;;;KAAA,GAAA,IAAA,CAAO,aAAA,GAAiC,EAAC,CAAA;QAQzC,IAAA,CAAO,OAAU,GAAA,CAAA,CAAA;QACjB,IAAA,CAAO,MAAS,GAAA,KAAA,CAAA;QAEC,IAAA,CAAA,KAAA,GAAQ,IAAI,YAAA,CAAa,CAAC,CAAA,CAAA;QAE3C,kHAAA,GAAA,IAAA,CAAiB,qBAAiC,GAAA,KAAA,CAAA;QAO9C,UAAA,GAAa;YAAE,GAAG,aAAa,CAAA,cAAA;YAAgB,GAAG,UAAW;QAAA,CAAA,CAAA;QAE7D,IAAA,CAAK,OAAA,GAAU,UAAW,CAAA,OAAA,CAAA;QAC1B,IAAA,CAAK,KAAA,GAAQ,UAAW,CAAA,KAAA,CAAA;QACxB,IAAA,CAAK,MAAA,GAAS,UAAW,CAAA,MAAA,CAAA;QAErB,IAAA,OAAO,UAAW,CAAA,aAAA,KAAkB,QACxC,EAAA;YACI,IAAA,CAAK,qBAAwB,GAAA,IAAA,CAAA;YAE7B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,CAAW,aAAA,EAAe,CAC9C,EAAA,CAAA;gBACI,IAAA,CAAK,aAAc,CAAA,IAAA,CAAK,qNAAI,gBAAc,CAAA;oBACtC,OAAO,UAAW,CAAA,KAAA;oBAClB,QAAQ,UAAW,CAAA,MAAA;oBACnB,YAAY,UAAW,CAAA,UAAA;oBACvB,WAAW,UAAW,CAAA,SAAA;gBAAA,CACzB,CAAA;YACD,CACJ;QAAA,CAGJ,MAAA;YACS,IAAA,CAAA,aAAA,GAAgB,CAAC;mBAAG,UAAW,CAAA,aAAA,CAAc,GAAA,CAAI,CAAC,OAAA,GAAY,OAAQ,CAAA,MAAM,CAAC;aAAA,CAAA;YAE5E,MAAA,WAAA,GAAc,IAAA,CAAK,YAAa,CAAA,MAAA,CAAA;YAEtC,IAAA,CAAK,MAAA,CAAO,WAAY,CAAA,KAAA,EAAO,WAAY,CAAA,MAAA,EAAQ,YAAY,WAAW,CAAA,CAAA;QAAA,CAC9E;QAGA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,EAAA,CAAG,QAAU,EAAA,IAAA,CAAK,cAAA,EAAgB,IAAI,CAAA,CAAA;QAI3D,IAAA,UAAA,CAAW,mBAAuB,IAAA,IAAA,CAAK,OAC3C,EAAA;YAEI,IAAI,UAAW,CAAA,mBAAA,4MAA+B,UACvC,IAAA,UAAA,CAAW,mBAAA,6NAA+B,gBACjD,EAAA;gBACS,IAAA,CAAA,mBAAA,GAAsB,WAAW,mBAAoB,CAAA,MAAA,CAAA;YAAA,CAG9D,MAAA;gBACI,IAAA,CAAK,yBAA0B,EAAA,CAAA;YAAA,CACnC;QAAA,CACJ;IAAA,CACJ;IAEA,IAAI,IACJ,GAAA;QACI,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;QAEb,KAAA,CAAA,CAAC,CAAA,GAAI,IAAK,CAAA,UAAA,CAAA;QACV,KAAA,CAAA,CAAC,CAAA,GAAI,IAAK,CAAA,WAAA,CAAA;QAET,OAAA,KAAA,CAAA;IAAA,CACX;IAEA,IAAI,KACJ,GAAA;QACW,OAAA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,KAAA,CAAA;IAAA,CACpC;IAEA,IAAI,MACJ,GAAA;QACW,OAAA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,MAAA,CAAA;IAAA,CACpC;IACA,IAAI,UACJ,GAAA;QACW,OAAA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,UAAA,CAAA;IAAA,CACpC;IAEA,IAAI,WACJ,GAAA;QACW,OAAA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,WAAA,CAAA;IAAA,CACpC;IAEA,IAAI,UACJ,GAAA;QACW,OAAA,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,WAAA,CAAA;IAAA,CACpC;IAEA,IAAI,YACJ,GAAA;QACW,OAAA,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAA;IAAA,CAC/B;IAEU,eAAe,MACzB,EAAA;QACI,IAAA,CAAK,MAAA,CAAO,MAAO,CAAA,KAAA,EAAO,OAAO,MAAQ,EAAA,MAAA,CAAO,WAAA,EAAa,IAAI,CAAA,CAAA;IAAA,CACrE;IAAA;;;;;GAAA,GAQO,yBACP,GAAA;QACQ,IAAA,CAAC,IAAA,CAAK,mBACV,EAAA;YACS,IAAA,CAAA,mBAAA,GAAsB,qNAAI,gBAAc,CAAA;gBACzC,OAAO,IAAK,CAAA,KAAA;gBACZ,QAAQ,IAAK,CAAA,MAAA;gBACb,YAAY,IAAK,CAAA,UAAA;gBACjB,MAAQ,EAAA,sBAAA;gBACR,mBAAqB,EAAA,KAAA;gBACrB,SAAW,EAAA,KAAA;gBACX,aAAe,EAAA,CAAA;YAAA,CAElB,CAAA,CAAA;QAAA,CACL;IAAA,CACJ;IAEO,OAAO,KAAe,EAAA,MAAA,EAAgB,aAAa,IAAK,CAAA,UAAA,EAAY,mBAAmB,KAC9F,EAAA;QACS,IAAA,CAAA,OAAA,EAAA,CAAA;QAEL,IAAA,CAAK,aAAc,CAAA,OAAA,CAAQ,CAAC,YAAA,EAAc,CAC1C,KAAA;YACI,IAAI,oBAAoB,CAAM,KAAA,CAAA,EAAG,OAAA;YAEjC,YAAA,CAAa,MAAO,CAAA,MAAA,CAAO,KAAO,EAAA,MAAA,EAAQ,UAAU,CAAA,CAAA;QAAA,CACvD,CAAA,CAAA;QAED,IAAI,IAAA,CAAK,mBACT,EAAA;YACI,IAAA,CAAK,mBAAoB,CAAA,MAAA,CAAO,MAAO,CAAA,KAAA,EAAO,QAAQ,UAAU,CAAA,CAAA;QAAA,CACpE;IAAA,CACJ;IAEO,OACP,GAAA;QACI,IAAA,CAAK,YAAA,CAAa,MAAO,CAAA,GAAA,CAAI,QAAU,EAAA,IAAA,CAAK,cAAA,EAAgB,IAAI,CAAA,CAAA;QAEhE,IAAI,IAAA,CAAK,qBACT,EAAA;YACS,IAAA,CAAA,aAAA,CAAc,OAAQ,CAAA,CAAC,OAC5B,KAAA;gBACI,OAAA,CAAQ,OAAQ,EAAA,CAAA;YAAA,CACnB,CAAA,CAAA;QAAA,CACL;QAEA,IAAI,IAAA,CAAK,mBACT,EAAA;YACI,IAAA,CAAK,mBAAA,CAAoB,OAAQ,EAAA,CAAA;YACjC,OAAO,IAAK,CAAA,mBAAA,CAAA;QAAA,CAChB;IAAA,CACJ;AACJ,CAAA,CAAA;AAAA,4CAAA,GAzMa,aAAA,CAGK,cAAsC,GAAA;IAAA,kCAAA,GAEhD,KAAO,EAAA,CAAA;IAAA,mCAAA,GAEP,MAAQ,EAAA,CAAA;IAAA,uCAAA,GAER,UAAY,EAAA,CAAA;IAAA,yFAAA,GAEZ,aAAe,EAAA,CAAA;IAAA,qDAAA,GAEf,OAAS,EAAA,KAAA;IAAA,mDAAA,GAET,KAAO,EAAA,KAAA;IAAA,8CAAA,GAEP,SAAW,EAAA,KAAA;IAAA,2BAAA;IAAA,4EAAA,GAEX,MAAQ,EAAA,KAAA;AACZ,CAAA,CAAA;AApBG,IAAM,YAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 1978, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1984, "column": 0}, "map": {"version":3,"file":"RenderTargetSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2231, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2237, "column": 0}, "map": {"version":3,"file":"GlRenderTargetSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAWO,MAAM,6OAA6B,qBAC1C,CAAA;IASI,YAAY,QACZ,CAAA;QACI,KAAA,CAAM,QAAQ,CAAA,CAAA;QAJX,IAAA,CAAA,OAAA,GAAU,mNAAI,wBAAsB,EAAA,CAAA;QAMlC,IAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,QAAA,EAAU,IAAI,CAAA,CAAA;IAAA,CACpC;AACJ,CAAA;AAAA,YAAA,GAhBa,oBAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;0KAAC,gBAAA,CAAc,WAAW;KAAA;IAChC,IAAM,EAAA,cAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2262, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2268, "column": 0}, "map": {"version":3,"file":"getAttributeInfoFromFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts"],"sourcesContent":["import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2435, "column": 0}, "map": {"version":3,"file":"ensureAttributes.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAiBgB,SAAA,gBAAA,CACZ,QAAA,EACA,aAEJ,EAAA;IACe,IAAA,MAAA,CAAA,IAAK,SAAS,UACzB,CAAA;QACU,MAAA,SAAA,GAAY,QAAS,CAAA,UAAA,CAAW,CAAC,CAAA,CAAA;QACjC,MAAA,aAAA,GAAgB,aAAA,CAAc,CAAC,CAAA,CAAA;QAErC,IAAI,aACJ,EAAA;YACc,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,QAAA,IAAA,CAAV,SAAU,CAAA,QAAA,GAAa,aAAc,CAAA,QAAA,CAAA,CAAA;QAAA,CAGzC,MAAA;aAES,4KAAA,EAAA,CAAA,UAAA,EAAa,CAAC,CAAmG,iGAAA,CAAA,CAAA,CAAA;QAAA,CAC1H;IAAA,CACJ;IAEA,oBAAA,CAAqB,QAAQ,CAAA,CAAA;AACjC,CAAA;AAEA,SAAS,qBAAqB,QAC9B,EAAA;IACU,MAAA,EAAE,OAAS,EAAA,UAAA,EAAe,GAAA,QAAA,CAAA;IAEhC,MAAM,aAAqC,CAAA,CAAC,CAAA;IAC5C,MAAM,YAAoC,CAAA,CAAC,CAAA;IAE3C,IAAA,MAAW,KAAK,OAChB,CAAA;QACU,MAAA,MAAA,GAAS,OAAA,CAAQ,CAAC,CAAA,CAAA;QAEb,UAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;QACf,SAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;IAAA,CAC5B;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,UAAA,CAAW,UAAU,MAAO,CAAA,GAAG,CAAA,KAAK,6PAAA,AAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACrF;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,SAAA,CAAU,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,UAAW,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAEpD,SAAA,CAAU,KAAA,IAAA,CAAV,SAAU,CAAA,KAAA,GAAU,SAAU,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAElD,SAAA,CAAU,UAAU,MAAO,CAAA,GAAG,CAAA,qOAAK,6BAAA,AAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACpF;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2479, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2485, "column": 0}, "map": {"version":3,"file":"getGlTypeFromFormat.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts"],"sourcesContent":["import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n"],"names":[],"mappings":";;;;;;AAIA,MAAM,OAAU,GAAA;IACZ,mMAAS,WAAS,CAAA,aAAA;IAClB,mMAAS,WAAS,CAAA,aAAA;IAClB,mMAAS,WAAS,CAAA,IAAA;IAClB,mMAAS,WAAS,CAAA,IAAA;IAClB,oMAAU,WAAS,CAAA,aAAA;IACnB,oMAAU,WAAS,CAAA,aAAA;IACnB,oMAAU,WAAS,CAAA,IAAA;IACnB,oMAAU,WAAS,CAAA,IAAA;IACnB,oMAAU,WAAS,CAAA,cAAA;IACnB,oMAAU,WAAS,CAAA,cAAA;IACnB,oMAAU,WAAS,CAAA,KAAA;IACnB,oMAAU,WAAS,CAAA,KAAA;IACnB,qMAAW,WAAS,CAAA,cAAA;IACpB,qMAAW,WAAS,CAAA,cAAA;IACpB,qMAAW,WAAS,CAAA,KAAA;IACpB,qMAAW,WAAS,CAAA,KAAA;IACpB,qMAAW,WAAS,CAAA,UAAA;IACpB,qMAAW,WAAS,CAAA,UAAA;IACpB,mMAAS,WAAS,CAAA,KAAA;IAClB,qMAAW,WAAS,CAAA,KAAA;IACpB,qMAAW,WAAS,CAAA,KAAA;IACpB,qMAAW,WAAS,CAAA,KAAA;IACpB,kMAAQ,WAAS,CAAA,YAAA;IACjB,oMAAU,WAAS,CAAA,YAAA;IACnB,oMAAU,WAAS,CAAA,YAAA;IACnB,oMAAU,WAAS,CAAA,YAAA;IACnB,kMAAQ,WAAS,CAAA,GAAA;IACjB,oMAAU,WAAS,CAAA,GAAA;IACnB,oMAAU,WAAS,CAAA,GAAA;IACnB,oMAAU,WAAS,CAAA,GAAA;AACvB,CAAA,CAAA;AAEO,SAAS,oBAAoB,MACpC,EAAA;IACW,OAAA,OAAA,CAAQ,MAAM,CAAA,IAAK,OAAQ,CAAA,OAAA,CAAA;AACtC","ignoreList":[0]}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2534, "column": 0}, "map": {"version":3,"file":"GlGeometrySystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof rendering\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n\n        this._renderer.renderableGC.addManagedHash(this, '_geometryVaoHash');\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader ||= this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = programAttrib.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        // Can't use truthiness check to determine if divisor is set,\n                        // since 0 is a valid value for divisor\n                        const divisor = attribute.divisor ?? 1;\n\n                        gl.vertexAttribDivisor(location, divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[topology || geometry.topology];\n\n        instanceCount ??= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2819, "column": 0}, "map": {"version":3,"file":"GlUniformGroupSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @memberof rendering\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @member {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2904, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2910, "column": 0}, "map": {"version":3,"file":"getTestContext.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n"],"names":[],"mappings":";;;;;;AAIA,IAAI,OAAA,CAAA;AAQG,SAAS,cAChB,GAAA;IACI,IAAI,CAAC,OAAA,IAAW,OAAS,EAAA,aAAA,EACzB,EAAA;QACI,MAAM,MAAS,mKAAA,aAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAE7C,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,OAAS,EAAA,CAAA,CAAE,CAAA,CAAA;IAAA,CAC3C;IAEO,OAAA,OAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2926, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2932, "column": 0}, "map": {"version":3,"file":"checkMaxIfStatementsInShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n"],"names":[],"mappings":";;;;AAEA,MAAM,YAAe,GAAA;IACjB,0BAAA;IACA,kBAAA;IACA,mBAAA;IACA,WAAA;IACA,2BAAA;IACA,GAAA;CACJ,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;AAEX,SAAS,kBAAkB,MAC3B,EAAA;IACI,IAAI,GAAM,GAAA,EAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,EAAQ,EAAE,CAC9B,CAAA;QACI,IAAI,IAAI,CACR,EAAA;YACW,GAAA,IAAA,SAAA,CAAA;QAAA,CACX;QAEI,IAAA,CAAA,GAAI,SAAS,CACjB,EAAA;YACI,GAAA,IAAO,CAAA,WAAA,EAAc,CAAC,CAAA,KAAA,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX,CAAA;AAEgB,SAAA,4BAAA,CAA6B,MAAA,EAAgB,EAC7D,EAAA;IACI,IAAI,WAAW,CACf,EAAA;QACU,MAAA,IAAI,MAAM,+DAA+D,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,MAAS,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,eAAe,CAAA,CAAA;IAGjD,IAAA;QACI,MAAO,IACP,CAAA;YACI,MAAM,cAAc,YAAa,CAAA,OAAA,CAAQ,aAAe,EAAA,iBAAA,CAAkB,MAAM,CAAC,CAAA,CAAA;YAE9E,EAAA,CAAA,YAAA,CAAa,QAAQ,WAAW,CAAA,CAAA;YACnC,EAAA,CAAG,aAAA,CAAc,MAAM,CAAA,CAAA;YAEvB,IAAI,CAAC,EAAG,CAAA,kBAAA,CAAmB,MAAQ,EAAA,EAAA,CAAG,cAAc,CACpD,EAAA;gBACI,MAAA,GAAU,SAAS,CAAK,GAAA,CAAA,CAAA;YAAA,CAG5B,MAAA;gBAEI,MAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CAEJ,QAAA;QAEI,EAAA,CAAG,YAAA,CAAa,MAAM,CAAA,CAAA;IAAA,CAC1B;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 2979, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2985, "column": 0}, "map": {"version":3,"file":"maxRecommendedTextures.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts"],"sourcesContent":["import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n"],"names":[],"mappings":";;;;;;;;AAGA,IAAI,wBAA0C,GAAA,IAAA,CAAA;AASvC,SAAS,sBAChB,GAAA;IACQ,IAAA,wBAAA,EAAiC,OAAA,wBAAA,CAAA;IAErC,MAAM,sNAAK,iBAAA,AAAe,EAAA,CAAA;IAGC,wBAAA,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,uBAAuB,CAAA,CAAA;IAG1C,wBAAA,oNAAA,+BAAA,EACvB,wBAAA,EAA0B,EAAA;IAE3B,EAAA,CAAA,YAAA,CAAa,oBAAoB,CAAA,EAAG,WAAY,EAAA,CAAA;IAE5C,OAAA,wBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3010, "column": 0}, "map": {"version":3,"file":"generateProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAmBgB,SAAA,eAAA,CAAgB,EAAA,EAAwB,OACxD,EAAA;IACI,MAAM,+NAAe,gBAAA,AAAc,EAAA,EAAA,EAAI,EAAG,CAAA,aAAA,EAAe,QAAQ,MAAM,CAAA,CAAA;IACvE,MAAM,+NAAe,gBAAA,AAAc,EAAA,EAAA,EAAI,EAAG,CAAA,eAAA,EAAiB,QAAQ,QAAQ,CAAA,CAAA;IAErE,MAAA,YAAA,GAAe,GAAG,aAAc,EAAA,CAAA;IAEnC,EAAA,CAAA,YAAA,CAAa,cAAc,YAAY,CAAA,CAAA;IACvC,EAAA,CAAA,YAAA,CAAa,cAAc,YAAY,CAAA,CAAA;IAE1C,MAAM,4BAA4B,OAAQ,CAAA,yBAAA,CAAA;IAE1C,IAAI,yBACJ,EAAA;QACQ,IAAA,OAAO,EAAG,CAAA,yBAAA,KAA8B,UAC5C,EAAA;kLAEI,OAAA,EAAK,CAA6E,2EAAA,CAAA,CAAA,CAAA;QAAA,CAItF,MAAA;YACO,EAAA,CAAA,yBAAA,CACC,YAAA,EACA,yBAA0B,CAAA,KAAA,EAC1B,yBAA0B,CAAA,UAAA,KAAe,UACnC,GAAA,EAAA,CAAG,gBAAA,GACH,EAAG,CAAA,mBAAA;QACb,CACJ;IAAA,CACJ;IAEA,EAAA,CAAG,WAAA,CAAY,YAAY,CAAA,CAAA;IAE3B,IAAI,CAAC,EAAG,CAAA,mBAAA,CAAoB,YAAc,EAAA,EAAA,CAAG,WAAW,CACxD,EAAA;0NACoB,kBAAA,EAAA,EAAA,EAAI,YAAc,EAAA,YAAA,EAAc,YAAY,CAAA,CAAA;IAAA,CAChE;IAKA,OAAA,CAAQ,cAAiB,oOAAA,iCAAA,EACrB,YAAA,EACA,EAAA,EACA,CAAE,gDAAA,CAAkD,IAAK,CAAA,OAAA,CAAQ,MAAM,CAAA;IAGnE,OAAA,CAAA,YAAA,oNAAe,iBAAA,AAAe,EAAA,YAAA,EAAc,EAAE,CAAA,CAAA;IAC9C,OAAA,CAAA,iBAAA,gNAAoB,aAAA,AAAW,EAAA,YAAA,EAAc,EAAE,CAAA,CAAA;IAEvD,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA,CAAA;IAC5B,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA,CAAA;IAE5B,MAAM,cAA+C,CAAA,CAAC,CAAA;IAE3C,IAAA,MAAA,CAAA,IAAK,QAAQ,YACxB,CAAA;QACU,MAAA,IAAA,GAAO,OAAQ,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;QAEnC,WAAA,CAAY,CAAC,CAAI,GAAA;YACb,QAAU,EAAA,EAAA,CAAG,kBAAmB,CAAA,YAAA,EAAc,CAAC,CAAA;YAC/C,KAAO,iNAAA,eAAA,EAAa,IAAK,CAAA,IAAA,EAAM,KAAK,IAAI,CAAA;QAAA,CAC5C,CAAA;IAAA,CACJ;IAEA,MAAM,SAAY,GAAA,qMAAI,gBAAc,CAAA,YAAA,EAAc,WAAW,CAAA,CAAA;IAEtD,OAAA,SAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3066, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3072, "column": 0}, "map": {"version":3,"file":"types.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts"],"sourcesContent":["// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n"],"names":[],"mappings":";;;;;AACO,MAAM,oBAAuB,GAAA;IAChC,KAAA;IACA,KAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;CACJ,CAAA;AAGO,MAAM,iBAAoB,GAAA,oBAAA,CAAqB,MAAO,CAAA,CAAC,KAAK,IACnE,KAAA;IACI,GAAA,CAAI,IAAI,CAAI,GAAA,IAAA,CAAA;IAEL,OAAA,GAAA,CAAA;AACX,CAAA,EAAG,CAAA,CAAoC","ignoreList":[0]}},
    {"offset": {"line": 3102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3108, "column": 0}, "map": {"version":3,"file":"getDefaultUniformValue.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts"],"sourcesContent":["/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n"],"names":[],"mappings":";;;;AAMgB,SAAA,sBAAA,CACZ,IAAA,EACA,IAEJ,EAAA;IACI,OAAQ,IACR;QACI,KAAK,KAAA;YACM,OAAA,CAAA,CAAA;QAEX,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QACpC,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBACxB,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEb,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC3B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACN,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEhB,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC9B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;IAAA,CACvB;IAEO,OAAA,IAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3171, "column": 0}, "map": {"version":3,"file":"createIdFromString.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts"],"sourcesContent":["const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,QAAA,GAAA,aAAA,GAA0C,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAC3D,MAAM,MAAA,GAAA,aAAA,GAAwC,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAEzC,SAAA,kBAAA,CAAmB,KAAA,EAAe,OAClD,EAAA;IACQ,IAAA,EAAA,GAAK,MAAA,CAAO,KAAK,CAAA,CAAA;IAErB,IAAI,OAAO,KACX,CAAA,EAAA;QACQ,IAAA,QAAA,CAAS,OAAO,CAAA,KAAM,KAC1B,CAAA,EAAA;YACI,QAAA,CAAS,OAAO,CAAI,GAAA,CAAA,CAAA;QAAA,CACxB;QAEA,MAAA,CAAO,KAAK,CAAA,GAAI,EAAK,GAAA,QAAA,CAAS,OAAO,CAAA,EAAA,CAAA;IAAA,CACzC;IAEO,OAAA,EAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3195, "column": 0}, "map": {"version":3,"file":"UniformGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts"],"sourcesContent":["import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAoFO,MAAM,aAAA,GAAN,MAAM,aACb,CAAA;IAAA;;;;GAAA,GAsDI,WAAA,CAAY,iBAAA,EAA6B,OACzC,CAAA;QA7CA,gFAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAGlB,iEAAA,GAAgB,IAAA,CAAA,GAAA,qKAAc,MAAA,EAAI,SAAS,CAAA,CAAA;QAE3C,kGAAA,GAAA,IAAA,CAAO,aAAgB,GAAA,cAAA,CAAA;QAEvB,6EAAA,GAAO,IAAA,CAAA,WAAA,qKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAenC,iDAAA,GAAA,IAAA,CAAgB,cAAiB,GAAA,IAAA,CAAA;QAMjC;;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QASlB,8DAAA;QAAA,IAAA,CAAgB,SAAY,GAAA,KAAA,CAAA;QASxB,OAAA,GAAU;YAAE,GAAG,aAAa,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEvD,IAAA,CAAK,iBAAoB,GAAA,iBAAA,CAAA;QAEzB,MAAM,WAAW,CAAA,CAAC,CAAA;QAElB,IAAA,MAAW,KAAK,iBAChB,CAAA;YACU,MAAA,WAAA,GAAc,iBAAA,CAAkB,CAAC,CAAA,CAAA;YAEvC,WAAA,CAAY,IAAO,GAAA,CAAA,CAAA;YACP,WAAA,CAAA,IAAA,GAAO,YAAY,IAAQ,IAAA,CAAA,CAAA;YAEvC,IAAI,8LAAC,oBAAA,CAAkB,WAAY,CAAA,IAAI,CACvC,EAAA;gBAEU,MAAA,IAAI,KAAM,CAAA,CAAA,aAAA,EAAgB,WAAY,CAAA,IAAI,CAAA,gDAAA,+LAAmD,uBAAqB,CAAA,IAAA,CAAK,IAAI,CAAC,CAAE,CAAA,CAAA,CAAA;YAAA,CACxI;YAEA,WAAA,CAAY,KAAA,IAAA,CAAZ,WAAY,CAAA,KAAA,8NAAU,yBAAA,EAAuB,WAAY,CAAA,IAAA,EAAM,YAAY,IAAI,CAAA,CAAA,CAAA;YAEtE,QAAA,CAAA,CAAC,CAAA,GAAI,WAAY,CAAA,KAAA,CAAA;QAAA,CAC9B;QAEA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;QAEhB,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA;QAChB,IAAA,CAAK,GAAA,GAAM,OAAQ,CAAA,GAAA,CAAA;QACnB,IAAA,CAAK,QAAA,GAAW,OAAQ,CAAA,QAAA,CAAA;QAExB,IAAA,CAAK,UAAa,IAAA,iOAAA,EAAmB,MAAO,CAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,GAAA,CACvD,CAAC,IAAM,CAAG,EAAA,CAAC,CAAA,CAAA,EAAK,iBAAkB,CAAA,CAAmC,CAAA,CAAkB,IAAI,CAAA,CAAA,EAC7F,IAAA,CAAK,GAAG,CAAA,EAAG,eAAe,CAAA,CAAA;IAAA,CAChC;IAAA,+GAAA,GAGO,MACP,GAAA;QACS,IAAA,CAAA,QAAA,EAAA,CAAA;IAAA,CAET;AACJ,CAAA,CAAA;AAAA,mDAAA,GAlGa,aAAA,CAGK,cAAsC,GAAA;IAAA,qEAAA,GAEhD,GAAK,EAAA,KAAA;IAAA,qGAAA,GAEL,QAAU,EAAA,KAAA;AACd,CAAA,CAAA;AARG,IAAM,YAAN,GAAA","ignoreList":[0]}},
    {"offset": {"line": 3258, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3264, "column": 0}, "map": {"version":3,"file":"BufferResource.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AA0BO,MAAM,gNAAuB,UAGpC,CAAA;IAAA;;;;;;;;GAAA,GA2DI,WAAY,CAAA,EAAE,MAAQ,EAAA,MAAA,EAAQ,IAAA,EAC9B,CAAA;QACU,KAAA,EAAA,CAAA;QArDV;;;;KAAA,GAAA,iEAAA,GAAgB,IAAA,CAAA,GAAA,qKAAc,MAAA,EAAI,QAAQ,CAAA,CAAA;QAO1C;;;;KAAA,GAAA,IAAA,CAAgB,aAAgB,GAAA,gBAAA,CAAA;QAOhC;;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAOlB;;;;KAAA,GAAO,IAAA,CAAA,WAAA,qKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAanC;;;;KAAA,GAAA,IAAA,CAAgB,eAAkB,GAAA,IAAA,CAAA;QAMlC;;;KAAA,GAAA,IAAA,CAAO,SAAY,GAAA,KAAA,CAAA;QAef,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QACd,IAAA,CAAK,MAAA,GAAS,MAAS,GAAA,CAAA,CAAA;QACvB,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QAEZ,IAAA,CAAK,MAAO,CAAA,EAAA,CAAG,QAAU,EAAA,IAAA,CAAK,cAAA,EAAgB,IAAI,CAAA,CAAA;IAAA,CACtD;IAEU,cACV,GAAA;QACS,IAAA,CAAA,WAAA,qKAAc,MAAA,EAAI,UAAU,CAAA,CAAA;QAE5B,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOO,OAAA,CAAQ,gBAAgB,KAC/B,EAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QAEjB,IAAI,aACJ,EAAA;YACI,IAAA,CAAK,MAAA,CAAO,OAAQ,EAAA,CAAA;QAAA,CACxB;QAEK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;QAExB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3337, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3343, "column": 0}, "map": {"version":3,"file":"GenerateShaderSyncCode.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts"],"sourcesContent":["import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    const resName = shader._uniformBindMap[i][Number(j)];\n\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                const resName = shader._uniformBindMap[i][Number(j)];\n\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAYgB,SAAA,sBAAA,CAAuB,MAAA,EAAgB,YACvD,EAAA;IACI,MAAM,gBAA0B,EAAC,CAAA;IAWjC,MAAM,kBAA4B;QAAC,CAAA;;;;;;IAMlC,CAAA;KAAA,CAAA;IAED,IAAI,iBAAoB,GAAA,KAAA,CAAA;IACxB,IAAI,YAAe,GAAA,CAAA,CAAA;IAEnB,MAAM,WAAc,GAAA,YAAA,CAAa,eAAgB,CAAA,MAAA,CAAO,SAAS,CAAA,CAAA;IAEtD,IAAA,MAAA,CAAA,IAAK,OAAO,MACvB,CAAA;QACU,MAAA,KAAA,GAAQ,MAAO,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;QAE7B,aAAA,CAAc,IAAK,CAAA,CAAA;0BAAA,EACC,CAAC,CAAA;QACpB,CAAA,CAAA,CAAA;QAEU,IAAA,MAAA,CAAA,IAAK,MAAM,SACtB,CAAA;YACU,MAAA,QAAA,GAAW,KAAM,CAAA,SAAA,CAAU,CAAC,CAAA,CAAA;YAElC,IAAI,wNAAoB,eACxB,EAAA;gBACI,IAAI,SAAS,GACb,EAAA;oBACI,MAAM,UAAU,MAAO,CAAA,eAAA,CAAgB,CAAC,CAAE,CAAA,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA;oBAEnD,aAAA,CAAc,IAAK,CAAA,CAAA;;sCAAA,EAEC,CAAC,CAAA;6BAAA,EACV,OAAO,CAAA;4BAAA,EACR,MAAO,CAAA,SAAA,CAAU,iBAAkB,CAAA,OAAO,CAAA,CAAE,KAAK,CAAA;;oBAE1D,CAAA,CAAA,CAAA;gBAAA,CAGL,MAAA;oBACI,aAAA,CAAc,IAAK,CAAA,CAAA;yDAAA,EACoB,CAAC,CAAA;oBACvC,CAAA,CAAA,CAAA;gBAAA,CACL;YAAA,CACJ,MAAA,IACS,0NAAoB,iBAC7B,EAAA;gBACI,MAAM,UAAU,MAAO,CAAA,eAAA,CAAgB,CAAC,CAAE,CAAA,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA;gBAEnD,aAAA,CAAc,IAAK,CAAA,CAAA;;kCAAA,EAEC,CAAC,CAAA;yBAAA,EACV,OAAO,CAAA;wBAAA,EACR,MAAO,CAAA,SAAA,CAAU,iBAAkB,CAAA,OAAO,CAAA,CAAE,KAAK,CAAA;;gBAE1D,CAAA,CAAA,CAAA;YAAA,CACL,MAAA,IACS,qOAAoB,gBAC7B,EAAA;gBACI,MAAM,WAAc,GAAA,MAAA,CAAO,eAAgB,CAAA,CAAsB,CAAA,CAAE,CAAsB,CAAA,CAAA;gBAEnF,MAAA,WAAA,GAAc,WAAY,CAAA,WAAA,CAAY,WAAW,CAAA,CAAA;gBAEvD,IAAI,WACJ,EAAA;oBACI,IAAI,CAAC,iBACL,EAAA;wBACwB,iBAAA,GAAA,IAAA,CAAA;wBACpB,eAAA,CAAgB,IAAK,CAAA,CAAA;;wBAEpB,CAAA,CAAA,CAAA;oBAAA,CACL;oBAEA,YAAA,CAAa,GAAI,CAAA,SAAA,CAAU,WAAY,CAAA,QAAA,EAAU,YAAY,CAAA,CAAA;oBAE7D,aAAA,CAAc,IAAK,CAAA,CAAA;0CACK,EAAA,CAAC,CAAA,GAAA,EAAM,YAAY,CAAA;oBAC1C,CAAA,CAAA,CAAA;oBAED,YAAA,EAAA,CAAA;gBAAA,CACJ;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAEM,MAAA,cAAA,GAAiB,CAAC;WAAG,eAAA,EAAiB;WAAG,aAAa;KAAA,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;IAGvE,OAAO,IAAI,QAAA,CAAS,GAAK,EAAA,GAAA,EAAK,MAAM,cAAc,CAAA,CAAA;AACtD","ignoreList":[0]}},
    {"offset": {"line": 3425, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3431, "column": 0}, "map": {"version":3,"file":"GlShaderSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getMaxTexturesPerBatch } from '../../../batcher/gl/utils/maxRecommendedTextures';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { ShaderSystem } from '../../shared/shader/ShaderSystem';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @memberof rendering\n */\nexport class GlShaderSystem implements ShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    public maxTextures: number;\n\n    /**\n     * @internal\n     * @private\n     */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_programDataHash');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n        this.maxTextures = getMaxTexturesPerBatch();\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     * @private\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3563, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3569, "column": 0}, "map": {"version":3,"file":"GlEncoderSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @memberof rendering\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAaO,MAAM,eACb,CAAA;IAYI,YAAY,QACZ,CAAA;QAJgB,IAAA,CAAA,eAAA,GAAkB,QAAQ,OAAQ,EAAA,CAAA;QAK9C,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,WAAA,CAAY,QAAA,EAAoB,MACvC,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,QAAA,CAAS,IAAK,CAAA,QAAA,EAAU,OAAO,SAAS,CAAA,CAAA;IAAA,CAC3D;IAEO,gBACP,GAAA,CAAA,CAEA;IAEO,KAAK,OAUZ,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAChB,MAAA,EAAE,QAAU,EAAA,MAAA,EAAQ,KAAO,EAAA,QAAA,EAAU,UAAU,IAAM,EAAA,IAAA,EAAM,KAAO,EAAA,aAAA,EAAkB,GAAA,OAAA,CAAA;QAEjF,QAAA,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,EAAQ,QAAQ,CAAA,CAAA;QAErC,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,QAAU,EAAA,QAAA,CAAS,MAAA,CAAO,cAAc,CAAA,CAAA;QAE/D,IAAI,KACJ,EAAA;YACa,QAAA,CAAA,KAAA,CAAM,GAAA,CAAI,KAAK,CAAA,CAAA;QAAA,CAC5B;QAEA,QAAA,CAAS,QAAA,CAAS,IAAK,CAAA,IAAA,EAAM,MAAM,KAAO,EAAA,aAAA,IAAiB,SAAS,aAAa,CAAA,CAAA;IAAA,CACrF;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ,CAAA;AAAA,YAAA,GA1Da,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;0KACF,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,SAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3606, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3612, "column": 0}, "map": {"version":3,"file":"State.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts"],"sourcesContent":["import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3768, "column": 0}, "map": {"version":3,"file":"mapWebGLBlendModesToPixi.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n\n    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());\n\n    if (isWebGl2)\n    {\n        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n    }\n    else\n    {\n        const ext = gl.getExtension('EXT_blend_minmax');\n\n        if (ext)\n        {\n            blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n            blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n        }\n    }\n\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n"],"names":[],"mappings":";;;;;;AAUO,SAAS,yBAAyB,EACzC,EAAA;IACI,MAAM,WAAmD,CAAA,CAAC,CAAA;IAI1D,QAAA,CAAS,MAAS,GAAA;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,mBAAmB;KAAA,CAAA;IACjD,QAAA,CAAS,GAAM,GAAA;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,GAAG;KAAA,CAAA;IACrB,QAAA,CAAA,QAAA,GAAW;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IAChF,QAAA,CAAA,MAAA,GAAS;QAAC,EAAG,CAAA,GAAA;QAAK,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IACxE,QAAA,CAAA,IAAA,GAAO;QAAC,CAAA;QAAG,CAAC;KAAA,CAAA;IAGZ,QAAA,CAAA,YAAY,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IACrF,QAAA,CAAA,SAAS,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,GAAK;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,GAAG;KAAA,CAAA;IAClD,QAAA,CAAA,YAAY,CAAI,GAAA;QAAC,EAAG,CAAA,SAAA;QAAW,GAAG,mBAAqB;QAAA,EAAA,CAAG,GAAK;QAAA,EAAA,CAAG,mBAAmB;KAAA,CAAA;IAE9F,QAAA,CAAS,KAAQ,GAAA;QAAC,EAAG,CAAA,IAAA;QAAM,GAAG,mBAAmB;KAAA,CAAA;IAEjD,MAAM,WAAW,CAAA,CAAE,EAAA,4KAAc,aAAW,CAAA,GAAA,GAAM,wBAAyB,EAAA,CAAA,CAAA;IAE3E,IAAI,QACJ,EAAA;QACI,QAAA,CAAS,GAAM,GAAA;YAAC,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,GAAG,GAAG;SAAA,CAAA;QAC9D,QAAA,CAAS,GAAM,GAAA;YAAC,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,EAAG,CAAA,GAAA;YAAK,GAAG,GAAG;SAAA,CAAA;IAAA,CAGlE,MAAA;QACU,MAAA,GAAA,GAAM,EAAG,CAAA,YAAA,CAAa,kBAAkB,CAAA,CAAA;QAE9C,IAAI,GACJ,EAAA;YACI,QAAA,CAAS,GAAM,GAAA;gBAAC,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,GAAI,CAAA,OAAA;gBAAS,IAAI,OAAO;aAAA,CAAA;YACxE,QAAA,CAAS,GAAM,GAAA;gBAAC,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,EAAG,CAAA,GAAA;gBAAK,GAAI,CAAA,OAAA;gBAAS,IAAI,OAAO;aAAA,CAAA;QAAA,CAC5E;IAAA,CACJ;IAeO,OAAA,QAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 3865, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3871, "column": 0}, "map": {"version":3,"file":"GlStateSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @memberof rendering\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @member {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @member {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        this.reset();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state ||= this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff >>= 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state ||= this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    // used\n    /** Resets all the logic and disables the VAOs. */\n    public reset(): void\n    {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4068, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4074, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts"],"sourcesContent":["/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n"],"names":["STENCIL_MODES"],"mappings":";;;;;AA2CO,MAAM,YAAe,GAAA;IACxB,MAAQ,EAAA,YAAA;IACR,GAAK,EAAA,SAAA;IACL,MAAQ,EAAA,YAAA;AACZ,EAAA;AAMY,IAAA,aAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,cAAL,KAAA;IAEHA,cAAAA,CAAAA,cAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,qBAAA,GAAqB,CAArB,CAAA,GAAA,oBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,cAAA,GAAc,CAAd,CAAA,GAAA,aAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,sBAAA,GAAsB,CAAtB,CAAA,GAAA,qBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,wBAAA,GAAwB,CAAxB,CAAA,GAAA,uBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,cAAAA,CAAAA;AAAA,CAAA,EAAA,aAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4101, "column": 0}, "map": {"version":3,"file":"GpuStencilModesToPixi.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts"],"sourcesContent":["import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n};\n"],"names":[],"mappings":";;;;;;AAgBO,MAAM,wBAAwC,EAAA,CAAC;AAEtD,qBAAsB,6LAAA,gBAAA,CAAc,IAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAE5C,qBAAsB,6LAAA,gBAAA,CAAc,QAAQ,CAAI,GAAA;IAC5C,gBAAkB,EAAA,CAAA;IAClB,eAAiB,EAAA,CAAA;AACrB,CAAA,CAAA;AAEA,qBAAsB,6LAAA,gBAAA,CAAc,kBAAkB,CAAI,GAAA;IACtD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,6LAAA,gBAAA,CAAc,qBAAqB,CAAI,GAAA;IACzD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,6LAAA,gBAAA,CAAc,WAAW,CAAI,GAAA;IAC/C,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,6LAAA,gBAAA,CAAc,mBAAmB,CAAI,GAAA;IACvD,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,SAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,SAAA;IAAA,CACZ;AACJ,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4163, "column": 0}, "map": {"version":3,"file":"GlStencilSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4255, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4261, "column": 0}, "map": {"version":3,"file":"GlColorMaskSystem.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @memberof rendering\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n"],"names":[],"mappings":";;;;;;AASO,MAAM,iBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QAHA,IAAA,CAAQ,eAAkB,GAAA,EAAA,CAAA;QAItB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,QAAQ,SACf,EAAA;QACI,IAAI,IAAA,CAAK,eAAoB,KAAA,SAAA,EAAW,OAAA;QACxC,IAAA,CAAK,eAAkB,GAAA,SAAA,CAAA;QAEvB,IAAA,CAAK,SAAA,CAAU,EAAG,CAAA,SAAA,CACd,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA,EACf,CAAC,CAAA,CAAE,SAAY,GAAA,CAAA,CAAA;IACnB,CACJ;AAGJ,CAAA;AAAA,YAAA,GAhCa,iBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;0KACF,gBAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4292, "column": 0}, "map": {"version":3,"file":"GlBatchAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _didUpload = false;\n    private readonly _tempState = State.for2d();\n\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUpload = false;\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, this._didUpload);\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._didUpload = true;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAcO,MAAM,cACb,CAAA;IADO,WAAA,EAAA;QAUH,IAAA,CAAQ,UAAa,GAAA,KAAA,CAAA;QACJ,IAAA,CAAA,UAAA,+LAAa,QAAA,CAAM,KAAM,EAAA,CAAA;IAAA,CAAA;IAEnC,KAAK,WACZ,EAAA;QACI,WAAA,CAAY,QAAS,CAAA,OAAA,CAAQ,aAAc,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CACvD;IAEO,aACP,GAAA;QACI,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;IAAA,CACtB;IAEO,KAAA,CAAM,SAAwB,EAAA,QAAA,EAAoB,MACzD,EAAA;QACI,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAG3B,QAAA,CAAS,MAAO,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAE5C,QAAA,CAAS,MAAO,CAAA,kBAAA,CAAmB,QAAS,CAAA,cAAA,CAAe,YAAY,CAAA,CAAA;QAEvE,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,QAAU,EAAA,MAAA,CAAO,SAAS,CAAA,CAAA;IAAA,CACrD;IAEO,OAAA,CAAQ,SAAA,EAAwB,KACvC,EAAA;QACI,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAE3B,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAEb,IAAA,CAAA,UAAA,CAAW,SAAA,GAAY,KAAM,CAAA,SAAA,CAAA;QAEzB,QAAA,CAAA,KAAA,CAAM,GAAI,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAE5B,MAAA,QAAA,GAAW,MAAM,QAAS,CAAA,QAAA,CAAA;QAEhC,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,QAAA,CAAS,KAAA,EAAO,CAC1C,EAAA,CAAA;YACI,QAAA,CAAS,OAAQ,CAAA,IAAA,CAAK,QAAS,CAAA,CAAC,CAAA,EAAG,CAAC,CAAA,CAAA;QAAA,CACxC;QAEA,QAAA,CAAS,QAAA,CAAS,IAAK,CAAA,KAAA,CAAM,QAAA,EAAU,KAAM,CAAA,IAAA,EAAM,MAAM,KAAK,CAAA,CAAA;IAAA,CAClE;AACJ,CAAA;AAAA,YAAA,GAtDa,cAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;0KACF,gBAAc,CAAA,iBAAA;KAClB;IACA,IAAM,EAAA,OAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4337, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4343, "column": 0}, "map": {"version":3,"file":"compileInputs.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts"],"sourcesContent":["function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAA,CAAc,cAAA,EAAwB,GAC/C,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,iBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAEO,SAAS,aAAc,CAAA,SAAA,EAAkB,QAAkB,EAAA,IAAA,GAAO,KACzE,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,aAAA,CAAc,UAAU,OAAO,CAAA,CAAA;IAErB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACkB,aAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC1C;IAAA,CACH,CAAA,CAAA;IAGD,MAAM,SAAY,GAAA,OAAA,CAAA;IAElB,IAAI,IACJ,EAAA;QACI,SAAA,CAAU,IAAK,EAAA,CAAA;IAAA,CACnB;IAEA,MAAM,WAAc,GAAA,SAAA,CACf,GAAI,CAAA,CAAC,OAAS,EAAA,CAAA,GAAM,CAAoB,iBAAA,EAAA,CAAC,CAAK,EAAA,EAAA,OAAO,CAAG,CAAA,CAAA,CAAA,CACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,IAAI,aAAgB,GAAA,QAAA,CAAS,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAAA,CAAA;IAE3C,aAAA,GAAA,aAAA,CAAc,OAAA,CAAQ,QAAU,EAAA,CAAA;AAAA,EAAK,WAAW,CAAA;AAAA,CAAI,CAAA,CAAA;IAE7D,OAAA,aAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4381, "column": 0}, "map": {"version":3,"file":"compileOutputs.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts"],"sourcesContent":["function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,cAAA,CAAe,cAAA,EAAwB,GAChD,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,kBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAEA,SAAS,oBAAoB,KAC7B,EAAA;IACI,MAAM,KAAQ,GAAA,cAAA,CAAA;IAER,MAAA,KAAA,GAAQ,KAAM,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAEvB,OAAA,KAAA,GAAQ,KAAM,CAAA,CAAC,CAAI,GAAA,EAAA,CAAA;AAC9B,CAAA;AAEA,SAAS,cAAc,KACvB,EAAA;IACI,MAAM,KAAQ,GAAA,UAAA,CAAA;IAEP,OAAA,KAAA,CAAM,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAA,CAAA;AAClC,CAAA;AAEgB,SAAA,cAAA,CAAe,SAAA,EAAkB,QACjD,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,cAAA,CAAe,UAAU,OAAO,CAAA,CAAA;IAEtB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACmB,cAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC3C;IAAA,CACH,CAAA,CAAA;IAED,IAAI,KAAQ,GAAA,CAAA,CAAA;IAGZ,MAAM,aAAa,OACd,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OACN,KAAA;QACI,IAAI,OAAQ,CAAA,OAAA,CAAQ,SAAS,CAAA,GAAI,CACjC,CAAA,EAAA;YACW,OAAA,OAAA,CAAA;QAAA,CACX;QAEO,OAAA,CAAA,UAAA,EAAa,KAAO,EAAA,CAAA,EAAA,EAAK,OAAO,CAAA,CAAA,CAAA;IAAA,CAC1C,CACA,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAGf,MAAM,SAAY,GAAA,OAAA,CACb,IAAK,EAAA,CACL,GAAA,CAAI,CAAC,OAAA,GAAY,CAAc,WAAA,EAAA,aAAA,CAAc,OAAO,CAAC,CAAG,CAAA,CAAA,CAAA,CACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,MAAM,OAAU,GAAA,CAAA;YAAA,EACN,OACG,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OAAY,GAAA,CAAA,CAAA,EAAI,mBAAoB,CAAA,OAAO,CAAC,CAAA,CAAE,CACnD,CAAA,IAAA,CAAK,KAAK,CAAC,CAAA,EAAA,CAAA,CAAA;IAGxB,IAAI,YAAe,GAAA,QAAA,CAAS,OAAQ,CAAA,mBAAA,EAAqB,EAAE,CAAA,CAAA;IAE5C,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,CAAA;AAAA,EAAK,UAAU,CAAA;AAAA,CAAI,CAAA,CAAA;IACtD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,WAAa,EAAA,CAAA;AAAA,EAAK,SAAS,CAAA;AAAA,CAAI,CAAA,CAAA;IACpD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,CAAA;AAAA,EAAK,OAAO,CAAA;AAAA,CAAI,CAAA,CAAA;IAE3D,OAAA,YAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4439, "column": 0}, "map": {"version":3,"file":"compileHooks.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts"],"sourcesContent":["export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n"],"names":[],"mappings":";;;;;AAAO,MAAM,WAAc,GAAA,iBAAA;AAMpB,SAAS,aAAa,UAC7B,EAAA;IACI,MAAM,QAAkC,CAAA,CAAC,CAAA;IAEzC,MAAM,WAAc,GAAA,UAAA,CACf,KAAM,CAAA,WAAW,GAChB,GAAI,CAAA,CAAC,IAAS,GAAA,IAAA,CAAK,OAAQ,CAAA,SAAA,EAAW,EAAE,CAAC,KAAK,EAAC,CAAA;IAEzC,WAAA,CAAA,OAAA,CAAQ,CAAC,IACrB,KAAA;QACU,KAAA,CAAA,IAAI,CAAA,GAAI,EAAC,CAAA;IAAA,CAClB,CAAA,CAAA;IAEM,OAAA,KAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4461, "column": 0}, "map": {"version":3,"file":"addBits.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;AAQgB,SAAA,OAAA,CAAQ,QAAkC,EAAA,KAAA,EAAiC,IAC3F,EAAA;IACI,IAAI,QACJ,EAAA;QACI,IAAA,MAAW,KAAK,QAChB,CAAA;YACU,MAAA,EAAA,GAAK,EAAE,iBAAkB,EAAA,CAAA;YAEzB,MAAA,IAAA,GAAO,KAAA,CAAM,EAAE,CAAA,CAAA;YAErB,IAAI,IACJ,EAAA;gBACQ,IAAA,aAAA,GAAgB,QAAA,CAAS,CAAC,CAAA,CAAA;gBAE9B,IAAI,MAAM,QACV,EAAA;oBACI,aAAA,GAAgB,cACX,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAC9B,CAAA,OAAA,CAAQ,qBAAqB,EAAE,CAAA,CAAA;gBAAA,CACxC;gBAEA,IAAI,IACJ,EAAA;oBACS,IAAA,CAAA,IAAA,CAAK,CAAS,MAAA,EAAA,IAAI,CAAQ,MAAA,CAAA,CAAA,CAAA;gBAAA,CACnC;gBACA,IAAA,CAAK,IAAA,CAAK,aAAa,CAAA,CAAA;YAAA,CAI3B,MAAA;sLAES,OAAA,EAAA,CAAA,EAAG,CAAC,CAA0C,wCAAA,CAAA,CAAA,CAAA;YAAA,CAEvD;QAAA,CACJ;IAAA,CACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4495, "column": 0}, "map": {"version":3,"file":"injectBits.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts"],"sourcesContent":["/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n"],"names":[],"mappings":";;;;AAKgB,SAAA,UAAA,CAAW,WAAA,EAAqB,aAChD,EAAA;IACI,IAAI,GAAM,GAAA,WAAA,CAAA;IAEV,IAAA,MAAW,KAAK,aAChB,CAAA;QACU,MAAA,KAAA,GAAQ,aAAA,CAAc,CAAC,CAAA,CAAA;QAEvB,MAAA,QAAA,GAAW,KAAM,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;QAEhC,IAAI,SAAS,MACb,EAAA;YACI,GAAA,GAAM,IAAI,OAAQ,CAAA,CAAA,EAAA,EAAK,CAAC,CAAA,EAAA,CAAA,EAAM,CAAA,OAAA,EAAU,CAAC,CAAA;AAAA,EAAkB,KAAA,CAAM,IAAK,CAAA,IAAI,CAAC,CAAA;MAAA,EAAW,CAAC,CAAe,aAAA,CAAA,CAAA,CAAA;QAAA,CAI1G,MAAA;YACI,GAAA,GAAM,GAAI,CAAA,OAAA,CAAQ,CAAK,EAAA,EAAA,CAAC,CAAA,EAAA,CAAA,EAAM,EAAE,CAAA,CAAA;QAAA,CACpC;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4522, "column": 0}, "map": {"version":3,"file":"compileHighShader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts"],"sourcesContent":["import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4586, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4592, "column": 0}, "map": {"version":3,"file":"defaultProgramTemplate.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts"],"sourcesContent":["const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n"],"names":[],"mappings":";;;;;;;AAAM,MAAA,iBAAA,GAAA,QAAA,GAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AA8C9B,MAAA,mBAAA,GAAA,QAAA,GAAgC,CAAA;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AAyBhC,MAAA,gBAAA,GAAA,QAAA,GAA6B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AAsC7B,MAAA,kBAAA,GAAA,QAAA,GAA+B,CAAA;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4735, "column": 0}, "map": {"version":3,"file":"globalUniformsBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts"],"sourcesContent":["export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;IAAA,CAUtB;AACJ,EAAA;AAEO,MAAM,sBAAyB,GAAA;IAClC,IAAM,EAAA,yBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;QAAA,CAAA;IAAA,CAQtB;AACJ,EAAA;AAEO,MAAM,mBAAsB,GAAA;IAC/B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 4782, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4788, "column": 0}, "map": {"version":3,"file":"extractStructAndGroups.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts"],"sourcesContent":["export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n"],"names":["name"],"mappings":";;;;AAeO,SAAS,uBAAuB,IACvC,EAAA;IAEI,MAAM,WAAc,GAAA,wCAAA,CAAA;IACpB,MAAM,YAAe,GAAA,iBAAA,CAAA;IACrB,MAAM,cAAiB,GAAA,mBAAA,CAAA;IACvB,MAAM,WAAc,GAAA,qBAAA,CAAA;IACpB,MAAM,WAAc,GAAA,WAAA,CAAA;IACpB,MAAM,aAAgB,GAAA,6BAAA,CAAA;IACtB,MAAM,mBAAsB,GAAA,0BAAA,CAAA;IAC5B,MAAM,UAAa,GAAA,gBAAA,CAAA;IAGnB,MAAM,SAAS,IAAK,CAAA,KAAA,CAAM,WAAW,CAAG,EAAA,GAAA,CAAI,CAAC,IAAU,GAAA,CAAA;YACnD,KAAA,EAAO,SAAS,IAAK,CAAA,KAAA,CAAM,YAAY,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YAC/C,OAAA,EAAS,SAAS,IAAK,CAAA,KAAA,CAAM,cAAc,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YACnD,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;YAC/B,WAAW,IAAK,CAAA,KAAA,CAAM,WAAW,CAAA,CAAE,CAAC,CAAM,KAAA,WAAA;YAC1C,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;QAAA,CACjC,CAAA,CAAA,CAAA;IAEF,IAAI,CAAC,MACL,EAAA;QACW,OAAA;YACH,QAAQ,EAAC;YACT,SAAS,EAAC;QAAA,CACd,CAAA;IAAA,CACJ;IAGA,MAAM,UAAU,IACX,CAAA,KAAA,CAAM,aAAa,CAClB,EAAA,GAAA,CAAI,CAAC,MACP,KAAA;QACI,MAAM,IAAO,GAAA,MAAA,CAAO,KAAM,CAAA,UAAU,CAAA,CAAE,CAAC,CAAA,CAAA;QACjC,MAAA,OAAA,GAAU,OAAO,KAAM,CAAA,mBAAmB,EAAE,MAAO,CAAA,CAAC,KAA6B,MACvF,KAAA;YACI,MAAM,CAACA,KAAM,EAAA,IAAI,CAAI,GAAA,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAA;YAErC,GAAA,CAAIA,KAAK,CAAA,IAAA,EAAM,CAAA,GAAI,KAAK,IAAK,EAAA,CAAA;YAEtB,OAAA,GAAA,CAAA;QAAA,CACX,EAAG,CAAA,CAAE,CAAA,CAAA;QAEL,IAAI,CAAC,OACL,EAAA;YACW,OAAA,IAAA,CAAA;QAAA,CACX;QAEO,OAAA;YAAE;YAAM,OAAQ;QAAA,CAAA,CAAA;IAAA,CAE1B,CACA,CAAA,MAAA,CAAO,CAAC,EAAE,IAAA,EAAW,GAAA,MAAA,CAAO,IAAK,CAAA,CAAC,QAAU,KAAM,CAAA,IAAA,KAAS,IAAI,CAAC,KAAK,EAAC,CAAA;IAEpE,OAAA;QACH,MAAA;QACA,OAAA;IAAA,CACJ,CAAA;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4836, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4842, "column": 0}, "map": {"version":3,"file":"removeStructAndGroupDuplicates.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts"],"sourcesContent":["import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n"],"names":[],"mappings":";;;;AAEgB,SAAA,8BAAA,CACZ,sBAAA,EACA,wBAEJ,EAAA;IACU,MAAA,aAAA,GAAA,aAAA,GAAA,IAAoB,GAAI,EAAA,CAAA;IACxB,MAAA,eAAA,GAAA,aAAA,GAAA,IAAsB,GAAI,EAAA,CAAA;IAE1B,MAAA,OAAA,GAAU,CAAC;WAAG,sBAAuB,CAAA,OAAA,EAAS;WAAG,wBAAA,CAAyB,OAAO;KAAA,CAClF,MAAO,CAAA,CAAC,MACT,KAAA;QACI,IAAI,aAAc,CAAA,GAAA,CAAI,MAAO,CAAA,IAAI,CACjC,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACc,aAAA,CAAA,GAAA,CAAI,OAAO,IAAI,CAAA,CAAA;QAEtB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEC,MAAA,MAAA,GAAS,CAAC;WAAG,sBAAuB,CAAA,MAAA,EAAQ;WAAG,wBAAA,CAAyB,MAAM;KAAA,CAC/E,MAAO,CAAA,CAAC,KACT,KAAA;QACI,MAAM,MAAM,CAAG,EAAA,KAAA,CAAM,IAAI,CAAA,CAAA,EAAI,MAAM,OAAO,CAAA,CAAA,CAAA;QAEtC,IAAA,eAAA,CAAgB,GAAI,CAAA,GAAG,CAC3B,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACA,eAAA,CAAgB,GAAA,CAAI,GAAG,CAAA,CAAA;QAEhB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEE,OAAA;QAAE;QAAS,MAAO;IAAA,CAAA,CAAA;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 4877, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4883, "column": 0}, "map": {"version":3,"file":"generateLayoutHash.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts"],"sourcesContent":["import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;AAGgB,SAAA,kBAAA,CAAmB,EAAE,MAAA,EACrC,EAAA;IACI,MAAM,SAAwB,EAAC,CAAA;IAE/B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,CAAA,CAAC,CAAA;QAAA,CAC3B;QAEA,MAAA,CAAO,MAAM,KAAK,CAAA,CAAE,KAAM,CAAA,IAAI,CAAA,GAAI,KAAM,CAAA,OAAA,CAAA;IAAA,CAC5C;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4900, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4906, "column": 0}, "map": {"version":3,"file":"const.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts"],"sourcesContent":["export enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n"],"names":["ShaderStage"],"mappings":";;;;AAAY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,CAAV,CAAA,GAAA,SAAA,CAAA;IAJQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4924, "column": 0}, "map": {"version":3,"file":"generateGpuLayoutGroups.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts"],"sourcesContent":["import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;;;AAKgB,SAAA,uBAAA,CAAwB,EAAE,MAAA,EAC1C,EAAA;IACI,MAAM,SAA2C,EAAC,CAAA;IAElD,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,EAAC,CAAA;QAAA,CAC3B;QAEA,IAAI,MAAM,SACV,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,UAAA,+LAAY,cAAY,CAAA,MAAA,gMAAS,cAAY,CAAA,QAAA;gBAC7C,MAAQ,EAAA;oBACJ,IAAM,EAAA,SAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,SACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,yMAAY,cAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,IAAM,EAAA,WAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,YACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,yMAAY,cAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,UAAY,EAAA,OAAA;oBACZ,aAAe,EAAA,IAAA;oBACf,YAAc,EAAA,KAAA;gBAAA,CAClB;YAAA,CACH,CAAA,CAAA;QAAA,CACL;IAAA,CACJ;IAEO,OAAA,MAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 4969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4975, "column": 0}, "map": {"version":3,"file":"extractAttributesFromGpuProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n"],"names":[],"mappings":";;;;;;AAMA,MAAM,oBAAqD,GAAA;IAEvD,GAAM,EAAA,SAAA;IACN,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IAEP,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,IAAM,EAAA,QAAA;IACN,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;AAClB,CAAA,CAAA;AAEO,SAAS,+BACZ,CAAA,EAAE,MAAQ,EAAA,UAAA,EAEd,EAAA;IACI,MAAM,UAAkD,CAAA,CAAC,CAAA;IAGzD,MAAM,aAAgB,GAAA,MAAA,CAAO,OAAQ,CAAA,CAAA,GAAA,EAAM,UAAU,CAAE,CAAA,CAAA,CAAA;IAEvD,IAAI,kBAAkB,CACtB,CAAA,EAAA;QAEI,MAAM,kBAAqB,GAAA,MAAA,CAAO,OAAQ,CAAA,IAAA,EAAM,aAAa,CAAA,CAAA;QAE7D,IAAI,uBAAuB,CAC3B,CAAA,EAAA;YACI,MAAM,qBAAwB,GAAA,MAAA,CAAO,SAAU,CAAA,aAAA,EAAe,kBAAkB,CAAA,CAAA;YAGhF,MAAM,WAAc,GAAA,yEAAA,CAAA;YAChB,IAAA,KAAA,CAAA;YAEJ,MAAA,CAAQ,KAAQ,GAAA,WAAA,CAAY,IAAK,CAAA,qBAAqB,CAAA,MAAO,IAC7D,CAAA;gBACI,MAAM,MAAS,GAAA,oBAAA,CAAqB,KAAM,CAAA,CAAC,CAAiB,CAAK,IAAA,SAAA,CAAA;gBAEzD,OAAA,CAAA,KAAA,CAAM,CAAC,CAAC,CAAI,GAAA;oBAChB,QAAU,EAAA,QAAA,CAAS,KAAM,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;oBAC/B,MAAA;oBACA,MAAA,mOAAQ,6BAAA,AAA2B,EAAA,MAAM,CAAE,CAAA,MAAA;oBAC3C,MAAQ,EAAA,CAAA;oBACR,QAAU,EAAA,KAAA;oBACV,KAAO,EAAA,CAAA;gBAAA,CACX,CAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,OAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 5028, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5034, "column": 0}, "map": {"version":3,"file":"GpuProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5121, "column": 0}, "map": {"version":3,"file":"stripVersion.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts"],"sourcesContent":["export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,YAAA,CAAa,GAAA,EAAa,OAC1C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,EAAE,CAAA,CAAA;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 5131, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5137, "column": 0}, "map": {"version":3,"file":"ensurePrecision.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts"],"sourcesContent":["import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n"],"names":[],"mappings":";;;;AAsBgB,SAAA,eAAA,CACZ,GACA,EAAA,OAAA,EACA,UAEJ,EAAA;IACI,MAAM,qBAAwB,GAAA,UAAA,GAAa,OAAQ,CAAA,6BAAA,GAAgC,OAAQ,CAAA,2BAAA,CAAA;IAE3F,IAAI,GAAI,CAAA,SAAA,CAAU,CAAG,EAAA,CAAC,MAAM,WAC5B,EAAA;QAEI,IAAI,SAAY,GAAA,UAAA,GAAa,OAAQ,CAAA,0BAAA,GAA6B,OAAQ,CAAA,wBAAA,CAAA;QAGtE,IAAA,SAAA,KAAc,OAAW,IAAA,qBAAA,KAA0B,OACvD,EAAA;YACgB,SAAA,GAAA,SAAA,CAAA;QAAA,CAChB;QAEA,OAAO,CAAA,UAAA,EAAa,SAAS,CAAA;AAAA,EAAY,GAAG,CAAA,CAAA,CAAA;IAAA,CAChD,MAAA,IACS,0BAA0B,OAAW,IAAA,GAAA,CAAI,SAAA,CAAU,CAAG,EAAA,EAAE,MAAM,iBACvE,EAAA;QAEW,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,mBAAmB,CAAA,CAAA;IAAA,CAC7D;IAEO,OAAA,GAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 5157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5163, "column": 0}, "map": {"version":3,"file":"addProgramDefines.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts"],"sourcesContent":["export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,iBAAA,CAAkB,GAAa,EAAA,OAAA,EAAkB,UACjE,EAAA;IACQ,IAAA,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEpB,IAAI,UACJ,EAAA;QACU,GAAA,GAAA,GAAA,CAAI,OAAQ,CAAA,sBAAA,EAAwB,EAAE,CAAA,CAAA;QAErC,OAAA,CAAA;;;;;;;QAAA,EAOL,GAAG,CAAA;QAAA,CAAA,CAAA;IAAA,CAET;IAEO,OAAA,CAAA;;;;;;QAAA,EAMD,GAAG,CAAA;QAAA,CAAA,CAAA;AAEb","ignoreList":[0]}},
    {"offset": {"line": 5192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5198, "column": 0}, "map": {"version":3,"file":"setProgramName.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts"],"sourcesContent":["const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,oBAA+C,CAAA,CAAC,CAAA;AACtD,MAAM,kBAA6C,CAAA,CAAC,CAAA;AAE7C,SAAS,eAAe,GAAa,EAAA,EAAE,OAAO,CAAe,YAAA,CAAA,EAAA,EAAsB,aAAa,IACvG,EAAA;IACW,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;IAE/B,IAAA,IAAQ,aAAa,WAAc,GAAA,SAAA,CAAA;IAE7B,MAAA,SAAA,GAAY,aAAa,iBAAoB,GAAA,eAAA,CAAA;IAE/C,IAAA,SAAA,CAAU,IAAI,CAClB,EAAA;QACI,SAAA,CAAU,IAAI,CAAA,EAAA,CAAA;QACN,IAAA,IAAA,CAAA,CAAA,EAAI,SAAU,CAAA,IAAI,CAAC,CAAA,CAAA,CAAA;IAAA,CAG/B,MAAA;QACI,SAAA,CAAU,IAAI,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAGI,IAAA,GAAA,CAAI,OAAQ,CAAA,qBAAqB,CAAM,KAAA,CAAA,CAAA,EAAW,OAAA,GAAA,CAAA;IAEhD,MAAA,UAAA,GAAa,CAAA,oBAAA,EAAuB,IAAI,CAAA,CAAA,CAAA;IAE9C,OAAO,GAAG,UAAU,CAAA;AAAA,EAAK,GAAG,CAAA,CAAA,CAAA;AAChC","ignoreList":[0]}},
    {"offset": {"line": 5221, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5227, "column": 0}, "map": {"version":3,"file":"insertVersion.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts"],"sourcesContent":["export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n"],"names":[],"mappings":";;;;AAAgB,SAAA,aAAA,CAAc,GAAA,EAAa,OAC3C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,CAAA;AAAA,EAAoB,GAAG,CAAA,CAAA,CAAA;AAClC","ignoreList":[0]}},
    {"offset": {"line": 5238, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5244, "column": 0}, "map": {"version":3,"file":"getMaxFragmentPrecision.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts"],"sourcesContent":["import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n"],"names":[],"mappings":";;;;;;AAIA,IAAI,oBAAA,CAAA;AAEG,SAAS,uBAChB,GAAA;IACI,IAAI,CAAC,oBACL,EAAA;QAC2B,oBAAA,GAAA,SAAA,CAAA;QACvB,MAAM,sNAAK,iBAAA,AAAe,EAAA,CAAA;QAE1B,IAAI,EACJ,EAAA;YACI,IAAI,GAAG,wBACP,EAAA;gBACI,MAAM,iBAAiB,EAAG,CAAA,wBAAA,CAAyB,EAAG,CAAA,eAAA,EAAiB,GAAG,UAAU,CAAA,CAAA;gBAE7D,oBAAA,GAAA,cAAA,CAAe,SAAA,GAAY,OAAU,GAAA,SAAA,CAAA;YAAA,CAChE;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,oBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 5266, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5272, "column": 0}, "map": {"version":3,"file":"GlProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5368, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5374, "column": 0}, "map": {"version":3,"file":"compileHighShaderToProgram.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts"],"sourcesContent":["import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAQO,SAAS,2BAA4B,CAAA,EAAE,IAAM,EAAA,IAAA,EACpD,EAAA;IACI,MAAM,SAAS,8NAAA,AAAkB,EAAA;QAC7B,QAAU,EAAA;YACN,QAAU,iMAAA,sBAAA;YACV,MAAQ,iMAAA,oBAAA;QAAA,CACZ;QACA,IAAM,EAAA;wNACF,oBAAA;eACG,IAAA;SACP;IAAA,CACH,CAAA,CAAA;IAED,sMAAO,aAAA,CAAW,IAAK,CAAA;QACnB,IAAA;QACA,MAAQ,EAAA;YACJ,QAAQ,MAAO,CAAA,MAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;QACA,QAAU,EAAA;YACN,QAAQ,MAAO,CAAA,QAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;IAAA,CACH,CAAA,CAAA;AACL,CAAA;AAEO,SAAS,0BAA2B,CAAA,EAAE,IAAM,EAAA,IAAA,EACnD,EAAA;IACI,OAAO,iMAAI,YAAU,CAAA;QACjB,IAAA;QACA,GAAG,gOAAA,AAAoB,EAAA;YACnB,QAAU,EAAA;gBACN,MAAQ,iMAAA,mBAAA;gBACR,QAAU,iMAAA,qBAAA;YAAA,CACd;YACA,IAAM,EAAA;4NACF,sBAAA;mBACG,IAAA;aACP;QAAA,CACH,CAAA;IAAA,CACJ,CAAA,CAAA;AACL","ignoreList":[0]}},
    {"offset": {"line": 5429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5435, "column": 0}, "map": {"version":3,"file":"localUniformBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,eAAkB,GAAA;IAC3B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;QAUlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ,EAAA;AAGO,MAAM,qBAAwB,GAAA;IACjC,GAAG,eAAA;IACH,MAAQ,EAAA;QACJ,GAAG,eAAgB,CAAA,MAAA;QAAA,qBAAA;QAEnB,QAAQ,eAAgB,CAAA,MAAA,CAAO,MAAO,CAAA,OAAA,CAAQ,YAAY,UAAU,CAAA;IAAA,CACxE;AACJ,EAAA;AAEO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5497, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5503, "column": 0}, "map": {"version":3,"file":"textureBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts"],"sourcesContent":["export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;AAAO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;QAAA,CAAA;QAQlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ,EAAA;AAEO,MAAM,YAAe,GAAA;IACxB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;QAAA,CAAA;QAKlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5558, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5564, "column": 0}, "map": {"version":3,"file":"roundPixelsBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts"],"sourcesContent":["export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;AAAO,MAAM,cAAiB,GAAA;IAC1B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AACJ,EAAA;AAEO,MAAM,gBAAmB,GAAA;IAC5B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;IAAA,CAMtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5593, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5599, "column": 0}, "map": {"version":3,"file":"types.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/types.ts"],"sourcesContent":["import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n"],"names":["RendererType"],"mappings":";;;;AA2BY,IAAA,YAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,aAAL,KAAA;IAEHA,aAAAA,CAAAA,aAAAA,CAAA,QAAA,GAAQ,CAAR,CAAA,GAAA,OAAA,CAAA;IACAA,aAAAA,CAAAA,aAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IACAA,aAAAA,CAAAA,aAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAJQA,OAAAA,aAAAA,CAAAA;AAAA,CAAA,EAAA,YAAA,IAAA,CAAA,CAAA","ignoreList":[0]}},
    {"offset": {"line": 5611, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5617, "column": 0}, "map": {"version":3,"file":"BindGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts"],"sourcesContent":["import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5709, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5715, "column": 0}, "map": {"version":3,"file":"Shader.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5902, "column": 0}, "map": {"version":3,"file":"GlMeshAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @memberof rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAkBO,MAAM,aACb,CAAA;IAUW,IACP,GAAA;QACI,MAAM,mNAAY,6BAAA,AAA2B,EAAA;YACzC,IAAM,EAAA,MAAA;YACN,IAAM,EAAA;0NACF,oBAAA;qNACA,eAAA;yNACA,mBAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEI,IAAA,CAAA,OAAA,GAAU,kMAAI,SAAO,CAAA;YACtB,SAAA;YACA,SAAW,EAAA;gBACP,QAAA,kMAAU,UAAA,CAAQ,KAAM,CAAA,MAAA;gBACxB,eAAiB,EAAA;oBACb,gBAAgB;wBAAE,IAAA,EAAM;wBAAe,KAAO,EAAA,IAAI,4KAAA,EAAS;oBAAA,CAAA;gBAAA,CAC/D;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,CAAQ,QAAA,EAAoB,IACnC,EAAA;QACI,MAAM,WAAW,QAAS,CAAA,QAAA,CAAA;QAE1B,IAAI,SAAiB,IAAK,CAAA,OAAA,CAAA;QAE1B,IAAI,CAAC,MACL,EAAA;YACI,MAAA,GAAS,IAAK,CAAA,OAAA,CAAA;YAEd,MAAM,UAAU,IAAK,CAAA,OAAA,CAAA;YACrB,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAA;YAEvB,MAAA,CAAO,SAAA,CAAU,QAAW,GAAA,MAAA,CAAA;YACrB,MAAA,CAAA,SAAA,CAAU,QAAA,GAAW,MAAO,CAAA,KAAA,CAAA;YACnC,MAAA,CAAO,SAAU,CAAA,eAAA,CAAgB,QAAS,CAAA,cAAA,GAAiB,QAAQ,aAAc,CAAA,QAAA,CAAA;QAAA,CACrF,MAAA,IACS,CAAC,MAAA,CAAO,SACjB,EAAA;kLAES,OAAA,EAAA,8BAAA,EAAgC,KAAK,MAAM,CAAA,CAAA;YAGhD,OAAA;QAAA,CACJ;QAIA,MAAA,CAAO,MAAO,CAAA,GAAG,CAAI,GAAA,QAAA,CAAS,cAAe,CAAA,SAAA,CAAA;QACtC,MAAA,CAAA,MAAA,CAAO,GAAG,CAAA,GAAI,QAAS,CAAA,sBAAA,CAAA;QAE9B,QAAA,CAAS,OAAA,CAAQ,IAAK,CAAA;YAClB,UAAU,IAAK,CAAA,SAAA;YACf,MAAA;YACA,OAAO,IAAK,CAAA,KAAA;QAAA,CACf,CAAA,CAAA;IAAA,CACL;IAEO,OACP,GAAA;QACS,IAAA,CAAA,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA,CAAA;QACzB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;IAAA,CACnB;AACJ,CAAA;AA5Ea,aAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;0KACF,gBAAc,CAAA,iBAAA;KAClB;IACA,IAAM,EAAA,MAAA;AACV,CAAA","ignoreList":[0]}},
    {"offset": {"line": 5982, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5988, "column": 0}, "map": {"version":3,"file":"colorBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts"],"sourcesContent":["export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n"],"names":[],"mappings":";;;;;AAAO,MAAM,QAAW,GAAA;IACpB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ,EAAA;AAEO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 6017, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6023, "column": 0}, "map": {"version":3,"file":"generateTextureBatchBit.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6158, "column": 0}, "map": {"version":3,"file":"getBatchSamplersUniformGroup.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts"],"sourcesContent":["import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,gCAA8D,CAAA,CAAC,CAAA;AAQ9D,SAAS,6BAA6B,WAC7C,EAAA;IACQ,IAAA,yBAAA,GAA4B,6BAAA,CAA8B,WAAW,CAAA,CAAA;IAErE,IAAA,yBAAA,EAAkC,OAAA,yBAAA,CAAA;IAEhC,MAAA,YAAA,GAAe,IAAI,UAAA,CAAW,WAAW,CAAA,CAAA;IAE/C,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,CAAA;QACI,YAAA,CAAa,CAAC,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAEA,yBAAA,GAA4B,6BAA8B,CAAA,WAAW,CAAI,GAAA,wMAAI,eAAa,CAAA;QACtF,WAAW;YAAE,KAAA,EAAO;YAAc,IAAM,EAAA,CAAA,GAAA,CAAA;YAAO,MAAM,WAAY;QAAA,CAAA;IAAA,CAClE,EAAA;QAAE,QAAU,EAAA,IAAA;IAAA,CAAM,CAAA,CAAA;IAEd,OAAA,yBAAA,CAAA;AACX","ignoreList":[0]}},
    {"offset": {"line": 6185, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6191, "column": 0}, "map": {"version":3,"file":"GlGraphicsAdaptor.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.state.set(graphicsPipe.state);\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(batcher.geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.count; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw(batch.topology, batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6290, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6296, "column": 0}, "map": {"version":3,"file":"WebGLRenderer.mjs","sources":["file://D%3A/dev/slot-game/frontend/node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\ntype WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems> & PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @memberof rendering\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @memberof rendering\n */\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link rendering.GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link rendering.GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link rendering.GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link rendering.GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link rendering.GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link rendering.GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GlUboSystem} ubo - UboSystem instance.\n * @property {rendering.GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {rendering.GlContextSystem} context - ContextSystem instance.\n * @property {rendering.GlBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GlTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {rendering.GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {rendering.GlShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GlStateSystem} state - StateSystem instance.\n * @property {rendering.GlStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends rendering.AbstractRenderer\n */\n/* eslint-enable max-len */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,MAAM,mBAAsB,GAAA;4MACrB,gBAAA;IACH,mMAAA;gMACA,qBAAA;wMACA,kBAAA;sMACA,iBAAA;wMACA,kBAAA;kNACA,uBAAA;0MACA,mBAAA;IACA,+NAAA;sMACA,iBAAA;6LACA,kBAAA;oMACA,gBAAA;6LACA,kBAAA;+LACA,oBAAA;CACJ,CAAA;AACA,MAAM,iBAAA,GAAoB,CAAC;4MAAG,oBAAiB;CAAA,CAAA;AAC/C,MAAM,oBAAuB,GAAA;0LAAC,iBAAgB;kLAAA,gBAAA;0LAAe,oBAAiB;CAAA,CAAA;AAG9E,MAAM,UAAwD,EAAC,CAAA;AAC/D,MAAM,cAA0D,EAAC,CAAA;AACjE,MAAM,qBAAqD,EAAC,CAAA;kKAE5D,aAAW,CAAA,iBAAA,mKAAkB,gBAAc,CAAA,WAAA,EAAa,OAAO,CAAA,CAAA;iKAC/D,cAAW,CAAA,iBAAA,mKAAkB,gBAAc,CAAA,UAAA,EAAY,WAAW,CAAA,CAAA;kKAClE,aAAW,CAAA,iBAAA,mKAAkB,gBAAc,CAAA,iBAAA,EAAmB,kBAAkB,CAAA,CAAA;kKAGhF,aAAA,CAAW,GAAA,CAAI,GAAG,mBAAA,EAAqB,GAAG,iBAAA,EAAmB,GAAG,oBAAoB,CAAA,CAAA;AA6F7E,MAAM,8NACD,mBAEZ,CAAA;IAGI,WACA,EAAA;QACI,MAAM,YAAe,GAAA;YACjB,IAAM,EAAA,OAAA;YACN,+KAAM,eAAa,CAAA,KAAA;YACnB,OAAA;YACA,WAAA;YACA,kBAAA;QAAA,CACJ,CAAA;QAEA,KAAA,CAAM,YAAY,CAAA,CAAA;IAAA,CACtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 6385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}